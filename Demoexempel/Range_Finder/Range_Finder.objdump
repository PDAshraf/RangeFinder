
Range_Finder.elf:     file format elf32-littlenios2
Range_Finder.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000a029c

Program Header:
    LOAD off    0x00001000 vaddr 0x000a0000 paddr 0x000a0000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x000a0020 paddr 0x000a0020 align 2**12
         filesz 0x000054d4 memsz 0x000054d4 flags r-x
    LOAD off    0x000064f4 vaddr 0x000a54f4 paddr 0x000a586c align 2**12
         filesz 0x00000378 memsz 0x00000378 flags rw-
    LOAD off    0x00006be4 vaddr 0x000a5be4 paddr 0x000a5be4 align 2**12
         filesz 0x00000000 memsz 0x00001538 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  000a0000  000a0000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000027c  000a0020  000a0020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00004cbc  000a029c  000a029c  0000129c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000059c  000a4f58  000a4f58  00005f58  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000378  000a54f4  000a586c  000064f4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00001538  000a5be4  000a5be4  00006be4  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_ram   00000000  000a711c  000a711c  0000686c  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  0000686c  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000710  00000000  00000000  00006890  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0000a9fb  00000000  00000000  00006fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003287  00000000  00000000  0001199b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00003b14  00000000  00000000  00014c22  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000010c8  00000000  00000000  00018738  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001f02  00000000  00000000  00019800  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000013ee  00000000  00000000  0001b702  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  0001caf0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000360  00000000  00000000  0001cb00  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0001f00a  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0001f00d  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001f010  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001f011  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0001f012  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0001f016  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0001f01a  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  0001f01e  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  0001f027  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  0001f030  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000c  00000000  00000000  0001f039  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000032  00000000  00000000  0001f045  2**0
                  CONTENTS, READONLY
 29 .jdi          00004c41  00000000  00000000  0001f077  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     0006dd8d  00000000  00000000  00023cb8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
000a0000 l    d  .entry	00000000 .entry
000a0020 l    d  .exceptions	00000000 .exceptions
000a029c l    d  .text	00000000 .text
000a4f58 l    d  .rodata	00000000 .rodata
000a54f4 l    d  .rwdata	00000000 .rwdata
000a5be4 l    d  .bss	00000000 .bss
000a711c l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Range_Finder_bsp//obj/HAL/src/crt0.o
000a02d4 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main_range_finder.c
00000000 l    df *ABS*	00000000 task_avg_range_code.c
00000000 l    df *ABS*	00000000 task_idle_code.c
00000000 l    df *ABS*	00000000 task_range_code.c
00000000 l    df *ABS*	00000000 task_range_print_code.c
00000000 l    df *ABS*	00000000 task_servo_position_code.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
000a1408 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
000a5594 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
000a1af4 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
000a1c4c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
000a1d88 l     F .text	00000034 alt_dev_reg
000a5674 l     O .rwdata	0000002c jtag_uart
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 draw_vga.c
00000000 l    df *ABS*	00000000 sierra.c
000a2ec4 l     F .text	0000004c init_Sierra_interrupt
00000000 l    df *ABS*	00000000 sierra_sem.c
00000000 l    df *ABS*	00000000 sierra_task.c
00000000 l    df *ABS*	00000000 sierra_time.c
00000000 l    df *ABS*	00000000 soft_drivers.c
00000000 l    df *ABS*	00000000 alt_close.c
000a418c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
000a42c0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
000a42ec l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
000a43ec l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
000a46cc l     F .text	0000003c alt_get_errno
000a4708 l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 char_map.c
00000000 l    df *ABS*	00000000 csw.o
000a4a84 l       .text	00000000 restore_context
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
000a5c10 g     O .bss	00000004 current_tcb
000a1be0 g     F .text	0000006c alt_main
000a1358 g     F .text	00000080 _puts_r
000a701c g     O .bss	00000100 alt_irq
000a0684 g     F .text	0000089c task_range_print_code
00000000 g       .debug_aranges	00000000 alt_exception_trap
000a33c4 g     F .text	0000008c sem_release
000a3c1c g     F .text	00000070 init_period_time
000a586c g       *ABS*	00000000 __flash_rwdata_start
000a5c1c g     O .bss	00000320 task_avg_range_stack
000a6bbc g     O .bss	00000460 TCB_LIST
000a2fdc g     F .text	00000098 Sierra_Initiation_HW_and_SW
000a130c g     F .text	0000004c printf
000a49f8 g     F .text	00000040 upper_char_line
000a54f4 g     O .rwdata	000000a0 circleData
000a398c g     F .text	000000c4 task_block
000a35b8 g     F .text	0000008c flag_set
000a49d4 g     F .text	00000024 altera_nios2_gen2_irq_init
000a0000 g     F .entry	0000000c __reset
000a2d8c g     F .text	00000138 int_print
000a385c g     F .text	000000a4 task_getinfo
000a0020 g       *ABS*	00000000 __flash_exceptions_start
000a5bfc g     O .bss	00000004 errno
000a016c g       .exceptions	00000000 .Ltrap_handler
000a5c04 g     O .bss	00000004 alt_argv
000ad848 g       *ABS*	00000000 _gp
000a0590 g     F .text	000000f4 task_range_code
000a5f3c g     O .bss	00000320 task_servo_position_stack
000a56c8 g     O .rwdata	00000180 alt_fd_list
000a2f10 g     F .text	00000030 sierra_SW_driver_version
000a5378 g     O .rodata	0000017c font32lower
000a4ae8 g     F .text	00000090 alt_find_dev
000a2190 g     F .text	00000090 draw_vline
000a44d0 g     F .text	0000007c alt_io_redirect
000a5be4 g     O .bss	00000004 x_val
000a13d8 g     F .text	00000014 puts
000a3198 g     F .text	0000004c tsw_off
000a1eec g     F .text	000000ec altera_avalon_jtag_uart_read
000a12d0 g     F .text	0000003c _printf_r
000a1214 g     F .text	00000064 .hidden __udivsi3
000a3b88 g     F .text	00000094 task_yield
000a625c g     O .bss	00000320 idle_stack
000a3148 g     F .text	00000050 tsw_on
000a657c g     O .bss	00000320 task_range_stack
000a5860 g     O .rwdata	00000004 alt_max_fd
000a3acc g     F .text	000000bc task_change_prio
000a2bb0 g     F .text	000001dc char_print
000a454c g     F .text	00000180 alt_irq_register
000a5848 g     O .rwdata	00000004 _global_impure_ptr
000a711c g       *ABS*	00000000 __bss_end
000a5be8 g     O .bss	00000004 distance
000a00e4 g       .exceptions	00000000 sierra_irq_or_trap
000a3de4 g     F .text	000000d8 init_screen
000a5c18 g     O .bss	00000004 alt_irq_active
000a01c8 g     F .exceptions	000000d4 alt_irq_handler
000a56a0 g     O .rwdata	00000028 alt_dev_null
000a42a0 g     F .text	00000020 alt_dcache_flush_all
000a4ae0 g       .text	00000000 SW_CTX_SWITCH
000a586c g       *ABS*	00000000 __ram_rwdata_end
000a5858 g     O .rwdata	00000008 alt_dev_list
000a1c88 g     F .text	00000100 write
000a54f4 g       *ABS*	00000000 __ram_rodata_end
000a00b4 g       .exceptions	00000000 context_switch
000a3ebc g     F .text	0000010c pattern
000a1278 g     F .text	00000058 .hidden __umodsi3
000a34f4 g     F .text	000000c4 flag_wait
000a711c g       *ABS*	00000000 end
000a4a78 g       .text	00000000 HW_CTX_SWITCH
000a5c14 g     O .bss	00000001 NEXT_TASKID
000c0000 g       *ABS*	00000000 __alt_stack_pointer
000a1fd8 g     F .text	00000094 altera_avalon_jtag_uart_write
000a0150 g       .exceptions	00000000 interrupt_testing
000a1474 g     F .text	0000052c ___vfprintf_internal_r
000a4d94 g     F .text	00000190 __call_exitprocs
000a029c g     F .text	0000003c _start
000a2104 g     F .text	0000008c draw_hline
000a1df4 g     F .text	00000038 alt_sys_init
000a1acc g     F .text	00000028 .hidden __mulsi3
000a54f4 g       *ABS*	00000000 __ram_rwdata_start
000a4f58 g       *ABS*	00000000 __ram_rodata_start
000a1e2c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
000a4c80 g     F .text	000000c4 alt_get_fd
000a3644 g     F .text	0000008c flag_clear
000a4d64 g     F .text	00000030 memcmp
000a36d0 g     F .text	0000018c task_create
000a711c g       *ABS*	00000000 __alt_stack_base
000a0f20 g     F .text	000001fc task_servo_position_code
000a3c8c g     F .text	000000ac wait_for_next_period
000a272c g     F .text	00000240 draw_angled_line
000a4b78 g     F .text	00000108 alt_find_file
000a4328 g     F .text	000000a4 alt_dev_llist_insert
000a4150 g     F .text	0000003c DELAY
000a3074 g     F .text	000000d4 get_next_task
000a19bc g     F .text	000000b8 __sfvwrite_small_dev
000a5be4 g       *ABS*	00000000 __bss_start
000a5c15 g     O .bss	00000001 RUNNING_TASKID
000a02d8 g     F .text	00000208 main
000a5c0c g     O .bss	00000004 first_csw
000a5c08 g     O .bss	00000004 alt_envp
000a1e8c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
000a5864 g     O .rwdata	00000004 alt_errno
000a5bec g     O .bss	00000004 dist_avg
000a111c g     F .text	00000084 .hidden __divsi3
000a2f40 g     F .text	00000034 sierra_HW_version
000a5bf0 g     O .bss	00000002 m_pos
000a4f58 g       *ABS*	00000000 __flash_rodata_start
000a2f74 g     F .text	00000034 SierraTime_base_reg
000a3d38 g     F .text	000000ac delay
000a31e4 g     F .text	00000058 get_new_task
000a1dbc g     F .text	00000038 alt_irq_init
000a4950 g     F .text	00000084 alt_release_fd
000a51fc g     O .rodata	0000017c font32upper
000a1a74 g     F .text	00000058 _write_r
000a4a7c g       .text	00000000 gettask
000a689c g     O .bss	00000320 task_range_print_stack
000a3a50 g     F .text	0000007c task_delete
000a4a38 g     F .text	00000040 lower_char_line
000a584c g     O .rwdata	00000004 _impure_ptr
000a5c00 g     O .bss	00000004 alt_argc
000a04e0 g     F .text	000000a0 task_avg_range_code
000a0580 g     F .text	00000010 task_idle_code
000a0020 g       .exceptions	00000000 alt_irq_entry
000a5850 g     O .rwdata	00000008 alt_fs_list
000a0020 g       *ABS*	00000000 __ram_exceptions_start
000a586c g       *ABS*	00000000 _edata
000a711c g       *ABS*	00000000 _end
000a00e0 g       .exceptions	00000000 sierra_trap
000a029c g       *ABS*	00000000 __ram_exceptions_end
000a2fa8 g     F .text	00000034 set_timebase
000a3900 g     F .text	0000008c task_start
000a4d44 g     F .text	00000020 exit
000a11a0 g     F .text	00000074 .hidden __modsi3
000c0000 g       *ABS*	00000000 __alt_data_end
000a0020 g     F .exceptions	00000000 alt_exception
000a3300 g     F .text	000000c4 sem_take
000a3450 g     F .text	000000a4 sem_read
000a0000 g       *ABS*	00000000 __alt_mem_onchip_ram
000a4f24 g     F .text	00000034 _exit
000a2220 g     F .text	000002e8 draw_circle
000a3fc8 g     F .text	00000188 testFunction
000a2508 g     F .text	00000224 draw_filled_circle
000a323c g     F .text	000000c4 irq_wait
000a5bf4 g     O .bss	00000004 dist_sum
000a13ec g     F .text	0000001c strlen
000a47f4 g     F .text	0000015c open
000a43cc g     F .text	00000020 alt_icache_flush_all
000a5bf8 g     O .bss	00000004 y_val
000a5868 g     O .rwdata	00000004 alt_priority_mask
000a19a0 g     F .text	0000001c __vfprintf_internal
000a206c g     F .text	00000098 clear_screen
000a296c g     F .text	00000244 tty_print
000a41c8 g     F .text	000000d8 close
000a1b5c g     F .text	00000084 alt_load



Disassembly of section .entry:

000a0000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   a0000:	004002b4 	movhi	at,10
    ori r1, r1, %lo(_start)
   a0004:	0840a714 	ori	at,at,668
    jmp r1
   a0008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

000a0020 <alt_exception>:
         */
         
        /*
         * !S Is the exception caused by a Sierra HW IRQ?
         */
        addi  	sp, sp, -8			 	# used registers to stack
   a0020:	defffe04 	addi	sp,sp,-8
        stwio  	r2, 0(sp) 
   a0024:	d8800035 	stwio	r2,0(sp)
        stwio  	at, 4(sp)
   a0028:	d8400135 	stwio	at,4(sp)
   a002c:	00400334 	movhi	at,12
        
        movia 	at, CPUstatusB_reg
   a0030:	08440c04 	addi	at,at,4144
   	    ldwio 	at, 0(at)    			# Read Status-register B
   a0034:	08400037 	ldwio	at,0(at)
   	    andi  	at, at, 1               # Only lowest bit is interesting
   a0038:	0840004c 	andi	at,at,1
   	    bgtu  	at, r0, context_switch 	# If the bit is set (at>0), it is  
   a003c:	00401d36 	bltu	zero,at,a00b4 <context_switch>
   	    						      	# a Sierra HW irq (HW ctx swtich)

        /*
         * !S Is the exception caused by a Sierra trap?
         */
        ldwio r2, -4(ea)              	/* last instr. op-code is put in r2 */ 
   a0040:	e8bfff37 	ldwio	r2,-4(ea)
        movhi at, 0x003b              	/* upper half of trap opcode */
   a0044:	00400ef4 	movhi	at,59
        ori   at, at, 0x683a          	/* lower half of trap opcode */
   a0048:	085a0e94 	ori	at,at,26682
        beq   r2, at, sierra_trap 		# Sierra trap (SW ctx switch)
   a004c:	10402426 	beq	r2,at,a00e0 <sierra_trap>
           
        /*
         * !S Not Sierra irq or exception. Restore r2, at and stack
         */   

       ldwio r2, 0(sp)
   a0050:	d8800037 	ldwio	r2,0(sp)
       ldwio at, 4(sp)
   a0054:	d8400137 	ldwio	at,4(sp)
       addi sp, sp, 8 					# sp now in original position (1/3)
   a0058:	dec00204 	addi	sp,sp,8

# normal exception.entry starts here       
       addi  sp, sp, -76
   a005c:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
   a0060:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
   a0064:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   a0068:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   a006c:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   a0070:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   a0074:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   a0078:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   a007c:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
   a0080:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
   a0084:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   a0088:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   a008c:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   a0090:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   a0094:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   a0098:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   a009c:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   a00a0:	dbc01015 	stw	r15,64(sp)

        stw   r5,  68(sp) 		/* r5=estatus */ 
   a00a4:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4 		/* re-issue the interrupted instruction */
   a00a8:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   a00ac:	dbc01215 	stw	r15,72(sp)
        
        br 	  interrupt_testing # !S Branch added to avoid sierra routines
   a00b0:	00002706 	br	a0150 <interrupt_testing>

000a00b4 <context_switch>:
   a00b4:	008002b4 	movhi	r2,10
       /* 
        * Do not save context on first tsw interrupt 
        * (no task status needs to be saved) 
        */

   		movia 	r2, first_csw 
   a00b8:	10970304 	addi	r2,r2,23564
   		ldwio   at, 0(r2)
   a00bc:	10400037 	ldwio	at,0(r2)
   		bgtu  	at, r0, sierra_irq_or_trap		# Jump to if first_csw != 0
   a00c0:	00400836 	bltu	zero,at,a00e4 <sierra_irq_or_trap>
   		
   		addi  	at, r0, 1            			# Set first_csw = 1
   a00c4:	00400044 	movi	at,1
   		stwio   at, 0(r2)						# first_csw(et) <- (at)
   a00c8:	10400035 	stwio	at,0(r2)
		
		ldwio	r2, 0(sp)					# restore r2, at and stack
   a00cc:	d8800037 	ldwio	r2,0(sp)
		ldwio 	at, 4(sp) 
   a00d0:	d8400137 	ldwio	at,4(sp)
   		addi 	sp, sp, 8					# sp now in original position (2/3)
   a00d4:	dec00204 	addi	sp,sp,8
   		rdctl 	r5, estatus
   a00d8:	000b307a 	rdctl	r5,estatus
 		br 		interrupt_testing			# results in jump to HW_CTX_SWITCH 
   a00dc:	00001c06 	br	a0150 <interrupt_testing>

000a00e0 <sierra_trap>:
	 * !S Save content of registers into running tasks tcb 
	 * (hw irq or sw trap) 
	 */
sierra_trap: 

		addi ea, ea, 4		/* !S add ea temporary so save register can be used 
   a00e0:	ef400104 	addi	ea,ea,4

000a00e4 <sierra_irq_or_trap>:
		                       by both hw irq and sw trap */
		
		
sierra_irq_or_trap:

		ldwio 	r2, 0(sp)
   a00e4:	d8800037 	ldwio	r2,0(sp)

		ldwio 	at, 4(sp) 				
   a00e8:	d8400137 	ldwio	at,4(sp)
    	stwio	at, TCB_REG_AT(at)
   a00ec:	08400235 	stwio	at,8(at)
       	
       	addi 	sp, sp, 8			  # sp now in original position (3/3)
   a00f0:	dec00204 	addi	sp,sp,8
   a00f4:	004002b4 	movhi	at,10
       	       	
       	movia	at, current_tcb		  # at = current_tcb
   a00f8:	08570404 	addi	at,at,23568
	    ldwio   at, 0(at)			  # Get address to current_tcb variable
   a00fc:	08400037 	ldwio	at,0(at)
 
		stwio	r2, TCB_REG_RETURNVALUES+0(at)
   a0100:	08800335 	stwio	r2,12(at)
   		stwio	r3, TCB_REG_RETURNVALUES+4(at)
   a0104:	08c00435 	stwio	r3,16(at)
    
   		stwio	r4, TCB_REG_ARG+0(at)
   a0108:	09000535 	stwio	r4,20(at)
   		stwio	r5, TCB_REG_ARG+4(at)
   a010c:	09400635 	stwio	r5,24(at)
   		stwio	r6, TCB_REG_ARG+8(at)
   a0110:	09800735 	stwio	r6,28(at)
		stwio 	r7, TCB_REG_ARG+12(at)
   a0114:	09c00835 	stwio	r7,32(at)
	
		rdctl r5, estatus 
   a0118:	000b307a 	rdctl	r5,estatus
	
		stwio	r8,  TCB_REG_GPR+0(at)
   a011c:	0a000935 	stwio	r8,36(at)
		stwio	r9,  TCB_REG_GPR+4(at)
   a0120:	0a400a35 	stwio	r9,40(at)
		stwio	r10, TCB_REG_GPR+8(at)
   a0124:	0a800b35 	stwio	r10,44(at)
		stwio	r11, TCB_REG_GPR+12(at)
   a0128:	0ac00c35 	stwio	r11,48(at)
		stwio	r12, TCB_REG_GPR+16(at)
   a012c:	0b000d35 	stwio	r12,52(at)
		stwio	r13, TCB_REG_GPR+20(at)
   a0130:	0b400e35 	stwio	r13,56(at)
		stwio	r14, TCB_REG_GPR+24(at)
   a0134:	0b800f35 	stwio	r14,60(at)
		stwio	r15, TCB_REG_GPR+28(at)
   a0138:	0bc01035 	stwio	r15,64(at)
	
 		# r16-r23 is callee saved registers
		/* r24, r25 not affected */
		/* r26, GP not affected */
	
    	stwio	sp, TCB_STACKPTR(at) 	# r27
   a013c:	0ec01e35 	stwio	sp,120(at)
	
		stwio	r28, TCB_REG_FP(at)
   a0140:	0f001b35 	stwio	fp,108(at)

        addi  	r15, ea, -4 	        # s49 nios ref, hw isr must substract -4 from ea
   a0144:	ebffff04 	addi	r15,ea,-4
        								# trap case is handled later
        stwio   r15, TCB_REG_EA(at)		# r29 return address from interrupt
   a0148:	0bc01c35 	stwio	r15,112(at)

		/* r30 not affected */
		stwio	ra, TCB_REG_RA(at)		# r31 return address  to subrutine
   a014c:	0fc01d35 	stwio	ra,116(at)

000a0150 <interrupt_testing>:
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   a0150:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   a0154:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   a0158:	10000326 	beq	r2,zero,a0168 <interrupt_testing+0x18>
        beq   r4, zero, .Lnot_irq
   a015c:	20000226 	beq	r4,zero,a0168 <interrupt_testing+0x18>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   a0160:	00a01c80 	call	a01c8 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   a0164:	00000306 	br	a0174 <.Ltrap_handler+0x8>
        /*
         * The other exception handling code goes here.
         */
         
         #/////////////////////////////////
         br .Ltrap_handler   # !S taskswitch trap 
   a0168:	00000006 	br	a016c <.Ltrap_handler>

000a016c <.Ltrap_handler>:
         */

        #break    #(SN)

	
		jmpi SW_CTX_SWITCH 
   a016c:	00a4ae01 	jmpi	a4ae0 <SW_CTX_SWITCH>

        /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
   a0170:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   a0174:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)
   a0178:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   a017c:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   a0180:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   a0184:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   a0188:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   a018c:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   a0190:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   a0194:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   a0198:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   a019c:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
   a01a0:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   a01a4:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   a01a8:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   a01ac:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   a01b0:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   a01b4:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   a01b8:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   a01bc:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
   a01c0:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   a01c4:	ef80083a 	eret

000a01c8 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   a01c8:	defff904 	addi	sp,sp,-28
   a01cc:	dfc00615 	stw	ra,24(sp)
   a01d0:	df000515 	stw	fp,20(sp)
   a01d4:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   a01d8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   a01dc:	0005313a 	rdctl	r2,ipending
   a01e0:	e0bffe15 	stw	r2,-8(fp)

  return active;
   a01e4:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   a01e8:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   a01ec:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   a01f0:	00800044 	movi	r2,1
   a01f4:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   a01f8:	e0fffb17 	ldw	r3,-20(fp)
   a01fc:	e0bffc17 	ldw	r2,-16(fp)
   a0200:	1884703a 	and	r2,r3,r2
   a0204:	10001426 	beq	r2,zero,a0258 <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   a0208:	008002b4 	movhi	r2,10
   a020c:	109c0704 	addi	r2,r2,28700
   a0210:	e0fffd17 	ldw	r3,-12(fp)
   a0214:	180690fa 	slli	r3,r3,3
   a0218:	10c5883a 	add	r2,r2,r3
   a021c:	10c00017 	ldw	r3,0(r2)
   a0220:	008002b4 	movhi	r2,10
   a0224:	109c0704 	addi	r2,r2,28700
   a0228:	e13ffd17 	ldw	r4,-12(fp)
   a022c:	200890fa 	slli	r4,r4,3
   a0230:	1105883a 	add	r2,r2,r4
   a0234:	10800104 	addi	r2,r2,4
   a0238:	10800017 	ldw	r2,0(r2)
   a023c:	1009883a 	mov	r4,r2
   a0240:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
   a0244:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   a0248:	0005313a 	rdctl	r2,ipending
   a024c:	e0bfff15 	stw	r2,-4(fp)

  return active;
   a0250:	e0bfff17 	ldw	r2,-4(fp)
   a0254:	00000706 	br	a0274 <alt_irq_handler+0xac>
      }
      mask <<= 1;
   a0258:	e0bffc17 	ldw	r2,-16(fp)
   a025c:	1085883a 	add	r2,r2,r2
   a0260:	e0bffc15 	stw	r2,-16(fp)
      i++;
   a0264:	e0bffd17 	ldw	r2,-12(fp)
   a0268:	10800044 	addi	r2,r2,1
   a026c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   a0270:	003fe106 	br	a01f8 <__alt_data_end+0xfffe01f8>

    active = alt_irq_pending ();
   a0274:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   a0278:	e0bffb17 	ldw	r2,-20(fp)
   a027c:	103fdb1e 	bne	r2,zero,a01ec <__alt_data_end+0xfffe01ec>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   a0280:	0001883a 	nop
}
   a0284:	0001883a 	nop
   a0288:	e037883a 	mov	sp,fp
   a028c:	dfc00117 	ldw	ra,4(sp)
   a0290:	df000017 	ldw	fp,0(sp)
   a0294:	dec00204 	addi	sp,sp,8
   a0298:	f800283a 	ret

Disassembly of section .text:

000a029c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   a029c:	06c00334 	movhi	sp,12
    ori sp, sp, %lo(__alt_stack_pointer)
   a02a0:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
   a02a4:	068002b4 	movhi	gp,10
    ori gp, gp, %lo(_gp)
   a02a8:	d6b61214 	ori	gp,gp,55368
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   a02ac:	008002b4 	movhi	r2,10
    ori r2, r2, %lo(__bss_start)
   a02b0:	1096f914 	ori	r2,r2,23524

    movhi r3, %hi(__bss_end)
   a02b4:	00c002b4 	movhi	r3,10
    ori r3, r3, %lo(__bss_end)
   a02b8:	18dc4714 	ori	r3,r3,28956

    beq r2, r3, 1f
   a02bc:	10c00326 	beq	r2,r3,a02cc <_start+0x30>

0:
    stw zero, (r2)
   a02c0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   a02c4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   a02c8:	10fffd36 	bltu	r2,r3,a02c0 <__alt_data_end+0xfffe02c0>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   a02cc:	00a1b5c0 	call	a1b5c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   a02d0:	00a1be00 	call	a1be0 <alt_main>

000a02d4 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   a02d4:	003fff06 	br	a02d4 <__alt_data_end+0xfffe02d4>

000a02d8 <main>:

/********************
 * MAIN             *
 ********************/
int main (void)
{
   a02d8:	defff904 	addi	sp,sp,-28
   a02dc:	dfc00615 	stw	ra,24(sp)
   a02e0:	df000515 	stw	fp,20(sp)
   a02e4:	df000504 	addi	fp,sp,20
    enum {start_screen_state,test_state, range_run_state}state ;
    //Sierra Help function
    Sierra_Initiation_HW_and_SW();
   a02e8:	00a2fdc0 	call	a2fdc <Sierra_Initiation_HW_and_SW>

    //Printa HW/SW Versioner
    printf(" Sierra HW version = %d\n", sierra_HW_version());
   a02ec:	00a2f400 	call	a2f40 <sierra_HW_version>
   a02f0:	100b883a 	mov	r5,r2
   a02f4:	010002b4 	movhi	r4,10
   a02f8:	2113d604 	addi	r4,r4,20312
   a02fc:	00a130c0 	call	a130c <printf>
    printf(" Sierra SW driver version = %d\n", sierra_SW_driver_version());
   a0300:	00a2f100 	call	a2f10 <sierra_SW_driver_version>
   a0304:	100b883a 	mov	r5,r2
   a0308:	010002b4 	movhi	r4,10
   a030c:	2113dd04 	addi	r4,r4,20340
   a0310:	00a130c0 	call	a130c <printf>
     * 20ms(50Hz) Tick periodtid               *
     * ----------------------------------------*
     * 20ms x 50Mhz / 1000 => 1000(dec)        *
     * Resultat: set_timebase(1000)            *
     *******************************************/
    set_timebase(1000);
   a0314:	0100fa04 	movi	r4,1000
   a0318:	00a2fa80 	call	a2fa8 <set_timebase>

    //TaskCreate
    task_create(IDLE, 0, READY_TASK_STATE,task_idle_code, idle_stack, STACK_SIZE);
   a031c:	0080c804 	movi	r2,800
   a0320:	d8800115 	stw	r2,4(sp)
   a0324:	008002b4 	movhi	r2,10
   a0328:	10989704 	addi	r2,r2,25180
   a032c:	d8800015 	stw	r2,0(sp)
   a0330:	01c002b4 	movhi	r7,10
   a0334:	39c16004 	addi	r7,r7,1408
   a0338:	01800044 	movi	r6,1
   a033c:	000b883a 	mov	r5,zero
   a0340:	0009883a 	mov	r4,zero
   a0344:	00a36d00 	call	a36d0 <task_create>
    task_create(Task_Avg_Range,1, READY_TASK_STATE,task_avg_range_code, task_avg_range_stack, STACK_SIZE);
   a0348:	0080c804 	movi	r2,800
   a034c:	d8800115 	stw	r2,4(sp)
   a0350:	008002b4 	movhi	r2,10
   a0354:	10970704 	addi	r2,r2,23580
   a0358:	d8800015 	stw	r2,0(sp)
   a035c:	01c002b4 	movhi	r7,10
   a0360:	39c13804 	addi	r7,r7,1248
   a0364:	01800044 	movi	r6,1
   a0368:	01400044 	movi	r5,1
   a036c:	01000044 	movi	r4,1
   a0370:	00a36d00 	call	a36d0 <task_create>
    task_create(Task_Range,2, READY_TASK_STATE, task_range_code, task_range_stack, STACK_SIZE);
   a0374:	0080c804 	movi	r2,800
   a0378:	d8800115 	stw	r2,4(sp)
   a037c:	008002b4 	movhi	r2,10
   a0380:	10995f04 	addi	r2,r2,25980
   a0384:	d8800015 	stw	r2,0(sp)
   a0388:	01c002b4 	movhi	r7,10
   a038c:	39c16404 	addi	r7,r7,1424
   a0390:	01800044 	movi	r6,1
   a0394:	01400084 	movi	r5,2
   a0398:	01000084 	movi	r4,2
   a039c:	00a36d00 	call	a36d0 <task_create>
    task_create(Task_Servo_Position,3, READY_TASK_STATE, task_servo_position_code, task_servo_position_stack,STACK_SIZE);
   a03a0:	0080c804 	movi	r2,800
   a03a4:	d8800115 	stw	r2,4(sp)
   a03a8:	008002b4 	movhi	r2,10
   a03ac:	1097cf04 	addi	r2,r2,24380
   a03b0:	d8800015 	stw	r2,0(sp)
   a03b4:	01c002b4 	movhi	r7,10
   a03b8:	39c3c804 	addi	r7,r7,3872
   a03bc:	01800044 	movi	r6,1
   a03c0:	014000c4 	movi	r5,3
   a03c4:	010000c4 	movi	r4,3
   a03c8:	00a36d00 	call	a36d0 <task_create>
    task_create(Task_Range_Print,4, READY_TASK_STATE, task_range_print_code, task_range_print_stack,STACK_SIZE);
   a03cc:	0080c804 	movi	r2,800
   a03d0:	d8800115 	stw	r2,4(sp)
   a03d4:	008002b4 	movhi	r2,10
   a03d8:	109a2704 	addi	r2,r2,26780
   a03dc:	d8800015 	stw	r2,0(sp)
   a03e0:	01c002b4 	movhi	r7,10
   a03e4:	39c1a104 	addi	r7,r7,1668
   a03e8:	01800044 	movi	r6,1
   a03ec:	01400104 	movi	r5,4
   a03f0:	01000104 	movi	r4,4
   a03f4:	00a36d00 	call	a36d0 <task_create>


    while(1)
    {
        switch(state)
   a03f8:	e0bffd17 	ldw	r2,-12(fp)
   a03fc:	10c00060 	cmpeqi	r3,r2,1
   a0400:	1800231e 	bne	r3,zero,a0490 <main+0x1b8>
   a0404:	0080032e 	bgeu	zero,r2,a0414 <main+0x13c>
   a0408:	108000a0 	cmpeqi	r2,r2,2
   a040c:	1000281e 	bne	r2,zero,a04b0 <main+0x1d8>
   a0410:	00003106 	br	a04d8 <main+0x200>
        {
                case start_screen_state:
                    printf("StarScreen\n");
   a0414:	010002b4 	movhi	r4,10
   a0418:	2113e504 	addi	r4,r4,20372
   a041c:	00a13d80 	call	a13d8 <puts>
                    init_screen();
   a0420:	00a3de40 	call	a3de4 <init_screen>
                    while(1)
                    {
                    	int key_in0 = KEY_0 ^ (KEY_0 & IORD_ALTERA_AVALON_PIO_DATA(BUTTON_PIO_BASE));
   a0424:	00800334 	movhi	r2,12
   a0428:	10850404 	addi	r2,r2,5136
   a042c:	10800037 	ldwio	r2,0(r2)
   a0430:	1080004c 	andi	r2,r2,1
   a0434:	1005003a 	cmpeq	r2,r2,zero
   a0438:	10803fcc 	andi	r2,r2,255
   a043c:	e0bffe15 	stw	r2,-8(fp)
                    	int key_in1 = KEY_1 ^ (KEY_1 & IORD_ALTERA_AVALON_PIO_DATA(BUTTON_PIO_BASE));
   a0440:	00800334 	movhi	r2,12
   a0444:	10850404 	addi	r2,r2,5136
   a0448:	10800037 	ldwio	r2,0(r2)
   a044c:	0084303a 	nor	r2,zero,r2
   a0450:	1080008c 	andi	r2,r2,2
   a0454:	e0bfff15 	stw	r2,-4(fp)

                        if(key_in0)
   a0458:	e0bffe17 	ldw	r2,-8(fp)
   a045c:	10000526 	beq	r2,zero,a0474 <main+0x19c>
                        {
                            DELAY(DELAY_1ms);
   a0460:	0130d414 	movui	r4,50000
   a0464:	00a41500 	call	a4150 <DELAY>
                            state=test_state;
   a0468:	00800044 	movi	r2,1
   a046c:	e0bffd15 	stw	r2,-12(fp)
                            break;
   a0470:	00000606 	br	a048c <main+0x1b4>
                        }

                        else if(key_in1)
   a0474:	e0bfff17 	ldw	r2,-4(fp)
   a0478:	103fea26 	beq	r2,zero,a0424 <__alt_data_end+0xfffe0424>
                        {
                        	DELAY(DELAY_1ms);
   a047c:	0130d414 	movui	r4,50000
   a0480:	00a41500 	call	a4150 <DELAY>
                            state=range_run_state;
   a0484:	00800084 	movi	r2,2
   a0488:	e0bffd15 	stw	r2,-12(fp)
                            break;
                        }
                    }
                break;
   a048c:	00001306 	br	a04dc <main+0x204>


                case test_state:
                    printf("Test");
   a0490:	010002b4 	movhi	r4,10
   a0494:	2113e804 	addi	r4,r4,20384
   a0498:	00a130c0 	call	a130c <printf>
                    clear_screen(COLOR_BLACK);
   a049c:	0009883a 	mov	r4,zero
   a04a0:	00a206c0 	call	a206c <clear_screen>
                    testFunction();
   a04a4:	00a3fc80 	call	a3fc8 <testFunction>
                    state=start_screen_state;
   a04a8:	e03ffd15 	stw	zero,-12(fp)

                break;
   a04ac:	00000b06 	br	a04dc <main+0x204>


                case range_run_state:
                    printf("range_run\n");
   a04b0:	010002b4 	movhi	r4,10
   a04b4:	2113ea04 	addi	r4,r4,20392
   a04b8:	00a13d80 	call	a13d8 <puts>
                    clear_screen(COLOR_BLACK);
   a04bc:	0009883a 	mov	r4,zero
   a04c0:	00a206c0 	call	a206c <clear_screen>
                    pattern();
   a04c4:	00a3ebc0 	call	a3ebc <pattern>
                    tsw_on();
   a04c8:	00a31480 	call	a3148 <tsw_on>
                    state = range_run_state;
   a04cc:	00800084 	movi	r2,2
   a04d0:	e0bffd15 	stw	r2,-12(fp)

                    break;
   a04d4:	00000106 	br	a04dc <main+0x204>

                default:
                    state = start_screen_state;
   a04d8:	e03ffd15 	stw	zero,-12(fp)

        }
    }
   a04dc:	003fc606 	br	a03f8 <__alt_data_end+0xfffe03f8>

000a04e0 <task_avg_range_code>:
#include <altera_avalon_sierra_ker.h>
#include "main_range_finder.h"
#include "def_var.h"

void task_avg_range_code(void)
{
   a04e0:	defffb04 	addi	sp,sp,-20
   a04e4:	dfc00415 	stw	ra,16(sp)
   a04e8:	df000315 	stw	fp,12(sp)
   a04ec:	df000304 	addi	fp,sp,12
    printf("Range Avg\n");
   a04f0:	010002b4 	movhi	r4,10
   a04f4:	2113ed04 	addi	r4,r4,20404
   a04f8:	00a13d80 	call	a13d8 <puts>
    task_periodic_start_union test;
    {
        init_period_time(500);
   a04fc:	01007d04 	movi	r4,500
   a0500:	00a3c1c0 	call	a3c1c <init_period_time>
        while(1)
        {

            test = wait_for_next_period();
   a0504:	00a3c8c0 	call	a3c8c <wait_for_next_period>
   a0508:	e0bfff15 	stw	r2,-4(fp)
            if(test.periodic_start_integer & 0x01)
   a050c:	e0bfff17 	ldw	r2,-4(fp)
   a0510:	1080004c 	andi	r2,r2,1
   a0514:	10000326 	beq	r2,zero,a0524 <task_avg_range_code+0x44>
            printf("Deadline miss, Task_avg_Range_Code");
   a0518:	010002b4 	movhi	r4,10
   a051c:	2113f004 	addi	r4,r4,20416
   a0520:	00a130c0 	call	a130c <printf>

            dist_avg=(dist_sum/20);
   a0524:	d0a0eb17 	ldw	r2,-31828(gp)
   a0528:	01400504 	movi	r5,20
   a052c:	1009883a 	mov	r4,r2
   a0530:	00a12140 	call	a1214 <__udivsi3>
   a0534:	d0a0e915 	stw	r2,-31836(gp)

            tty_print(160, 220, "Avg:", COLOR_GREEN,COLOR_BLACK);
   a0538:	d8000015 	stw	zero,0(sp)
   a053c:	01c00084 	movi	r7,2
   a0540:	018002b4 	movhi	r6,10
   a0544:	3193f904 	addi	r6,r6,20452
   a0548:	01403704 	movi	r5,220
   a054c:	01002804 	movi	r4,160
   a0550:	00a296c0 	call	a296c <tty_print>
            int_print(200, 220, dist_avg,3, COLOR_WHITE,COLOR_BLACK);
   a0554:	d0e0e917 	ldw	r3,-31836(gp)
   a0558:	d8000115 	stw	zero,4(sp)
   a055c:	008001c4 	movi	r2,7
   a0560:	d8800015 	stw	r2,0(sp)
   a0564:	01c000c4 	movi	r7,3
   a0568:	180d883a 	mov	r6,r3
   a056c:	01403704 	movi	r5,220
   a0570:	01003204 	movi	r4,200
   a0574:	00a2d8c0 	call	a2d8c <int_print>
            dist_sum=0;
   a0578:	d020eb15 	stw	zero,-31828(gp)
        }
   a057c:	003fe106 	br	a0504 <__alt_data_end+0xfffe0504>

000a0580 <task_idle_code>:

#include <stdio.h>
#include "main_range_finder.h"

void task_idle_code(void)
{
   a0580:	deffff04 	addi	sp,sp,-4
   a0584:	df000015 	stw	fp,0(sp)
   a0588:	d839883a 	mov	fp,sp
	while(1);
   a058c:	003fff06 	br	a058c <__alt_data_end+0xfffe058c>

000a0590 <task_range_code>:
#include <altera_avalon_sierra_ker.h>
#include "main_range_finder.h"
#include "def_var.h"

void task_range_code(void)
{
   a0590:	defffa04 	addi	sp,sp,-24
   a0594:	dfc00515 	stw	ra,20(sp)
   a0598:	df000415 	stw	fp,16(sp)
   a059c:	df000404 	addi	fp,sp,16
    printf("Range Init\n");
   a05a0:	010002b4 	movhi	r4,10
   a05a4:	2113fb04 	addi	r4,r4,20460
   a05a8:	00a13d80 	call	a13d8 <puts>
    task_periodic_start_union test;
    {
        init_period_time(25);
   a05ac:	01000644 	movi	r4,25
   a05b0:	00a3c1c0 	call	a3c1c <init_period_time>
        alt_u16 range;
        while(1)
        {
            test = wait_for_next_period();
   a05b4:	00a3c8c0 	call	a3c8c <wait_for_next_period>
   a05b8:	e0bfff15 	stw	r2,-4(fp)
            if(test.periodic_start_integer & 0x01)
   a05bc:	e0bfff17 	ldw	r2,-4(fp)
   a05c0:	1080004c 	andi	r2,r2,1
   a05c4:	10000326 	beq	r2,zero,a05d4 <task_range_code+0x44>
            printf("Deadline miss, Task_Range_Code");
   a05c8:	010002b4 	movhi	r4,10
   a05cc:	2113fe04 	addi	r4,r4,20472
   a05d0:	00a130c0 	call	a130c <printf>
            sem_take(SEM3);
   a05d4:	010000c4 	movi	r4,3
   a05d8:	00a33000 	call	a3300 <sem_take>
            distance = IORD_32DIRECT(DISTANCE_IN_BASE, 0);
   a05dc:	00800334 	movhi	r2,12
   a05e0:	10850c04 	addi	r2,r2,5168
   a05e4:	10800037 	ldwio	r2,0(r2)
   a05e8:	d0a0e815 	stw	r2,-31840(gp)
            range = distance;
   a05ec:	d0a0e817 	ldw	r2,-31840(gp)
   a05f0:	e0bffe0d 	sth	r2,-8(fp)
            dist_sum = dist_sum + range;
   a05f4:	e0fffe0b 	ldhu	r3,-8(fp)
   a05f8:	d0a0eb17 	ldw	r2,-31828(gp)
   a05fc:	1885883a 	add	r2,r3,r2
   a0600:	d0a0eb15 	stw	r2,-31828(gp)
            sem_release(SEM3);
   a0604:	010000c4 	movi	r4,3
   a0608:	00a33c40 	call	a33c4 <sem_release>
            printf("%ld cm\n",range);
   a060c:	e0bffe0b 	ldhu	r2,-8(fp)
   a0610:	100b883a 	mov	r5,r2
   a0614:	010002b4 	movhi	r4,10
   a0618:	21140604 	addi	r4,r4,20504
   a061c:	00a130c0 	call	a130c <printf>
            tty_print(5, 220, "Distance:", COLOR_GREEN,COLOR_BLACK);
   a0620:	d8000015 	stw	zero,0(sp)
   a0624:	01c00084 	movi	r7,2
   a0628:	018002b4 	movhi	r6,10
   a062c:	31940804 	addi	r6,r6,20512
   a0630:	01403704 	movi	r5,220
   a0634:	01000144 	movi	r4,5
   a0638:	00a296c0 	call	a296c <tty_print>
            int_print(75, 220, range,3, COLOR_WHITE,COLOR_BLACK);
   a063c:	e0fffe0b 	ldhu	r3,-8(fp)
   a0640:	d8000115 	stw	zero,4(sp)
   a0644:	008001c4 	movi	r2,7
   a0648:	d8800015 	stw	r2,0(sp)
   a064c:	01c000c4 	movi	r7,3
   a0650:	180d883a 	mov	r6,r3
   a0654:	01403704 	movi	r5,220
   a0658:	010012c4 	movi	r4,75
   a065c:	00a2d8c0 	call	a2d8c <int_print>

            //Watchdog Timer
            IOWR_8DIRECT(PIO_OUT_WD_BASE,0,1);      // restart(HW) std_logic = '1'. To reset Watchdog Hardware timer
   a0660:	00c00044 	movi	r3,1
   a0664:	00800334 	movhi	r2,12
   a0668:	10850804 	addi	r2,r2,5152
   a066c:	10c00025 	stbio	r3,0(r2)
            IOWR_8DIRECT(PIO_OUT_WD_BASE,0,0);      // restart(HW) std_logic = '0'. Watchdog Hardware timer counting
   a0670:	0007883a 	mov	r3,zero
   a0674:	00800334 	movhi	r2,12
   a0678:	10850804 	addi	r2,r2,5152
   a067c:	10c00025 	stbio	r3,0(r2)


        }
   a0680:	003fcc06 	br	a05b4 <__alt_data_end+0xfffe05b4>

000a0684 <task_range_print_code>:
#include <DE10_Lite_VGA_Driver.h>



void task_range_print_code(void)
{
   a0684:	defff304 	addi	sp,sp,-52
   a0688:	dfc00c15 	stw	ra,48(sp)
   a068c:	df000b15 	stw	fp,44(sp)
   a0690:	df000b04 	addi	fp,sp,44
    printf("Range Init\n");
   a0694:	010002b4 	movhi	r4,10
   a0698:	21140b04 	addi	r4,r4,20524
   a069c:	00a13d80 	call	a13d8 <puts>
    task_periodic_start_union test;
    {
        init_period_time(15);
   a06a0:	010003c4 	movi	r4,15
   a06a4:	00a3c1c0 	call	a3c1c <init_period_time>
        alt_u16 x_pos[]={0,25,50,75,90,115,140,165,180}; //Var for each angle(9 angles)
   a06a8:	e03ff70d 	sth	zero,-36(fp)
   a06ac:	00800644 	movi	r2,25
   a06b0:	e0bff78d 	sth	r2,-34(fp)
   a06b4:	00800c84 	movi	r2,50
   a06b8:	e0bff80d 	sth	r2,-32(fp)
   a06bc:	008012c4 	movi	r2,75
   a06c0:	e0bff88d 	sth	r2,-30(fp)
   a06c4:	00801684 	movi	r2,90
   a06c8:	e0bff90d 	sth	r2,-28(fp)
   a06cc:	00801cc4 	movi	r2,115
   a06d0:	e0bff98d 	sth	r2,-26(fp)
   a06d4:	00802304 	movi	r2,140
   a06d8:	e0bffa0d 	sth	r2,-24(fp)
   a06dc:	00802944 	movi	r2,165
   a06e0:	e0bffa8d 	sth	r2,-22(fp)
   a06e4:	00802d04 	movi	r2,180
   a06e8:	e0bffb0d 	sth	r2,-20(fp)
        alt_u16 y_pos[]={0,25,50,75,90,115,140,165,180};
   a06ec:	e03ffb8d 	sth	zero,-18(fp)
   a06f0:	00800644 	movi	r2,25
   a06f4:	e0bffc0d 	sth	r2,-16(fp)
   a06f8:	00800c84 	movi	r2,50
   a06fc:	e0bffc8d 	sth	r2,-14(fp)
   a0700:	008012c4 	movi	r2,75
   a0704:	e0bffd0d 	sth	r2,-12(fp)
   a0708:	00801684 	movi	r2,90
   a070c:	e0bffd8d 	sth	r2,-10(fp)
   a0710:	00801cc4 	movi	r2,115
   a0714:	e0bffe0d 	sth	r2,-8(fp)
   a0718:	00802304 	movi	r2,140
   a071c:	e0bffe8d 	sth	r2,-6(fp)
   a0720:	00802944 	movi	r2,165
   a0724:	e0bfff0d 	sth	r2,-4(fp)
   a0728:	00802d04 	movi	r2,180
   a072c:	e0bfff8d 	sth	r2,-2(fp)
        alt_u16 pos;
        alt_u16 range;
        while(1)
        {
            test = wait_for_next_period();
   a0730:	00a3c8c0 	call	a3c8c <wait_for_next_period>
   a0734:	e0bff615 	stw	r2,-40(fp)
            if(test.periodic_start_integer & 0x01)
   a0738:	e0bff617 	ldw	r2,-40(fp)
   a073c:	1080004c 	andi	r2,r2,1
   a0740:	10000326 	beq	r2,zero,a0750 <task_range_print_code+0xcc>
            printf("Deadline miss, Task_Range_print_Code");
   a0744:	010002b4 	movhi	r4,10
   a0748:	21140e04 	addi	r4,r4,20536
   a074c:	00a130c0 	call	a130c <printf>
            sem_take(SEM1);
   a0750:	01000044 	movi	r4,1
   a0754:	00a33000 	call	a3300 <sem_take>
             pos=m_pos;
   a0758:	d0a0ea0b 	ldhu	r2,-31832(gp)
   a075c:	e0bff50d 	sth	r2,-44(fp)
             range=distance;
   a0760:	d0a0e817 	ldw	r2,-31840(gp)
   a0764:	e0bff58d 	sth	r2,-42(fp)
             sem_release(SEM1);
   a0768:	01000044 	movi	r4,1
   a076c:	00a33c40 	call	a33c4 <sem_release>

            //Angle 90 Degrees
            if(pos<52&&pos>46){
   a0770:	e0bff50b 	ldhu	r2,-44(fp)
   a0774:	10800d28 	cmpgeui	r2,r2,52
   a0778:	1000301e 	bne	r2,zero,a083c <task_range_print_code+0x1b8>
   a077c:	e0bff50b 	ldhu	r2,-44(fp)
   a0780:	10800bf0 	cmpltui	r2,r2,47
   a0784:	10002d1e 	bne	r2,zero,a083c <task_range_print_code+0x1b8>
                draw_filled_circle(160,5,2,COLOR_CYAN);
   a0788:	01c00184 	movi	r7,6
   a078c:	01800084 	movi	r6,2
   a0790:	01400144 	movi	r5,5
   a0794:	01002804 	movi	r4,160
   a0798:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a079c:	e0bff58b 	ldhu	r2,-42(fp)
   a07a0:	10001c26 	beq	r2,zero,a0814 <task_range_print_code+0x190>
   a07a4:	e0bff58b 	ldhu	r2,-42(fp)
   a07a8:	108020a8 	cmpgeui	r2,r2,130
   a07ac:	1000191e 	bne	r2,zero,a0814 <task_range_print_code+0x190>
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_BLACK);
   a07b0:	e0bff90b 	ldhu	r2,-28(fp)
   a07b4:	10bfffcc 	andi	r2,r2,65535
   a07b8:	e0fffd8b 	ldhu	r3,-10(fp)
   a07bc:	18ffffcc 	andi	r3,r3,65535
   a07c0:	000f883a 	mov	r7,zero
   a07c4:	01800144 	movi	r6,5
   a07c8:	180b883a 	mov	r5,r3
   a07cc:	1009883a 	mov	r4,r2
   a07d0:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[4]=160;
   a07d4:	00802804 	movi	r2,160
   a07d8:	e0bff90d 	sth	r2,-28(fp)
                    y_pos[4]=150-range;
   a07dc:	e0bff58b 	ldhu	r2,-42(fp)
   a07e0:	00c02584 	movi	r3,150
   a07e4:	1885c83a 	sub	r2,r3,r2
   a07e8:	e0bffd8d 	sth	r2,-10(fp)
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_YELLOW);
   a07ec:	e0bff90b 	ldhu	r2,-28(fp)
   a07f0:	10bfffcc 	andi	r2,r2,65535
   a07f4:	e0fffd8b 	ldhu	r3,-10(fp)
   a07f8:	18ffffcc 	andi	r3,r3,65535
   a07fc:	01c000c4 	movi	r7,3
   a0800:	01800144 	movi	r6,5
   a0804:	180b883a 	mov	r5,r3
   a0808:	1009883a 	mov	r4,r2
   a080c:	00a25080 	call	a2508 <draw_filled_circle>
             pos=m_pos;
             range=distance;
             sem_release(SEM1);

            //Angle 90 Degrees
            if(pos<52&&pos>46){
   a0810:	0001c206 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[4]=160;
                    y_pos[4]=150-range;
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_BLACK);
   a0814:	e0bff90b 	ldhu	r2,-28(fp)
   a0818:	10bfffcc 	andi	r2,r2,65535
   a081c:	e0fffd8b 	ldhu	r3,-10(fp)
   a0820:	18ffffcc 	andi	r3,r3,65535
   a0824:	000f883a 	mov	r7,zero
   a0828:	01800144 	movi	r6,5
   a082c:	180b883a 	mov	r5,r3
   a0830:	1009883a 	mov	r4,r2
   a0834:	00a25080 	call	a2508 <draw_filled_circle>
             pos=m_pos;
             range=distance;
             sem_release(SEM1);

            //Angle 90 Degrees
            if(pos<52&&pos>46){
   a0838:	0001b806 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_BLACK);
                }
            }

            //Angle 0 Degrees
            else if(pos<16&&pos>13){
   a083c:	e0bff50b 	ldhu	r2,-44(fp)
   a0840:	10800428 	cmpgeui	r2,r2,16
   a0844:	10002f1e 	bne	r2,zero,a0904 <task_range_print_code+0x280>
   a0848:	e0bff50b 	ldhu	r2,-44(fp)
   a084c:	108003b0 	cmpltui	r2,r2,14
   a0850:	10002c1e 	bne	r2,zero,a0904 <task_range_print_code+0x280>
                draw_filled_circle(310,180,2,COLOR_CYAN);
   a0854:	01c00184 	movi	r7,6
   a0858:	01800084 	movi	r6,2
   a085c:	01402d04 	movi	r5,180
   a0860:	01004d84 	movi	r4,310
   a0864:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0868:	e0bff58b 	ldhu	r2,-42(fp)
   a086c:	10001b26 	beq	r2,zero,a08dc <task_range_print_code+0x258>
   a0870:	e0bff58b 	ldhu	r2,-42(fp)
   a0874:	108020a8 	cmpgeui	r2,r2,130
   a0878:	1000181e 	bne	r2,zero,a08dc <task_range_print_code+0x258>
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_BLACK);
   a087c:	e0bff70b 	ldhu	r2,-36(fp)
   a0880:	10bfffcc 	andi	r2,r2,65535
   a0884:	e0fffb8b 	ldhu	r3,-18(fp)
   a0888:	18ffffcc 	andi	r3,r3,65535
   a088c:	000f883a 	mov	r7,zero
   a0890:	01800144 	movi	r6,5
   a0894:	180b883a 	mov	r5,r3
   a0898:	1009883a 	mov	r4,r2
   a089c:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[0]=180+range;
   a08a0:	e0bff58b 	ldhu	r2,-42(fp)
   a08a4:	10802d04 	addi	r2,r2,180
   a08a8:	e0bff70d 	sth	r2,-36(fp)
                    y_pos[0]=180;
   a08ac:	00802d04 	movi	r2,180
   a08b0:	e0bffb8d 	sth	r2,-18(fp)
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_YELLOW);
   a08b4:	e0bff70b 	ldhu	r2,-36(fp)
   a08b8:	10bfffcc 	andi	r2,r2,65535
   a08bc:	e0fffb8b 	ldhu	r3,-18(fp)
   a08c0:	18ffffcc 	andi	r3,r3,65535
   a08c4:	01c000c4 	movi	r7,3
   a08c8:	01800144 	movi	r6,5
   a08cc:	180b883a 	mov	r5,r3
   a08d0:	1009883a 	mov	r4,r2
   a08d4:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_BLACK);
                }
            }

            //Angle 0 Degrees
            else if(pos<16&&pos>13){
   a08d8:	00019006 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[0]=180+range;
                    y_pos[0]=180;
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_BLACK);
   a08dc:	e0bff70b 	ldhu	r2,-36(fp)
   a08e0:	10bfffcc 	andi	r2,r2,65535
   a08e4:	e0fffb8b 	ldhu	r3,-18(fp)
   a08e8:	18ffffcc 	andi	r3,r3,65535
   a08ec:	000f883a 	mov	r7,zero
   a08f0:	01800144 	movi	r6,5
   a08f4:	180b883a 	mov	r5,r3
   a08f8:	1009883a 	mov	r4,r2
   a08fc:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[4],y_pos[4],5,COLOR_BLACK);
                }
            }

            //Angle 0 Degrees
            else if(pos<16&&pos>13){
   a0900:	00018606 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_BLACK);
                }
            }

            //Angle 180 Degrees
            else if(pos<84&&pos>79){
   a0904:	e0bff50b 	ldhu	r2,-44(fp)
   a0908:	10801528 	cmpgeui	r2,r2,84
   a090c:	1000301e 	bne	r2,zero,a09d0 <task_range_print_code+0x34c>
   a0910:	e0bff50b 	ldhu	r2,-44(fp)
   a0914:	10801430 	cmpltui	r2,r2,80
   a0918:	10002d1e 	bne	r2,zero,a09d0 <task_range_print_code+0x34c>
                draw_filled_circle(10,180,2,COLOR_CYAN);
   a091c:	01c00184 	movi	r7,6
   a0920:	01800084 	movi	r6,2
   a0924:	01402d04 	movi	r5,180
   a0928:	01000284 	movi	r4,10
   a092c:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0930:	e0bff58b 	ldhu	r2,-42(fp)
   a0934:	10001c26 	beq	r2,zero,a09a8 <task_range_print_code+0x324>
   a0938:	e0bff58b 	ldhu	r2,-42(fp)
   a093c:	108020a8 	cmpgeui	r2,r2,130
   a0940:	1000191e 	bne	r2,zero,a09a8 <task_range_print_code+0x324>
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_BLACK);
   a0944:	e0bffb0b 	ldhu	r2,-20(fp)
   a0948:	10bfffcc 	andi	r2,r2,65535
   a094c:	e0ffff8b 	ldhu	r3,-2(fp)
   a0950:	18ffffcc 	andi	r3,r3,65535
   a0954:	000f883a 	mov	r7,zero
   a0958:	01800144 	movi	r6,5
   a095c:	180b883a 	mov	r5,r3
   a0960:	1009883a 	mov	r4,r2
   a0964:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[8]=140-range;
   a0968:	e0bff58b 	ldhu	r2,-42(fp)
   a096c:	00c02304 	movi	r3,140
   a0970:	1885c83a 	sub	r2,r3,r2
   a0974:	e0bffb0d 	sth	r2,-20(fp)
                    y_pos[8]=180;
   a0978:	00802d04 	movi	r2,180
   a097c:	e0bfff8d 	sth	r2,-2(fp)
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_YELLOW);
   a0980:	e0bffb0b 	ldhu	r2,-20(fp)
   a0984:	10bfffcc 	andi	r2,r2,65535
   a0988:	e0ffff8b 	ldhu	r3,-2(fp)
   a098c:	18ffffcc 	andi	r3,r3,65535
   a0990:	01c000c4 	movi	r7,3
   a0994:	01800144 	movi	r6,5
   a0998:	180b883a 	mov	r5,r3
   a099c:	1009883a 	mov	r4,r2
   a09a0:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_BLACK);
                }
            }

            //Angle 180 Degrees
            else if(pos<84&&pos>79){
   a09a4:	00015d06 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[8]=140-range;
                    y_pos[8]=180;
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_BLACK);
   a09a8:	e0bffb0b 	ldhu	r2,-20(fp)
   a09ac:	10bfffcc 	andi	r2,r2,65535
   a09b0:	e0ffff8b 	ldhu	r3,-2(fp)
   a09b4:	18ffffcc 	andi	r3,r3,65535
   a09b8:	000f883a 	mov	r7,zero
   a09bc:	01800144 	movi	r6,5
   a09c0:	180b883a 	mov	r5,r3
   a09c4:	1009883a 	mov	r4,r2
   a09c8:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[0],y_pos[0],5,COLOR_BLACK);
                }
            }

            //Angle 180 Degrees
            else if(pos<84&&pos>79){
   a09cc:	00015306 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_BLACK);
                }
            }

            //Angle 25 Degrees
            else if(pos<25&&pos>16){
   a09d0:	e0bff50b 	ldhu	r2,-44(fp)
   a09d4:	10800668 	cmpgeui	r2,r2,25
   a09d8:	1000361e 	bne	r2,zero,a0ab4 <task_range_print_code+0x430>
   a09dc:	e0bff50b 	ldhu	r2,-44(fp)
   a09e0:	10800470 	cmpltui	r2,r2,17
   a09e4:	1000331e 	bne	r2,zero,a0ab4 <task_range_print_code+0x430>
                draw_filled_circle(300,75,2,COLOR_CYAN);
   a09e8:	01c00184 	movi	r7,6
   a09ec:	01800084 	movi	r6,2
   a09f0:	014012c4 	movi	r5,75
   a09f4:	01004b04 	movi	r4,300
   a09f8:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a09fc:	e0bff58b 	ldhu	r2,-42(fp)
   a0a00:	10002226 	beq	r2,zero,a0a8c <task_range_print_code+0x408>
   a0a04:	e0bff58b 	ldhu	r2,-42(fp)
   a0a08:	108020a8 	cmpgeui	r2,r2,130
   a0a0c:	10001f1e 	bne	r2,zero,a0a8c <task_range_print_code+0x408>
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_BLACK);
   a0a10:	e0bff78b 	ldhu	r2,-34(fp)
   a0a14:	10bfffcc 	andi	r2,r2,65535
   a0a18:	e0fffc0b 	ldhu	r3,-16(fp)
   a0a1c:	18ffffcc 	andi	r3,r3,65535
   a0a20:	000f883a 	mov	r7,zero
   a0a24:	01800144 	movi	r6,5
   a0a28:	180b883a 	mov	r5,r3
   a0a2c:	1009883a 	mov	r4,r2
   a0a30:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[1]=(255+range/3);
   a0a34:	e0bff58b 	ldhu	r2,-42(fp)
   a0a38:	014000c4 	movi	r5,3
   a0a3c:	1009883a 	mov	r4,r2
   a0a40:	00a12140 	call	a1214 <__udivsi3>
   a0a44:	10803fc4 	addi	r2,r2,255
   a0a48:	e0bff78d 	sth	r2,-34(fp)
                    y_pos[1]=(150-range/2);
   a0a4c:	e0bff58b 	ldhu	r2,-42(fp)
   a0a50:	1004d07a 	srli	r2,r2,1
   a0a54:	1007883a 	mov	r3,r2
   a0a58:	00802584 	movi	r2,150
   a0a5c:	10c5c83a 	sub	r2,r2,r3
   a0a60:	e0bffc0d 	sth	r2,-16(fp)
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_YELLOW);
   a0a64:	e0bff78b 	ldhu	r2,-34(fp)
   a0a68:	10bfffcc 	andi	r2,r2,65535
   a0a6c:	e0fffc0b 	ldhu	r3,-16(fp)
   a0a70:	18ffffcc 	andi	r3,r3,65535
   a0a74:	01c000c4 	movi	r7,3
   a0a78:	01800144 	movi	r6,5
   a0a7c:	180b883a 	mov	r5,r3
   a0a80:	1009883a 	mov	r4,r2
   a0a84:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_BLACK);
                }
            }

            //Angle 25 Degrees
            else if(pos<25&&pos>16){
   a0a88:	00012406 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[1]=(255+range/3);
                    y_pos[1]=(150-range/2);
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_BLACK);
   a0a8c:	e0bff78b 	ldhu	r2,-34(fp)
   a0a90:	10bfffcc 	andi	r2,r2,65535
   a0a94:	e0fffc0b 	ldhu	r3,-16(fp)
   a0a98:	18ffffcc 	andi	r3,r3,65535
   a0a9c:	000f883a 	mov	r7,zero
   a0aa0:	01800144 	movi	r6,5
   a0aa4:	180b883a 	mov	r5,r3
   a0aa8:	1009883a 	mov	r4,r2
   a0aac:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[8],y_pos[8],5,COLOR_BLACK);
                }
            }

            //Angle 25 Degrees
            else if(pos<25&&pos>16){
   a0ab0:	00011a06 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_BLACK);
                }
            }

            //Angle 50 Degrees
            else if(pos<34&&pos>25){
   a0ab4:	e0bff50b 	ldhu	r2,-44(fp)
   a0ab8:	108008a8 	cmpgeui	r2,r2,34
   a0abc:	1000341e 	bne	r2,zero,a0b90 <task_range_print_code+0x50c>
   a0ac0:	e0bff50b 	ldhu	r2,-44(fp)
   a0ac4:	108006b0 	cmpltui	r2,r2,26
   a0ac8:	1000311e 	bne	r2,zero,a0b90 <task_range_print_code+0x50c>
                draw_filled_circle(270,15,2,COLOR_CYAN);
   a0acc:	01c00184 	movi	r7,6
   a0ad0:	01800084 	movi	r6,2
   a0ad4:	014003c4 	movi	r5,15
   a0ad8:	01004384 	movi	r4,270
   a0adc:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0ae0:	e0bff58b 	ldhu	r2,-42(fp)
   a0ae4:	10002026 	beq	r2,zero,a0b68 <task_range_print_code+0x4e4>
   a0ae8:	e0bff58b 	ldhu	r2,-42(fp)
   a0aec:	108020a8 	cmpgeui	r2,r2,130
   a0af0:	10001d1e 	bne	r2,zero,a0b68 <task_range_print_code+0x4e4>
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_BLACK);
   a0af4:	e0bff80b 	ldhu	r2,-32(fp)
   a0af8:	10bfffcc 	andi	r2,r2,65535
   a0afc:	e0fffc8b 	ldhu	r3,-14(fp)
   a0b00:	18ffffcc 	andi	r3,r3,65535
   a0b04:	000f883a 	mov	r7,zero
   a0b08:	01800144 	movi	r6,5
   a0b0c:	180b883a 	mov	r5,r3
   a0b10:	1009883a 	mov	r4,r2
   a0b14:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[2]=(210+range/3);
   a0b18:	e0bff58b 	ldhu	r2,-42(fp)
   a0b1c:	014000c4 	movi	r5,3
   a0b20:	1009883a 	mov	r4,r2
   a0b24:	00a12140 	call	a1214 <__udivsi3>
   a0b28:	10803484 	addi	r2,r2,210
   a0b2c:	e0bff80d 	sth	r2,-32(fp)
                    y_pos[2]=(150-range);
   a0b30:	e0bff58b 	ldhu	r2,-42(fp)
   a0b34:	00c02584 	movi	r3,150
   a0b38:	1885c83a 	sub	r2,r3,r2
   a0b3c:	e0bffc8d 	sth	r2,-14(fp)
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_YELLOW);
   a0b40:	e0bff80b 	ldhu	r2,-32(fp)
   a0b44:	10bfffcc 	andi	r2,r2,65535
   a0b48:	e0fffc8b 	ldhu	r3,-14(fp)
   a0b4c:	18ffffcc 	andi	r3,r3,65535
   a0b50:	01c000c4 	movi	r7,3
   a0b54:	01800144 	movi	r6,5
   a0b58:	180b883a 	mov	r5,r3
   a0b5c:	1009883a 	mov	r4,r2
   a0b60:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_BLACK);
                }
            }

            //Angle 50 Degrees
            else if(pos<34&&pos>25){
   a0b64:	0000ed06 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[2]=(210+range/3);
                    y_pos[2]=(150-range);
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_BLACK);
   a0b68:	e0bff80b 	ldhu	r2,-32(fp)
   a0b6c:	10bfffcc 	andi	r2,r2,65535
   a0b70:	e0fffc8b 	ldhu	r3,-14(fp)
   a0b74:	18ffffcc 	andi	r3,r3,65535
   a0b78:	000f883a 	mov	r7,zero
   a0b7c:	01800144 	movi	r6,5
   a0b80:	180b883a 	mov	r5,r3
   a0b84:	1009883a 	mov	r4,r2
   a0b88:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[1],y_pos[1],5,COLOR_BLACK);
                }
            }

            //Angle 50 Degrees
            else if(pos<34&&pos>25){
   a0b8c:	0000e306 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_BLACK);
                }
            }

            //Angle 75 Degrees
            else if(pos<46&&pos>34){
   a0b90:	e0bff50b 	ldhu	r2,-44(fp)
   a0b94:	10800ba8 	cmpgeui	r2,r2,46
   a0b98:	1000341e 	bne	r2,zero,a0c6c <task_range_print_code+0x5e8>
   a0b9c:	e0bff50b 	ldhu	r2,-44(fp)
   a0ba0:	108008f0 	cmpltui	r2,r2,35
   a0ba4:	1000311e 	bne	r2,zero,a0c6c <task_range_print_code+0x5e8>
                draw_filled_circle(205,10,2,COLOR_CYAN);
   a0ba8:	01c00184 	movi	r7,6
   a0bac:	01800084 	movi	r6,2
   a0bb0:	01400284 	movi	r5,10
   a0bb4:	01003344 	movi	r4,205
   a0bb8:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0bbc:	e0bff58b 	ldhu	r2,-42(fp)
   a0bc0:	10002026 	beq	r2,zero,a0c44 <task_range_print_code+0x5c0>
   a0bc4:	e0bff58b 	ldhu	r2,-42(fp)
   a0bc8:	108020a8 	cmpgeui	r2,r2,130
   a0bcc:	10001d1e 	bne	r2,zero,a0c44 <task_range_print_code+0x5c0>
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_BLACK);
   a0bd0:	e0bff88b 	ldhu	r2,-30(fp)
   a0bd4:	10bfffcc 	andi	r2,r2,65535
   a0bd8:	e0fffd0b 	ldhu	r3,-12(fp)
   a0bdc:	18ffffcc 	andi	r3,r3,65535
   a0be0:	000f883a 	mov	r7,zero
   a0be4:	01800144 	movi	r6,5
   a0be8:	180b883a 	mov	r5,r3
   a0bec:	1009883a 	mov	r4,r2
   a0bf0:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[3]=(190+range/5);
   a0bf4:	e0bff58b 	ldhu	r2,-42(fp)
   a0bf8:	01400144 	movi	r5,5
   a0bfc:	1009883a 	mov	r4,r2
   a0c00:	00a12140 	call	a1214 <__udivsi3>
   a0c04:	10802f84 	addi	r2,r2,190
   a0c08:	e0bff88d 	sth	r2,-30(fp)
                    y_pos[3]=(150-range);
   a0c0c:	e0bff58b 	ldhu	r2,-42(fp)
   a0c10:	00c02584 	movi	r3,150
   a0c14:	1885c83a 	sub	r2,r3,r2
   a0c18:	e0bffd0d 	sth	r2,-12(fp)
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_YELLOW);
   a0c1c:	e0bff88b 	ldhu	r2,-30(fp)
   a0c20:	10bfffcc 	andi	r2,r2,65535
   a0c24:	e0fffd0b 	ldhu	r3,-12(fp)
   a0c28:	18ffffcc 	andi	r3,r3,65535
   a0c2c:	01c000c4 	movi	r7,3
   a0c30:	01800144 	movi	r6,5
   a0c34:	180b883a 	mov	r5,r3
   a0c38:	1009883a 	mov	r4,r2
   a0c3c:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_BLACK);
                }
            }

            //Angle 75 Degrees
            else if(pos<46&&pos>34){
   a0c40:	0000b606 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[3]=(190+range/5);
                    y_pos[3]=(150-range);
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_BLACK);
   a0c44:	e0bff88b 	ldhu	r2,-30(fp)
   a0c48:	10bfffcc 	andi	r2,r2,65535
   a0c4c:	e0fffd0b 	ldhu	r3,-12(fp)
   a0c50:	18ffffcc 	andi	r3,r3,65535
   a0c54:	000f883a 	mov	r7,zero
   a0c58:	01800144 	movi	r6,5
   a0c5c:	180b883a 	mov	r5,r3
   a0c60:	1009883a 	mov	r4,r2
   a0c64:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[2],y_pos[2],5,COLOR_BLACK);
                }
            }

            //Angle 75 Degrees
            else if(pos<46&&pos>34){
   a0c68:	0000ac06 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_BLACK);
                }
            }

            //Angle 115 Degrees
            else if(pos<61&&pos>52){
   a0c6c:	e0bff50b 	ldhu	r2,-44(fp)
   a0c70:	10800f68 	cmpgeui	r2,r2,61
   a0c74:	1000361e 	bne	r2,zero,a0d50 <task_range_print_code+0x6cc>
   a0c78:	e0bff50b 	ldhu	r2,-44(fp)
   a0c7c:	10800d70 	cmpltui	r2,r2,53
   a0c80:	1000331e 	bne	r2,zero,a0d50 <task_range_print_code+0x6cc>
                draw_filled_circle(115,10,2,COLOR_CYAN);
   a0c84:	01c00184 	movi	r7,6
   a0c88:	01800084 	movi	r6,2
   a0c8c:	01400284 	movi	r5,10
   a0c90:	01001cc4 	movi	r4,115
   a0c94:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0c98:	e0bff58b 	ldhu	r2,-42(fp)
   a0c9c:	10002226 	beq	r2,zero,a0d28 <task_range_print_code+0x6a4>
   a0ca0:	e0bff58b 	ldhu	r2,-42(fp)
   a0ca4:	108020a8 	cmpgeui	r2,r2,130
   a0ca8:	10001f1e 	bne	r2,zero,a0d28 <task_range_print_code+0x6a4>
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_BLACK);
   a0cac:	e0bff98b 	ldhu	r2,-26(fp)
   a0cb0:	10bfffcc 	andi	r2,r2,65535
   a0cb4:	e0fffe0b 	ldhu	r3,-8(fp)
   a0cb8:	18ffffcc 	andi	r3,r3,65535
   a0cbc:	000f883a 	mov	r7,zero
   a0cc0:	01800144 	movi	r6,5
   a0cc4:	180b883a 	mov	r5,r3
   a0cc8:	1009883a 	mov	r4,r2
   a0ccc:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[5]=(130-range/5);
   a0cd0:	e0bff58b 	ldhu	r2,-42(fp)
   a0cd4:	01400144 	movi	r5,5
   a0cd8:	1009883a 	mov	r4,r2
   a0cdc:	00a12140 	call	a1214 <__udivsi3>
   a0ce0:	1007883a 	mov	r3,r2
   a0ce4:	00802084 	movi	r2,130
   a0ce8:	10c5c83a 	sub	r2,r2,r3
   a0cec:	e0bff98d 	sth	r2,-26(fp)
                    y_pos[5]=(150-range);
   a0cf0:	e0bff58b 	ldhu	r2,-42(fp)
   a0cf4:	00c02584 	movi	r3,150
   a0cf8:	1885c83a 	sub	r2,r3,r2
   a0cfc:	e0bffe0d 	sth	r2,-8(fp)
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_YELLOW);
   a0d00:	e0bff98b 	ldhu	r2,-26(fp)
   a0d04:	10bfffcc 	andi	r2,r2,65535
   a0d08:	e0fffe0b 	ldhu	r3,-8(fp)
   a0d0c:	18ffffcc 	andi	r3,r3,65535
   a0d10:	01c000c4 	movi	r7,3
   a0d14:	01800144 	movi	r6,5
   a0d18:	180b883a 	mov	r5,r3
   a0d1c:	1009883a 	mov	r4,r2
   a0d20:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_BLACK);
                }
            }

            //Angle 115 Degrees
            else if(pos<61&&pos>52){
   a0d24:	00007d06 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[5]=(130-range/5);
                    y_pos[5]=(150-range);
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_BLACK);
   a0d28:	e0bff98b 	ldhu	r2,-26(fp)
   a0d2c:	10bfffcc 	andi	r2,r2,65535
   a0d30:	e0fffe0b 	ldhu	r3,-8(fp)
   a0d34:	18ffffcc 	andi	r3,r3,65535
   a0d38:	000f883a 	mov	r7,zero
   a0d3c:	01800144 	movi	r6,5
   a0d40:	180b883a 	mov	r5,r3
   a0d44:	1009883a 	mov	r4,r2
   a0d48:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[3],y_pos[3],5,COLOR_BLACK);
                }
            }

            //Angle 115 Degrees
            else if(pos<61&&pos>52){
   a0d4c:	00007306 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_BLACK);
                }
            }

            //Angle 140 Degrees
            else if(pos<70&&pos>61){
   a0d50:	e0bff50b 	ldhu	r2,-44(fp)
   a0d54:	108011a8 	cmpgeui	r2,r2,70
   a0d58:	1000361e 	bne	r2,zero,a0e34 <task_range_print_code+0x7b0>
   a0d5c:	e0bff50b 	ldhu	r2,-44(fp)
   a0d60:	10800fb0 	cmpltui	r2,r2,62
   a0d64:	1000331e 	bne	r2,zero,a0e34 <task_range_print_code+0x7b0>
                draw_filled_circle(40,15,2,COLOR_CYAN);
   a0d68:	01c00184 	movi	r7,6
   a0d6c:	01800084 	movi	r6,2
   a0d70:	014003c4 	movi	r5,15
   a0d74:	01000a04 	movi	r4,40
   a0d78:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0d7c:	e0bff58b 	ldhu	r2,-42(fp)
   a0d80:	10002226 	beq	r2,zero,a0e0c <task_range_print_code+0x788>
   a0d84:	e0bff58b 	ldhu	r2,-42(fp)
   a0d88:	108020a8 	cmpgeui	r2,r2,130
   a0d8c:	10001f1e 	bne	r2,zero,a0e0c <task_range_print_code+0x788>
                    draw_filled_circle(x_pos[6],y_pos[6],5,COLOR_BLACK);
   a0d90:	e0bffa0b 	ldhu	r2,-24(fp)
   a0d94:	10bfffcc 	andi	r2,r2,65535
   a0d98:	e0fffe8b 	ldhu	r3,-6(fp)
   a0d9c:	18ffffcc 	andi	r3,r3,65535
   a0da0:	000f883a 	mov	r7,zero
   a0da4:	01800144 	movi	r6,5
   a0da8:	180b883a 	mov	r5,r3
   a0dac:	1009883a 	mov	r4,r2
   a0db0:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[6]=(110-range/3);
   a0db4:	e0bff58b 	ldhu	r2,-42(fp)
   a0db8:	014000c4 	movi	r5,3
   a0dbc:	1009883a 	mov	r4,r2
   a0dc0:	00a12140 	call	a1214 <__udivsi3>
   a0dc4:	1007883a 	mov	r3,r2
   a0dc8:	00801b84 	movi	r2,110
   a0dcc:	10c5c83a 	sub	r2,r2,r3
   a0dd0:	e0bffa0d 	sth	r2,-24(fp)
                    y_pos[6]=(150-range);
   a0dd4:	e0bff58b 	ldhu	r2,-42(fp)
   a0dd8:	00c02584 	movi	r3,150
   a0ddc:	1885c83a 	sub	r2,r3,r2
   a0de0:	e0bffe8d 	sth	r2,-6(fp)
                    draw_filled_circle(x_pos[6],y_pos[6],5,COLOR_YELLOW);
   a0de4:	e0bffa0b 	ldhu	r2,-24(fp)
   a0de8:	10bfffcc 	andi	r2,r2,65535
   a0dec:	e0fffe8b 	ldhu	r3,-6(fp)
   a0df0:	18ffffcc 	andi	r3,r3,65535
   a0df4:	01c000c4 	movi	r7,3
   a0df8:	01800144 	movi	r6,5
   a0dfc:	180b883a 	mov	r5,r3
   a0e00:	1009883a 	mov	r4,r2
   a0e04:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_BLACK);
                }
            }

            //Angle 140 Degrees
            else if(pos<70&&pos>61){
   a0e08:	00004406 	br	a0f1c <task_range_print_code+0x898>
                    x_pos[6]=(110-range/3);
                    y_pos[6]=(150-range);
                    draw_filled_circle(x_pos[6],y_pos[6],5,COLOR_YELLOW);
                }
                else{
                    draw_filled_circle(x_pos[6],y_pos[6],5,COLOR_BLACK);
   a0e0c:	e0bffa0b 	ldhu	r2,-24(fp)
   a0e10:	10bfffcc 	andi	r2,r2,65535
   a0e14:	e0fffe8b 	ldhu	r3,-6(fp)
   a0e18:	18ffffcc 	andi	r3,r3,65535
   a0e1c:	000f883a 	mov	r7,zero
   a0e20:	01800144 	movi	r6,5
   a0e24:	180b883a 	mov	r5,r3
   a0e28:	1009883a 	mov	r4,r2
   a0e2c:	00a25080 	call	a2508 <draw_filled_circle>
                    draw_filled_circle(x_pos[5],y_pos[5],5,COLOR_BLACK);
                }
            }

            //Angle 140 Degrees
            else if(pos<70&&pos>61){
   a0e30:	00003a06 	br	a0f1c <task_range_print_code+0x898>
                    draw_filled_circle(x_pos[6],y_pos[6],5,COLOR_BLACK);
                }
            }

            //Angle 165 Degrees
            else if(pos<79&&pos>70){
   a0e34:	e0bff50b 	ldhu	r2,-44(fp)
   a0e38:	108013e8 	cmpgeui	r2,r2,79
   a0e3c:	103e3c1e 	bne	r2,zero,a0730 <__alt_data_end+0xfffe0730>
   a0e40:	e0bff50b 	ldhu	r2,-44(fp)
   a0e44:	108011f0 	cmpltui	r2,r2,71
   a0e48:	103e391e 	bne	r2,zero,a0730 <__alt_data_end+0xfffe0730>
                draw_filled_circle(10,75,2,COLOR_CYAN);
   a0e4c:	01c00184 	movi	r7,6
   a0e50:	01800084 	movi	r6,2
   a0e54:	014012c4 	movi	r5,75
   a0e58:	01000284 	movi	r4,10
   a0e5c:	00a25080 	call	a2508 <draw_filled_circle>
                if(range>0 && range<130){
   a0e60:	e0bff58b 	ldhu	r2,-42(fp)
   a0e64:	10002426 	beq	r2,zero,a0ef8 <task_range_print_code+0x874>
   a0e68:	e0bff58b 	ldhu	r2,-42(fp)
   a0e6c:	108020a8 	cmpgeui	r2,r2,130
   a0e70:	1000211e 	bne	r2,zero,a0ef8 <task_range_print_code+0x874>
                    draw_filled_circle(x_pos[7],y_pos[7],5,COLOR_BLACK);
   a0e74:	e0bffa8b 	ldhu	r2,-22(fp)
   a0e78:	10bfffcc 	andi	r2,r2,65535
   a0e7c:	e0ffff0b 	ldhu	r3,-4(fp)
   a0e80:	18ffffcc 	andi	r3,r3,65535
   a0e84:	000f883a 	mov	r7,zero
   a0e88:	01800144 	movi	r6,5
   a0e8c:	180b883a 	mov	r5,r3
   a0e90:	1009883a 	mov	r4,r2
   a0e94:	00a25080 	call	a2508 <draw_filled_circle>
                    x_pos[7]=(65-range/3);
   a0e98:	e0bff58b 	ldhu	r2,-42(fp)
   a0e9c:	014000c4 	movi	r5,3
   a0ea0:	1009883a 	mov	r4,r2
   a0ea4:	00a12140 	call	a1214 <__udivsi3>
   a0ea8:	1007883a 	mov	r3,r2
   a0eac:	00801044 	movi	r2,65
   a0eb0:	10c5c83a 	sub	r2,r2,r3
   a0eb4:	e0bffa8d 	sth	r2,-22(fp)
                    y_pos[7]=(150-range/2);
   a0eb8:	e0bff58b 	ldhu	r2,-42(fp)
   a0ebc:	1004d07a 	srli	r2,r2,1
   a0ec0:	1007883a 	mov	r3,r2
   a0ec4:	00802584 	movi	r2,150
   a0ec8:	10c5c83a 	sub	r2,r2,r3
   a0ecc:	e0bfff0d 	sth	r2,-4(fp)
                    draw_filled_circle(x_pos[7],y_pos[7],5,COLOR_YELLOW);
   a0ed0:	e0bffa8b 	ldhu	r2,-22(fp)
   a0ed4:	10bfffcc 	andi	r2,r2,65535
   a0ed8:	e0ffff0b 	ldhu	r3,-4(fp)
   a0edc:	18ffffcc 	andi	r3,r3,65535
   a0ee0:	01c000c4 	movi	r7,3
   a0ee4:	01800144 	movi	r6,5
   a0ee8:	180b883a 	mov	r5,r3
   a0eec:	1009883a 	mov	r4,r2
   a0ef0:	00a25080 	call	a2508 <draw_filled_circle>
   a0ef4:	00000906 	br	a0f1c <task_range_print_code+0x898>
                }
                else{
                    draw_filled_circle(x_pos[7],y_pos[7],5,COLOR_BLACK);
   a0ef8:	e0bffa8b 	ldhu	r2,-22(fp)
   a0efc:	10bfffcc 	andi	r2,r2,65535
   a0f00:	e0ffff0b 	ldhu	r3,-4(fp)
   a0f04:	18ffffcc 	andi	r3,r3,65535
   a0f08:	000f883a 	mov	r7,zero
   a0f0c:	01800144 	movi	r6,5
   a0f10:	180b883a 	mov	r5,r3
   a0f14:	1009883a 	mov	r4,r2
   a0f18:	00a25080 	call	a2508 <draw_filled_circle>
                }
            }

        }
   a0f1c:	003e0406 	br	a0730 <__alt_data_end+0xfffe0730>

000a0f20 <task_servo_position_code>:
                              {300,75,2,COLOR_BLACK},{270,15,2,COLOR_BLACK}, {205,10,2,COLOR_BLACK},
							  {115,10,2,COLOR_BLACK}, {20,15,2,COLOR_BLACK}, {10,180,2,COLOR_BLACK},
                              {40,15,2,COLOR_BLACK}};

void task_servo_position_code(void)
{
   a0f20:	defff904 	addi	sp,sp,-28
   a0f24:	dfc00615 	stw	ra,24(sp)
   a0f28:	df000515 	stw	fp,20(sp)
   a0f2c:	df000504 	addi	fp,sp,20
    printf("Range Init\n");
   a0f30:	010002b4 	movhi	r4,10
   a0f34:	21141804 	addi	r4,r4,20576
   a0f38:	00a13d80 	call	a13d8 <puts>
    task_periodic_start_union test;
    {
        enum {increase_state,decrease_state}state;
        alt_u16 pos;
        init_period_time(10);
   a0f3c:	01000284 	movi	r4,10
   a0f40:	00a3c1c0 	call	a3c1c <init_period_time>
        while(1)
        {
            test = wait_for_next_period();
   a0f44:	00a3c8c0 	call	a3c8c <wait_for_next_period>
   a0f48:	e0bfff15 	stw	r2,-4(fp)
            if(test.periodic_start_integer & 0x01)
   a0f4c:	e0bfff17 	ldw	r2,-4(fp)
   a0f50:	1080004c 	andi	r2,r2,1
   a0f54:	10000326 	beq	r2,zero,a0f64 <task_servo_position_code+0x44>
            printf("Deadline miss, Task_Servo_position_Code");
   a0f58:	010002b4 	movhi	r4,10
   a0f5c:	21141b04 	addi	r4,r4,20588
   a0f60:	00a130c0 	call	a130c <printf>

            switch(state){
   a0f64:	e0bffb17 	ldw	r2,-20(fp)
   a0f68:	10000326 	beq	r2,zero,a0f78 <task_servo_position_code+0x58>
   a0f6c:	10800060 	cmpeqi	r2,r2,1
   a0f70:	1000331e 	bne	r2,zero,a1040 <task_servo_position_code+0x120>
   a0f74:	00006806 	br	a1118 <task_servo_position_code+0x1f8>
            case increase_state:
                sem_take(SEM1);
   a0f78:	01000044 	movi	r4,1
   a0f7c:	00a33000 	call	a3300 <sem_take>
                m_pos=m_pos+1;
   a0f80:	d0a0ea0b 	ldhu	r2,-31832(gp)
   a0f84:	10800044 	addi	r2,r2,1
   a0f88:	d0a0ea0d 	sth	r2,-31832(gp)
                pos=m_pos;
   a0f8c:	d0a0ea0b 	ldhu	r2,-31832(gp)
   a0f90:	e0bffe0d 	sth	r2,-8(fp)
                sem_release(SEM1);
   a0f94:	01000044 	movi	r4,1
   a0f98:	00a33c40 	call	a33c4 <sem_release>
                servo_position(pos);
   a0f9c:	e0fffe0b 	ldhu	r3,-8(fp)
   a0fa0:	00800334 	movhi	r2,12
   a0fa4:	10851c04 	addi	r2,r2,5232
   a0fa8:	10c00035 	stwio	r3,0(r2)
                if(pos>=84)
   a0fac:	e0bffe0b 	ldhu	r2,-8(fp)
   a0fb0:	10801530 	cmpltui	r2,r2,84
   a0fb4:	1000551e 	bne	r2,zero,a110c <task_servo_position_code+0x1ec>
                {
                	for(size_t i = 0; i < 10; ++i) {
   a0fb8:	e03ffc15 	stw	zero,-16(fp)
   a0fbc:	00001a06 	br	a1028 <task_servo_position_code+0x108>
                		draw_filled_circle(circleData[i].x0,circleData[i].y0,circleData[i].radius,COLOR_BLACK);
   a0fc0:	008002b4 	movhi	r2,10
   a0fc4:	10953d04 	addi	r2,r2,21748
   a0fc8:	e0fffc17 	ldw	r3,-16(fp)
   a0fcc:	1806913a 	slli	r3,r3,4
   a0fd0:	10c5883a 	add	r2,r2,r3
   a0fd4:	11000017 	ldw	r4,0(r2)
   a0fd8:	008002b4 	movhi	r2,10
   a0fdc:	10953d04 	addi	r2,r2,21748
   a0fe0:	e0fffc17 	ldw	r3,-16(fp)
   a0fe4:	1806913a 	slli	r3,r3,4
   a0fe8:	10c5883a 	add	r2,r2,r3
   a0fec:	10800104 	addi	r2,r2,4
   a0ff0:	11400017 	ldw	r5,0(r2)
   a0ff4:	008002b4 	movhi	r2,10
   a0ff8:	10953d04 	addi	r2,r2,21748
   a0ffc:	e0fffc17 	ldw	r3,-16(fp)
   a1000:	1806913a 	slli	r3,r3,4
   a1004:	10c5883a 	add	r2,r2,r3
   a1008:	10800204 	addi	r2,r2,8
   a100c:	10800017 	ldw	r2,0(r2)
   a1010:	000f883a 	mov	r7,zero
   a1014:	100d883a 	mov	r6,r2
   a1018:	00a25080 	call	a2508 <draw_filled_circle>
                pos=m_pos;
                sem_release(SEM1);
                servo_position(pos);
                if(pos>=84)
                {
                	for(size_t i = 0; i < 10; ++i) {
   a101c:	e0bffc17 	ldw	r2,-16(fp)
   a1020:	10800044 	addi	r2,r2,1
   a1024:	e0bffc15 	stw	r2,-16(fp)
   a1028:	e0bffc17 	ldw	r2,-16(fp)
   a102c:	108002b0 	cmpltui	r2,r2,10
   a1030:	103fe31e 	bne	r2,zero,a0fc0 <__alt_data_end+0xfffe0fc0>
                		draw_filled_circle(circleData[i].x0,circleData[i].y0,circleData[i].radius,COLOR_BLACK);
                	}
                    state=decrease_state;
   a1034:	00800044 	movi	r2,1
   a1038:	e0bffb15 	stw	r2,-20(fp)
                }
                break;
   a103c:	00003306 	br	a110c <task_servo_position_code+0x1ec>
                
            case decrease_state:
                sem_take(SEM1);
   a1040:	01000044 	movi	r4,1
   a1044:	00a33000 	call	a3300 <sem_take>
                m_pos=m_pos-1;
   a1048:	d0a0ea0b 	ldhu	r2,-31832(gp)
   a104c:	10bfffc4 	addi	r2,r2,-1
   a1050:	d0a0ea0d 	sth	r2,-31832(gp)
                pos=m_pos;
   a1054:	d0a0ea0b 	ldhu	r2,-31832(gp)
   a1058:	e0bffe0d 	sth	r2,-8(fp)
                sem_release(SEM1);
   a105c:	01000044 	movi	r4,1
   a1060:	00a33c40 	call	a33c4 <sem_release>
                servo_position(pos);
   a1064:	e0fffe0b 	ldhu	r3,-8(fp)
   a1068:	00800334 	movhi	r2,12
   a106c:	10851c04 	addi	r2,r2,5232
   a1070:	10c00035 	stwio	r3,0(r2)
                sem_release(SEM1);
   a1074:	01000044 	movi	r4,1
   a1078:	00a33c40 	call	a33c4 <sem_release>
                if(pos<=14)
   a107c:	e0bffe0b 	ldhu	r2,-8(fp)
   a1080:	108003e8 	cmpgeui	r2,r2,15
   a1084:	1000231e 	bne	r2,zero,a1114 <task_servo_position_code+0x1f4>
                {
                	for(size_t i = 0; i < 10; ++i) {
   a1088:	e03ffd15 	stw	zero,-12(fp)
   a108c:	00001a06 	br	a10f8 <task_servo_position_code+0x1d8>
                		draw_filled_circle(circleData[i].x0,circleData[i].y0,circleData[i].radius,COLOR_BLACK);
   a1090:	008002b4 	movhi	r2,10
   a1094:	10953d04 	addi	r2,r2,21748
   a1098:	e0fffd17 	ldw	r3,-12(fp)
   a109c:	1806913a 	slli	r3,r3,4
   a10a0:	10c5883a 	add	r2,r2,r3
   a10a4:	11000017 	ldw	r4,0(r2)
   a10a8:	008002b4 	movhi	r2,10
   a10ac:	10953d04 	addi	r2,r2,21748
   a10b0:	e0fffd17 	ldw	r3,-12(fp)
   a10b4:	1806913a 	slli	r3,r3,4
   a10b8:	10c5883a 	add	r2,r2,r3
   a10bc:	10800104 	addi	r2,r2,4
   a10c0:	11400017 	ldw	r5,0(r2)
   a10c4:	008002b4 	movhi	r2,10
   a10c8:	10953d04 	addi	r2,r2,21748
   a10cc:	e0fffd17 	ldw	r3,-12(fp)
   a10d0:	1806913a 	slli	r3,r3,4
   a10d4:	10c5883a 	add	r2,r2,r3
   a10d8:	10800204 	addi	r2,r2,8
   a10dc:	10800017 	ldw	r2,0(r2)
   a10e0:	000f883a 	mov	r7,zero
   a10e4:	100d883a 	mov	r6,r2
   a10e8:	00a25080 	call	a2508 <draw_filled_circle>
                sem_release(SEM1);
                servo_position(pos);
                sem_release(SEM1);
                if(pos<=14)
                {
                	for(size_t i = 0; i < 10; ++i) {
   a10ec:	e0bffd17 	ldw	r2,-12(fp)
   a10f0:	10800044 	addi	r2,r2,1
   a10f4:	e0bffd15 	stw	r2,-12(fp)
   a10f8:	e0bffd17 	ldw	r2,-12(fp)
   a10fc:	108002b0 	cmpltui	r2,r2,10
   a1100:	103fe31e 	bne	r2,zero,a1090 <__alt_data_end+0xfffe1090>
                		draw_filled_circle(circleData[i].x0,circleData[i].y0,circleData[i].radius,COLOR_BLACK);
                	}
                    state=increase_state;
   a1104:	e03ffb15 	stw	zero,-20(fp)
                }
                break;
   a1108:	00000206 	br	a1114 <task_servo_position_code+0x1f4>
                	for(size_t i = 0; i < 10; ++i) {
                		draw_filled_circle(circleData[i].x0,circleData[i].y0,circleData[i].radius,COLOR_BLACK);
                	}
                    state=decrease_state;
                }
                break;
   a110c:	0001883a 	nop
   a1110:	003f8c06 	br	a0f44 <__alt_data_end+0xfffe0f44>
                	for(size_t i = 0; i < 10; ++i) {
                		draw_filled_circle(circleData[i].x0,circleData[i].y0,circleData[i].radius,COLOR_BLACK);
                	}
                    state=increase_state;
                }
                break;
   a1114:	0001883a 	nop

            }

        }
   a1118:	003f8a06 	br	a0f44 <__alt_data_end+0xfffe0f44>

000a111c <__divsi3>:
   a111c:	20001b16 	blt	r4,zero,a118c <__divsi3+0x70>
   a1120:	000f883a 	mov	r7,zero
   a1124:	28001616 	blt	r5,zero,a1180 <__divsi3+0x64>
   a1128:	200d883a 	mov	r6,r4
   a112c:	29001a2e 	bgeu	r5,r4,a1198 <__divsi3+0x7c>
   a1130:	00800804 	movi	r2,32
   a1134:	00c00044 	movi	r3,1
   a1138:	00000106 	br	a1140 <__divsi3+0x24>
   a113c:	10000d26 	beq	r2,zero,a1174 <__divsi3+0x58>
   a1140:	294b883a 	add	r5,r5,r5
   a1144:	10bfffc4 	addi	r2,r2,-1
   a1148:	18c7883a 	add	r3,r3,r3
   a114c:	293ffb36 	bltu	r5,r4,a113c <__alt_data_end+0xfffe113c>
   a1150:	0005883a 	mov	r2,zero
   a1154:	18000726 	beq	r3,zero,a1174 <__divsi3+0x58>
   a1158:	0005883a 	mov	r2,zero
   a115c:	31400236 	bltu	r6,r5,a1168 <__divsi3+0x4c>
   a1160:	314dc83a 	sub	r6,r6,r5
   a1164:	10c4b03a 	or	r2,r2,r3
   a1168:	1806d07a 	srli	r3,r3,1
   a116c:	280ad07a 	srli	r5,r5,1
   a1170:	183ffa1e 	bne	r3,zero,a115c <__alt_data_end+0xfffe115c>
   a1174:	38000126 	beq	r7,zero,a117c <__divsi3+0x60>
   a1178:	0085c83a 	sub	r2,zero,r2
   a117c:	f800283a 	ret
   a1180:	014bc83a 	sub	r5,zero,r5
   a1184:	39c0005c 	xori	r7,r7,1
   a1188:	003fe706 	br	a1128 <__alt_data_end+0xfffe1128>
   a118c:	0109c83a 	sub	r4,zero,r4
   a1190:	01c00044 	movi	r7,1
   a1194:	003fe306 	br	a1124 <__alt_data_end+0xfffe1124>
   a1198:	00c00044 	movi	r3,1
   a119c:	003fee06 	br	a1158 <__alt_data_end+0xfffe1158>

000a11a0 <__modsi3>:
   a11a0:	20001716 	blt	r4,zero,a1200 <__modsi3+0x60>
   a11a4:	000f883a 	mov	r7,zero
   a11a8:	2005883a 	mov	r2,r4
   a11ac:	28001216 	blt	r5,zero,a11f8 <__modsi3+0x58>
   a11b0:	2900162e 	bgeu	r5,r4,a120c <__modsi3+0x6c>
   a11b4:	01800804 	movi	r6,32
   a11b8:	00c00044 	movi	r3,1
   a11bc:	00000106 	br	a11c4 <__modsi3+0x24>
   a11c0:	30000a26 	beq	r6,zero,a11ec <__modsi3+0x4c>
   a11c4:	294b883a 	add	r5,r5,r5
   a11c8:	31bfffc4 	addi	r6,r6,-1
   a11cc:	18c7883a 	add	r3,r3,r3
   a11d0:	293ffb36 	bltu	r5,r4,a11c0 <__alt_data_end+0xfffe11c0>
   a11d4:	18000526 	beq	r3,zero,a11ec <__modsi3+0x4c>
   a11d8:	1806d07a 	srli	r3,r3,1
   a11dc:	11400136 	bltu	r2,r5,a11e4 <__modsi3+0x44>
   a11e0:	1145c83a 	sub	r2,r2,r5
   a11e4:	280ad07a 	srli	r5,r5,1
   a11e8:	183ffb1e 	bne	r3,zero,a11d8 <__alt_data_end+0xfffe11d8>
   a11ec:	38000126 	beq	r7,zero,a11f4 <__modsi3+0x54>
   a11f0:	0085c83a 	sub	r2,zero,r2
   a11f4:	f800283a 	ret
   a11f8:	014bc83a 	sub	r5,zero,r5
   a11fc:	003fec06 	br	a11b0 <__alt_data_end+0xfffe11b0>
   a1200:	0109c83a 	sub	r4,zero,r4
   a1204:	01c00044 	movi	r7,1
   a1208:	003fe706 	br	a11a8 <__alt_data_end+0xfffe11a8>
   a120c:	00c00044 	movi	r3,1
   a1210:	003ff106 	br	a11d8 <__alt_data_end+0xfffe11d8>

000a1214 <__udivsi3>:
   a1214:	200d883a 	mov	r6,r4
   a1218:	2900152e 	bgeu	r5,r4,a1270 <__udivsi3+0x5c>
   a121c:	28001416 	blt	r5,zero,a1270 <__udivsi3+0x5c>
   a1220:	00800804 	movi	r2,32
   a1224:	00c00044 	movi	r3,1
   a1228:	00000206 	br	a1234 <__udivsi3+0x20>
   a122c:	10000e26 	beq	r2,zero,a1268 <__udivsi3+0x54>
   a1230:	28000516 	blt	r5,zero,a1248 <__udivsi3+0x34>
   a1234:	294b883a 	add	r5,r5,r5
   a1238:	10bfffc4 	addi	r2,r2,-1
   a123c:	18c7883a 	add	r3,r3,r3
   a1240:	293ffa36 	bltu	r5,r4,a122c <__alt_data_end+0xfffe122c>
   a1244:	18000826 	beq	r3,zero,a1268 <__udivsi3+0x54>
   a1248:	0005883a 	mov	r2,zero
   a124c:	31400236 	bltu	r6,r5,a1258 <__udivsi3+0x44>
   a1250:	314dc83a 	sub	r6,r6,r5
   a1254:	10c4b03a 	or	r2,r2,r3
   a1258:	1806d07a 	srli	r3,r3,1
   a125c:	280ad07a 	srli	r5,r5,1
   a1260:	183ffa1e 	bne	r3,zero,a124c <__alt_data_end+0xfffe124c>
   a1264:	f800283a 	ret
   a1268:	0005883a 	mov	r2,zero
   a126c:	f800283a 	ret
   a1270:	00c00044 	movi	r3,1
   a1274:	003ff406 	br	a1248 <__alt_data_end+0xfffe1248>

000a1278 <__umodsi3>:
   a1278:	2005883a 	mov	r2,r4
   a127c:	2900122e 	bgeu	r5,r4,a12c8 <__umodsi3+0x50>
   a1280:	28001116 	blt	r5,zero,a12c8 <__umodsi3+0x50>
   a1284:	01800804 	movi	r6,32
   a1288:	00c00044 	movi	r3,1
   a128c:	00000206 	br	a1298 <__umodsi3+0x20>
   a1290:	30000c26 	beq	r6,zero,a12c4 <__umodsi3+0x4c>
   a1294:	28000516 	blt	r5,zero,a12ac <__umodsi3+0x34>
   a1298:	294b883a 	add	r5,r5,r5
   a129c:	31bfffc4 	addi	r6,r6,-1
   a12a0:	18c7883a 	add	r3,r3,r3
   a12a4:	293ffa36 	bltu	r5,r4,a1290 <__alt_data_end+0xfffe1290>
   a12a8:	18000626 	beq	r3,zero,a12c4 <__umodsi3+0x4c>
   a12ac:	1806d07a 	srli	r3,r3,1
   a12b0:	11400136 	bltu	r2,r5,a12b8 <__umodsi3+0x40>
   a12b4:	1145c83a 	sub	r2,r2,r5
   a12b8:	280ad07a 	srli	r5,r5,1
   a12bc:	183ffb1e 	bne	r3,zero,a12ac <__alt_data_end+0xfffe12ac>
   a12c0:	f800283a 	ret
   a12c4:	f800283a 	ret
   a12c8:	00c00044 	movi	r3,1
   a12cc:	003ff706 	br	a12ac <__alt_data_end+0xfffe12ac>

000a12d0 <_printf_r>:
   a12d0:	defffd04 	addi	sp,sp,-12
   a12d4:	dfc00015 	stw	ra,0(sp)
   a12d8:	d9800115 	stw	r6,4(sp)
   a12dc:	d9c00215 	stw	r7,8(sp)
   a12e0:	20c00217 	ldw	r3,8(r4)
   a12e4:	018002b4 	movhi	r6,10
   a12e8:	31866f04 	addi	r6,r6,6588
   a12ec:	19800115 	stw	r6,4(r3)
   a12f0:	280d883a 	mov	r6,r5
   a12f4:	21400217 	ldw	r5,8(r4)
   a12f8:	d9c00104 	addi	r7,sp,4
   a12fc:	00a14740 	call	a1474 <___vfprintf_internal_r>
   a1300:	dfc00017 	ldw	ra,0(sp)
   a1304:	dec00304 	addi	sp,sp,12
   a1308:	f800283a 	ret

000a130c <printf>:
   a130c:	defffc04 	addi	sp,sp,-16
   a1310:	dfc00015 	stw	ra,0(sp)
   a1314:	d9400115 	stw	r5,4(sp)
   a1318:	d9800215 	stw	r6,8(sp)
   a131c:	d9c00315 	stw	r7,12(sp)
   a1320:	008002b4 	movhi	r2,10
   a1324:	10961304 	addi	r2,r2,22604
   a1328:	10800017 	ldw	r2,0(r2)
   a132c:	014002b4 	movhi	r5,10
   a1330:	29466f04 	addi	r5,r5,6588
   a1334:	10c00217 	ldw	r3,8(r2)
   a1338:	d9800104 	addi	r6,sp,4
   a133c:	19400115 	stw	r5,4(r3)
   a1340:	200b883a 	mov	r5,r4
   a1344:	11000217 	ldw	r4,8(r2)
   a1348:	00a19a00 	call	a19a0 <__vfprintf_internal>
   a134c:	dfc00017 	ldw	ra,0(sp)
   a1350:	dec00404 	addi	sp,sp,16
   a1354:	f800283a 	ret

000a1358 <_puts_r>:
   a1358:	defffd04 	addi	sp,sp,-12
   a135c:	dc000015 	stw	r16,0(sp)
   a1360:	2021883a 	mov	r16,r4
   a1364:	2809883a 	mov	r4,r5
   a1368:	dfc00215 	stw	ra,8(sp)
   a136c:	dc400115 	stw	r17,4(sp)
   a1370:	2823883a 	mov	r17,r5
   a1374:	00a13ec0 	call	a13ec <strlen>
   a1378:	81400217 	ldw	r5,8(r16)
   a137c:	010002b4 	movhi	r4,10
   a1380:	21066f04 	addi	r4,r4,6588
   a1384:	29000115 	stw	r4,4(r5)
   a1388:	100f883a 	mov	r7,r2
   a138c:	880d883a 	mov	r6,r17
   a1390:	8009883a 	mov	r4,r16
   a1394:	00a19bc0 	call	a19bc <__sfvwrite_small_dev>
   a1398:	00ffffc4 	movi	r3,-1
   a139c:	10c00926 	beq	r2,r3,a13c4 <_puts_r+0x6c>
   a13a0:	81400217 	ldw	r5,8(r16)
   a13a4:	018002b4 	movhi	r6,10
   a13a8:	01c00044 	movi	r7,1
   a13ac:	28800117 	ldw	r2,4(r5)
   a13b0:	31942504 	addi	r6,r6,20628
   a13b4:	8009883a 	mov	r4,r16
   a13b8:	103ee83a 	callr	r2
   a13bc:	10bfffe0 	cmpeqi	r2,r2,-1
   a13c0:	0085c83a 	sub	r2,zero,r2
   a13c4:	dfc00217 	ldw	ra,8(sp)
   a13c8:	dc400117 	ldw	r17,4(sp)
   a13cc:	dc000017 	ldw	r16,0(sp)
   a13d0:	dec00304 	addi	sp,sp,12
   a13d4:	f800283a 	ret

000a13d8 <puts>:
   a13d8:	008002b4 	movhi	r2,10
   a13dc:	10961304 	addi	r2,r2,22604
   a13e0:	200b883a 	mov	r5,r4
   a13e4:	11000017 	ldw	r4,0(r2)
   a13e8:	00a13581 	jmpi	a1358 <_puts_r>

000a13ec <strlen>:
   a13ec:	2005883a 	mov	r2,r4
   a13f0:	10c00007 	ldb	r3,0(r2)
   a13f4:	18000226 	beq	r3,zero,a1400 <strlen+0x14>
   a13f8:	10800044 	addi	r2,r2,1
   a13fc:	003ffc06 	br	a13f0 <__alt_data_end+0xfffe13f0>
   a1400:	1105c83a 	sub	r2,r2,r4
   a1404:	f800283a 	ret

000a1408 <print_repeat>:
   a1408:	defffb04 	addi	sp,sp,-20
   a140c:	dc800315 	stw	r18,12(sp)
   a1410:	dc400215 	stw	r17,8(sp)
   a1414:	dc000115 	stw	r16,4(sp)
   a1418:	dfc00415 	stw	ra,16(sp)
   a141c:	2025883a 	mov	r18,r4
   a1420:	2823883a 	mov	r17,r5
   a1424:	d9800005 	stb	r6,0(sp)
   a1428:	3821883a 	mov	r16,r7
   a142c:	04000a0e 	bge	zero,r16,a1458 <print_repeat+0x50>
   a1430:	88800117 	ldw	r2,4(r17)
   a1434:	01c00044 	movi	r7,1
   a1438:	d80d883a 	mov	r6,sp
   a143c:	880b883a 	mov	r5,r17
   a1440:	9009883a 	mov	r4,r18
   a1444:	103ee83a 	callr	r2
   a1448:	843fffc4 	addi	r16,r16,-1
   a144c:	103ff726 	beq	r2,zero,a142c <__alt_data_end+0xfffe142c>
   a1450:	00bfffc4 	movi	r2,-1
   a1454:	00000106 	br	a145c <print_repeat+0x54>
   a1458:	0005883a 	mov	r2,zero
   a145c:	dfc00417 	ldw	ra,16(sp)
   a1460:	dc800317 	ldw	r18,12(sp)
   a1464:	dc400217 	ldw	r17,8(sp)
   a1468:	dc000117 	ldw	r16,4(sp)
   a146c:	dec00504 	addi	sp,sp,20
   a1470:	f800283a 	ret

000a1474 <___vfprintf_internal_r>:
   a1474:	deffe504 	addi	sp,sp,-108
   a1478:	d8c00804 	addi	r3,sp,32
   a147c:	ddc01815 	stw	r23,96(sp)
   a1480:	dd801715 	stw	r22,92(sp)
   a1484:	dd401615 	stw	r21,88(sp)
   a1488:	dd001515 	stw	r20,84(sp)
   a148c:	dcc01415 	stw	r19,80(sp)
   a1490:	dc801315 	stw	r18,76(sp)
   a1494:	dc401215 	stw	r17,72(sp)
   a1498:	dc001115 	stw	r16,68(sp)
   a149c:	dfc01a15 	stw	ra,104(sp)
   a14a0:	df001915 	stw	fp,100(sp)
   a14a4:	2029883a 	mov	r20,r4
   a14a8:	2823883a 	mov	r17,r5
   a14ac:	382d883a 	mov	r22,r7
   a14b0:	d9800f15 	stw	r6,60(sp)
   a14b4:	0021883a 	mov	r16,zero
   a14b8:	d8000e15 	stw	zero,56(sp)
   a14bc:	d8000a15 	stw	zero,40(sp)
   a14c0:	002b883a 	mov	r21,zero
   a14c4:	0027883a 	mov	r19,zero
   a14c8:	0025883a 	mov	r18,zero
   a14cc:	d8000c15 	stw	zero,48(sp)
   a14d0:	d8000b15 	stw	zero,44(sp)
   a14d4:	002f883a 	mov	r23,zero
   a14d8:	d8c00915 	stw	r3,36(sp)
   a14dc:	d8c00f17 	ldw	r3,60(sp)
   a14e0:	19000003 	ldbu	r4,0(r3)
   a14e4:	20803fcc 	andi	r2,r4,255
   a14e8:	1080201c 	xori	r2,r2,128
   a14ec:	10bfe004 	addi	r2,r2,-128
   a14f0:	10011e26 	beq	r2,zero,a196c <___vfprintf_internal_r+0x4f8>
   a14f4:	00c00044 	movi	r3,1
   a14f8:	b8c01426 	beq	r23,r3,a154c <___vfprintf_internal_r+0xd8>
   a14fc:	1dc00216 	blt	r3,r23,a1508 <___vfprintf_internal_r+0x94>
   a1500:	b8000626 	beq	r23,zero,a151c <___vfprintf_internal_r+0xa8>
   a1504:	00011506 	br	a195c <___vfprintf_internal_r+0x4e8>
   a1508:	01400084 	movi	r5,2
   a150c:	b9401d26 	beq	r23,r5,a1584 <___vfprintf_internal_r+0x110>
   a1510:	014000c4 	movi	r5,3
   a1514:	b9402b26 	beq	r23,r5,a15c4 <___vfprintf_internal_r+0x150>
   a1518:	00011006 	br	a195c <___vfprintf_internal_r+0x4e8>
   a151c:	01400944 	movi	r5,37
   a1520:	1140fc26 	beq	r2,r5,a1914 <___vfprintf_internal_r+0x4a0>
   a1524:	88800117 	ldw	r2,4(r17)
   a1528:	d9000005 	stb	r4,0(sp)
   a152c:	01c00044 	movi	r7,1
   a1530:	d80d883a 	mov	r6,sp
   a1534:	880b883a 	mov	r5,r17
   a1538:	a009883a 	mov	r4,r20
   a153c:	103ee83a 	callr	r2
   a1540:	1000d81e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a1544:	84000044 	addi	r16,r16,1
   a1548:	00010406 	br	a195c <___vfprintf_internal_r+0x4e8>
   a154c:	01400c04 	movi	r5,48
   a1550:	1140fa26 	beq	r2,r5,a193c <___vfprintf_internal_r+0x4c8>
   a1554:	01400944 	movi	r5,37
   a1558:	11400a1e 	bne	r2,r5,a1584 <___vfprintf_internal_r+0x110>
   a155c:	d8800005 	stb	r2,0(sp)
   a1560:	88800117 	ldw	r2,4(r17)
   a1564:	b80f883a 	mov	r7,r23
   a1568:	d80d883a 	mov	r6,sp
   a156c:	880b883a 	mov	r5,r17
   a1570:	a009883a 	mov	r4,r20
   a1574:	103ee83a 	callr	r2
   a1578:	1000ca1e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a157c:	84000044 	addi	r16,r16,1
   a1580:	0000f506 	br	a1958 <___vfprintf_internal_r+0x4e4>
   a1584:	25fff404 	addi	r23,r4,-48
   a1588:	bdc03fcc 	andi	r23,r23,255
   a158c:	00c00244 	movi	r3,9
   a1590:	1dc00936 	bltu	r3,r23,a15b8 <___vfprintf_internal_r+0x144>
   a1594:	00bfffc4 	movi	r2,-1
   a1598:	90800426 	beq	r18,r2,a15ac <___vfprintf_internal_r+0x138>
   a159c:	01400284 	movi	r5,10
   a15a0:	9009883a 	mov	r4,r18
   a15a4:	00a1acc0 	call	a1acc <__mulsi3>
   a15a8:	00000106 	br	a15b0 <___vfprintf_internal_r+0x13c>
   a15ac:	0005883a 	mov	r2,zero
   a15b0:	b8a5883a 	add	r18,r23,r2
   a15b4:	0000e206 	br	a1940 <___vfprintf_internal_r+0x4cc>
   a15b8:	01400b84 	movi	r5,46
   a15bc:	1140e426 	beq	r2,r5,a1950 <___vfprintf_internal_r+0x4dc>
   a15c0:	05c00084 	movi	r23,2
   a15c4:	213ff404 	addi	r4,r4,-48
   a15c8:	27003fcc 	andi	fp,r4,255
   a15cc:	00c00244 	movi	r3,9
   a15d0:	1f000936 	bltu	r3,fp,a15f8 <___vfprintf_internal_r+0x184>
   a15d4:	00bfffc4 	movi	r2,-1
   a15d8:	98800426 	beq	r19,r2,a15ec <___vfprintf_internal_r+0x178>
   a15dc:	01400284 	movi	r5,10
   a15e0:	9809883a 	mov	r4,r19
   a15e4:	00a1acc0 	call	a1acc <__mulsi3>
   a15e8:	00000106 	br	a15f0 <___vfprintf_internal_r+0x17c>
   a15ec:	0005883a 	mov	r2,zero
   a15f0:	e0a7883a 	add	r19,fp,r2
   a15f4:	0000d906 	br	a195c <___vfprintf_internal_r+0x4e8>
   a15f8:	00c01b04 	movi	r3,108
   a15fc:	10c0d226 	beq	r2,r3,a1948 <___vfprintf_internal_r+0x4d4>
   a1600:	013fffc4 	movi	r4,-1
   a1604:	99000226 	beq	r19,r4,a1610 <___vfprintf_internal_r+0x19c>
   a1608:	d8000b15 	stw	zero,44(sp)
   a160c:	00000106 	br	a1614 <___vfprintf_internal_r+0x1a0>
   a1610:	04c00044 	movi	r19,1
   a1614:	01001a44 	movi	r4,105
   a1618:	11001626 	beq	r2,r4,a1674 <___vfprintf_internal_r+0x200>
   a161c:	20800916 	blt	r4,r2,a1644 <___vfprintf_internal_r+0x1d0>
   a1620:	010018c4 	movi	r4,99
   a1624:	11008826 	beq	r2,r4,a1848 <___vfprintf_internal_r+0x3d4>
   a1628:	01001904 	movi	r4,100
   a162c:	11001126 	beq	r2,r4,a1674 <___vfprintf_internal_r+0x200>
   a1630:	01001604 	movi	r4,88
   a1634:	1100c81e 	bne	r2,r4,a1958 <___vfprintf_internal_r+0x4e4>
   a1638:	00c00044 	movi	r3,1
   a163c:	d8c00e15 	stw	r3,56(sp)
   a1640:	00001506 	br	a1698 <___vfprintf_internal_r+0x224>
   a1644:	01001cc4 	movi	r4,115
   a1648:	11009826 	beq	r2,r4,a18ac <___vfprintf_internal_r+0x438>
   a164c:	20800416 	blt	r4,r2,a1660 <___vfprintf_internal_r+0x1ec>
   a1650:	01001bc4 	movi	r4,111
   a1654:	1100c01e 	bne	r2,r4,a1958 <___vfprintf_internal_r+0x4e4>
   a1658:	05400204 	movi	r21,8
   a165c:	00000f06 	br	a169c <___vfprintf_internal_r+0x228>
   a1660:	01001d44 	movi	r4,117
   a1664:	11000d26 	beq	r2,r4,a169c <___vfprintf_internal_r+0x228>
   a1668:	01001e04 	movi	r4,120
   a166c:	11000a26 	beq	r2,r4,a1698 <___vfprintf_internal_r+0x224>
   a1670:	0000b906 	br	a1958 <___vfprintf_internal_r+0x4e4>
   a1674:	d8c00a17 	ldw	r3,40(sp)
   a1678:	b7000104 	addi	fp,r22,4
   a167c:	18000726 	beq	r3,zero,a169c <___vfprintf_internal_r+0x228>
   a1680:	df000d15 	stw	fp,52(sp)
   a1684:	b5c00017 	ldw	r23,0(r22)
   a1688:	b800080e 	bge	r23,zero,a16ac <___vfprintf_internal_r+0x238>
   a168c:	05efc83a 	sub	r23,zero,r23
   a1690:	02400044 	movi	r9,1
   a1694:	00000606 	br	a16b0 <___vfprintf_internal_r+0x23c>
   a1698:	05400404 	movi	r21,16
   a169c:	b0c00104 	addi	r3,r22,4
   a16a0:	d8c00d15 	stw	r3,52(sp)
   a16a4:	b5c00017 	ldw	r23,0(r22)
   a16a8:	d8000a15 	stw	zero,40(sp)
   a16ac:	0013883a 	mov	r9,zero
   a16b0:	d839883a 	mov	fp,sp
   a16b4:	b8001726 	beq	r23,zero,a1714 <___vfprintf_internal_r+0x2a0>
   a16b8:	a80b883a 	mov	r5,r21
   a16bc:	b809883a 	mov	r4,r23
   a16c0:	da401015 	stw	r9,64(sp)
   a16c4:	00a12140 	call	a1214 <__udivsi3>
   a16c8:	a80b883a 	mov	r5,r21
   a16cc:	1009883a 	mov	r4,r2
   a16d0:	102d883a 	mov	r22,r2
   a16d4:	00a1acc0 	call	a1acc <__mulsi3>
   a16d8:	b885c83a 	sub	r2,r23,r2
   a16dc:	00c00244 	movi	r3,9
   a16e0:	da401017 	ldw	r9,64(sp)
   a16e4:	18800216 	blt	r3,r2,a16f0 <___vfprintf_internal_r+0x27c>
   a16e8:	10800c04 	addi	r2,r2,48
   a16ec:	00000506 	br	a1704 <___vfprintf_internal_r+0x290>
   a16f0:	d8c00e17 	ldw	r3,56(sp)
   a16f4:	18000226 	beq	r3,zero,a1700 <___vfprintf_internal_r+0x28c>
   a16f8:	10800dc4 	addi	r2,r2,55
   a16fc:	00000106 	br	a1704 <___vfprintf_internal_r+0x290>
   a1700:	108015c4 	addi	r2,r2,87
   a1704:	e0800005 	stb	r2,0(fp)
   a1708:	b02f883a 	mov	r23,r22
   a170c:	e7000044 	addi	fp,fp,1
   a1710:	003fe806 	br	a16b4 <__alt_data_end+0xfffe16b4>
   a1714:	e6efc83a 	sub	r23,fp,sp
   a1718:	9dc5c83a 	sub	r2,r19,r23
   a171c:	0080090e 	bge	zero,r2,a1744 <___vfprintf_internal_r+0x2d0>
   a1720:	e085883a 	add	r2,fp,r2
   a1724:	01400c04 	movi	r5,48
   a1728:	d8c00917 	ldw	r3,36(sp)
   a172c:	e009883a 	mov	r4,fp
   a1730:	e0c0032e 	bgeu	fp,r3,a1740 <___vfprintf_internal_r+0x2cc>
   a1734:	e7000044 	addi	fp,fp,1
   a1738:	21400005 	stb	r5,0(r4)
   a173c:	e0bffa1e 	bne	fp,r2,a1728 <__alt_data_end+0xfffe1728>
   a1740:	e6efc83a 	sub	r23,fp,sp
   a1744:	d8c00b17 	ldw	r3,44(sp)
   a1748:	4dd1883a 	add	r8,r9,r23
   a174c:	922dc83a 	sub	r22,r18,r8
   a1750:	18001626 	beq	r3,zero,a17ac <___vfprintf_internal_r+0x338>
   a1754:	48000a26 	beq	r9,zero,a1780 <___vfprintf_internal_r+0x30c>
   a1758:	00800b44 	movi	r2,45
   a175c:	d8800805 	stb	r2,32(sp)
   a1760:	88800117 	ldw	r2,4(r17)
   a1764:	01c00044 	movi	r7,1
   a1768:	d9800804 	addi	r6,sp,32
   a176c:	880b883a 	mov	r5,r17
   a1770:	a009883a 	mov	r4,r20
   a1774:	103ee83a 	callr	r2
   a1778:	10004a1e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a177c:	84000044 	addi	r16,r16,1
   a1780:	0580070e 	bge	zero,r22,a17a0 <___vfprintf_internal_r+0x32c>
   a1784:	b00f883a 	mov	r7,r22
   a1788:	01800c04 	movi	r6,48
   a178c:	880b883a 	mov	r5,r17
   a1790:	a009883a 	mov	r4,r20
   a1794:	00a14080 	call	a1408 <print_repeat>
   a1798:	1000421e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a179c:	85a1883a 	add	r16,r16,r22
   a17a0:	e02d883a 	mov	r22,fp
   a17a4:	bf2fc83a 	sub	r23,r23,fp
   a17a8:	00002006 	br	a182c <___vfprintf_internal_r+0x3b8>
   a17ac:	0580090e 	bge	zero,r22,a17d4 <___vfprintf_internal_r+0x360>
   a17b0:	b00f883a 	mov	r7,r22
   a17b4:	01800804 	movi	r6,32
   a17b8:	880b883a 	mov	r5,r17
   a17bc:	a009883a 	mov	r4,r20
   a17c0:	da401015 	stw	r9,64(sp)
   a17c4:	00a14080 	call	a1408 <print_repeat>
   a17c8:	da401017 	ldw	r9,64(sp)
   a17cc:	1000351e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a17d0:	85a1883a 	add	r16,r16,r22
   a17d4:	483ff226 	beq	r9,zero,a17a0 <__alt_data_end+0xfffe17a0>
   a17d8:	00800b44 	movi	r2,45
   a17dc:	d8800805 	stb	r2,32(sp)
   a17e0:	88800117 	ldw	r2,4(r17)
   a17e4:	01c00044 	movi	r7,1
   a17e8:	d9800804 	addi	r6,sp,32
   a17ec:	880b883a 	mov	r5,r17
   a17f0:	a009883a 	mov	r4,r20
   a17f4:	103ee83a 	callr	r2
   a17f8:	10002a1e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a17fc:	84000044 	addi	r16,r16,1
   a1800:	003fe706 	br	a17a0 <__alt_data_end+0xfffe17a0>
   a1804:	b5bfffc4 	addi	r22,r22,-1
   a1808:	b0800003 	ldbu	r2,0(r22)
   a180c:	01c00044 	movi	r7,1
   a1810:	d9800804 	addi	r6,sp,32
   a1814:	d8800805 	stb	r2,32(sp)
   a1818:	88800117 	ldw	r2,4(r17)
   a181c:	880b883a 	mov	r5,r17
   a1820:	a009883a 	mov	r4,r20
   a1824:	103ee83a 	callr	r2
   a1828:	10001e1e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a182c:	8585c83a 	sub	r2,r16,r22
   a1830:	b5c9883a 	add	r4,r22,r23
   a1834:	e085883a 	add	r2,fp,r2
   a1838:	013ff216 	blt	zero,r4,a1804 <__alt_data_end+0xfffe1804>
   a183c:	1021883a 	mov	r16,r2
   a1840:	dd800d17 	ldw	r22,52(sp)
   a1844:	00004406 	br	a1958 <___vfprintf_internal_r+0x4e4>
   a1848:	00800044 	movi	r2,1
   a184c:	1480080e 	bge	r2,r18,a1870 <___vfprintf_internal_r+0x3fc>
   a1850:	95ffffc4 	addi	r23,r18,-1
   a1854:	b80f883a 	mov	r7,r23
   a1858:	01800804 	movi	r6,32
   a185c:	880b883a 	mov	r5,r17
   a1860:	a009883a 	mov	r4,r20
   a1864:	00a14080 	call	a1408 <print_repeat>
   a1868:	10000e1e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a186c:	85e1883a 	add	r16,r16,r23
   a1870:	b0800017 	ldw	r2,0(r22)
   a1874:	01c00044 	movi	r7,1
   a1878:	d80d883a 	mov	r6,sp
   a187c:	d8800005 	stb	r2,0(sp)
   a1880:	88800117 	ldw	r2,4(r17)
   a1884:	880b883a 	mov	r5,r17
   a1888:	a009883a 	mov	r4,r20
   a188c:	b5c00104 	addi	r23,r22,4
   a1890:	103ee83a 	callr	r2
   a1894:	1000031e 	bne	r2,zero,a18a4 <___vfprintf_internal_r+0x430>
   a1898:	84000044 	addi	r16,r16,1
   a189c:	b82d883a 	mov	r22,r23
   a18a0:	00002d06 	br	a1958 <___vfprintf_internal_r+0x4e4>
   a18a4:	00bfffc4 	movi	r2,-1
   a18a8:	00003106 	br	a1970 <___vfprintf_internal_r+0x4fc>
   a18ac:	b5c00017 	ldw	r23,0(r22)
   a18b0:	b7000104 	addi	fp,r22,4
   a18b4:	b809883a 	mov	r4,r23
   a18b8:	00a13ec0 	call	a13ec <strlen>
   a18bc:	9091c83a 	sub	r8,r18,r2
   a18c0:	102d883a 	mov	r22,r2
   a18c4:	0200090e 	bge	zero,r8,a18ec <___vfprintf_internal_r+0x478>
   a18c8:	400f883a 	mov	r7,r8
   a18cc:	01800804 	movi	r6,32
   a18d0:	880b883a 	mov	r5,r17
   a18d4:	a009883a 	mov	r4,r20
   a18d8:	da001015 	stw	r8,64(sp)
   a18dc:	00a14080 	call	a1408 <print_repeat>
   a18e0:	da001017 	ldw	r8,64(sp)
   a18e4:	103fef1e 	bne	r2,zero,a18a4 <__alt_data_end+0xfffe18a4>
   a18e8:	8221883a 	add	r16,r16,r8
   a18ec:	88800117 	ldw	r2,4(r17)
   a18f0:	b00f883a 	mov	r7,r22
   a18f4:	b80d883a 	mov	r6,r23
   a18f8:	880b883a 	mov	r5,r17
   a18fc:	a009883a 	mov	r4,r20
   a1900:	103ee83a 	callr	r2
   a1904:	103fe71e 	bne	r2,zero,a18a4 <__alt_data_end+0xfffe18a4>
   a1908:	85a1883a 	add	r16,r16,r22
   a190c:	e02d883a 	mov	r22,fp
   a1910:	00001106 	br	a1958 <___vfprintf_internal_r+0x4e4>
   a1914:	00c00044 	movi	r3,1
   a1918:	04ffffc4 	movi	r19,-1
   a191c:	d8000e15 	stw	zero,56(sp)
   a1920:	d8c00a15 	stw	r3,40(sp)
   a1924:	05400284 	movi	r21,10
   a1928:	9825883a 	mov	r18,r19
   a192c:	d8000c15 	stw	zero,48(sp)
   a1930:	d8000b15 	stw	zero,44(sp)
   a1934:	182f883a 	mov	r23,r3
   a1938:	00000806 	br	a195c <___vfprintf_internal_r+0x4e8>
   a193c:	ddc00b15 	stw	r23,44(sp)
   a1940:	05c00084 	movi	r23,2
   a1944:	00000506 	br	a195c <___vfprintf_internal_r+0x4e8>
   a1948:	00c00044 	movi	r3,1
   a194c:	d8c00c15 	stw	r3,48(sp)
   a1950:	05c000c4 	movi	r23,3
   a1954:	00000106 	br	a195c <___vfprintf_internal_r+0x4e8>
   a1958:	002f883a 	mov	r23,zero
   a195c:	d8c00f17 	ldw	r3,60(sp)
   a1960:	18c00044 	addi	r3,r3,1
   a1964:	d8c00f15 	stw	r3,60(sp)
   a1968:	003edc06 	br	a14dc <__alt_data_end+0xfffe14dc>
   a196c:	8005883a 	mov	r2,r16
   a1970:	dfc01a17 	ldw	ra,104(sp)
   a1974:	df001917 	ldw	fp,100(sp)
   a1978:	ddc01817 	ldw	r23,96(sp)
   a197c:	dd801717 	ldw	r22,92(sp)
   a1980:	dd401617 	ldw	r21,88(sp)
   a1984:	dd001517 	ldw	r20,84(sp)
   a1988:	dcc01417 	ldw	r19,80(sp)
   a198c:	dc801317 	ldw	r18,76(sp)
   a1990:	dc401217 	ldw	r17,72(sp)
   a1994:	dc001117 	ldw	r16,68(sp)
   a1998:	dec01b04 	addi	sp,sp,108
   a199c:	f800283a 	ret

000a19a0 <__vfprintf_internal>:
   a19a0:	008002b4 	movhi	r2,10
   a19a4:	10961304 	addi	r2,r2,22604
   a19a8:	300f883a 	mov	r7,r6
   a19ac:	280d883a 	mov	r6,r5
   a19b0:	200b883a 	mov	r5,r4
   a19b4:	11000017 	ldw	r4,0(r2)
   a19b8:	00a14741 	jmpi	a1474 <___vfprintf_internal_r>

000a19bc <__sfvwrite_small_dev>:
   a19bc:	2880000b 	ldhu	r2,0(r5)
   a19c0:	1080020c 	andi	r2,r2,8
   a19c4:	10002126 	beq	r2,zero,a1a4c <__sfvwrite_small_dev+0x90>
   a19c8:	2880008f 	ldh	r2,2(r5)
   a19cc:	defffa04 	addi	sp,sp,-24
   a19d0:	dc000015 	stw	r16,0(sp)
   a19d4:	dfc00515 	stw	ra,20(sp)
   a19d8:	dd000415 	stw	r20,16(sp)
   a19dc:	dcc00315 	stw	r19,12(sp)
   a19e0:	dc800215 	stw	r18,8(sp)
   a19e4:	dc400115 	stw	r17,4(sp)
   a19e8:	2821883a 	mov	r16,r5
   a19ec:	10001216 	blt	r2,zero,a1a38 <__sfvwrite_small_dev+0x7c>
   a19f0:	2027883a 	mov	r19,r4
   a19f4:	3025883a 	mov	r18,r6
   a19f8:	3823883a 	mov	r17,r7
   a19fc:	05010004 	movi	r20,1024
   a1a00:	04400b0e 	bge	zero,r17,a1a30 <__sfvwrite_small_dev+0x74>
   a1a04:	880f883a 	mov	r7,r17
   a1a08:	a440010e 	bge	r20,r17,a1a10 <__sfvwrite_small_dev+0x54>
   a1a0c:	01c10004 	movi	r7,1024
   a1a10:	8140008f 	ldh	r5,2(r16)
   a1a14:	900d883a 	mov	r6,r18
   a1a18:	9809883a 	mov	r4,r19
   a1a1c:	00a1a740 	call	a1a74 <_write_r>
   a1a20:	0080050e 	bge	zero,r2,a1a38 <__sfvwrite_small_dev+0x7c>
   a1a24:	88a3c83a 	sub	r17,r17,r2
   a1a28:	90a5883a 	add	r18,r18,r2
   a1a2c:	003ff406 	br	a1a00 <__alt_data_end+0xfffe1a00>
   a1a30:	0005883a 	mov	r2,zero
   a1a34:	00000706 	br	a1a54 <__sfvwrite_small_dev+0x98>
   a1a38:	8080000b 	ldhu	r2,0(r16)
   a1a3c:	10801014 	ori	r2,r2,64
   a1a40:	8080000d 	sth	r2,0(r16)
   a1a44:	00bfffc4 	movi	r2,-1
   a1a48:	00000206 	br	a1a54 <__sfvwrite_small_dev+0x98>
   a1a4c:	00bfffc4 	movi	r2,-1
   a1a50:	f800283a 	ret
   a1a54:	dfc00517 	ldw	ra,20(sp)
   a1a58:	dd000417 	ldw	r20,16(sp)
   a1a5c:	dcc00317 	ldw	r19,12(sp)
   a1a60:	dc800217 	ldw	r18,8(sp)
   a1a64:	dc400117 	ldw	r17,4(sp)
   a1a68:	dc000017 	ldw	r16,0(sp)
   a1a6c:	dec00604 	addi	sp,sp,24
   a1a70:	f800283a 	ret

000a1a74 <_write_r>:
   a1a74:	defffd04 	addi	sp,sp,-12
   a1a78:	dc000015 	stw	r16,0(sp)
   a1a7c:	040002b4 	movhi	r16,10
   a1a80:	dc400115 	stw	r17,4(sp)
   a1a84:	8416ff04 	addi	r16,r16,23548
   a1a88:	2023883a 	mov	r17,r4
   a1a8c:	2809883a 	mov	r4,r5
   a1a90:	300b883a 	mov	r5,r6
   a1a94:	380d883a 	mov	r6,r7
   a1a98:	dfc00215 	stw	ra,8(sp)
   a1a9c:	80000015 	stw	zero,0(r16)
   a1aa0:	00a1c880 	call	a1c88 <write>
   a1aa4:	00ffffc4 	movi	r3,-1
   a1aa8:	10c0031e 	bne	r2,r3,a1ab8 <_write_r+0x44>
   a1aac:	80c00017 	ldw	r3,0(r16)
   a1ab0:	18000126 	beq	r3,zero,a1ab8 <_write_r+0x44>
   a1ab4:	88c00015 	stw	r3,0(r17)
   a1ab8:	dfc00217 	ldw	ra,8(sp)
   a1abc:	dc400117 	ldw	r17,4(sp)
   a1ac0:	dc000017 	ldw	r16,0(sp)
   a1ac4:	dec00304 	addi	sp,sp,12
   a1ac8:	f800283a 	ret

000a1acc <__mulsi3>:
   a1acc:	0005883a 	mov	r2,zero
   a1ad0:	20000726 	beq	r4,zero,a1af0 <__mulsi3+0x24>
   a1ad4:	20c0004c 	andi	r3,r4,1
   a1ad8:	2008d07a 	srli	r4,r4,1
   a1adc:	18000126 	beq	r3,zero,a1ae4 <__mulsi3+0x18>
   a1ae0:	1145883a 	add	r2,r2,r5
   a1ae4:	294b883a 	add	r5,r5,r5
   a1ae8:	203ffa1e 	bne	r4,zero,a1ad4 <__alt_data_end+0xfffe1ad4>
   a1aec:	f800283a 	ret
   a1af0:	f800283a 	ret

000a1af4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   a1af4:	defffc04 	addi	sp,sp,-16
   a1af8:	df000315 	stw	fp,12(sp)
   a1afc:	df000304 	addi	fp,sp,12
   a1b00:	e13ffd15 	stw	r4,-12(fp)
   a1b04:	e17ffe15 	stw	r5,-8(fp)
   a1b08:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   a1b0c:	e0fffe17 	ldw	r3,-8(fp)
   a1b10:	e0bffd17 	ldw	r2,-12(fp)
   a1b14:	18800c26 	beq	r3,r2,a1b48 <alt_load_section+0x54>
  {
    while( to != end )
   a1b18:	00000806 	br	a1b3c <alt_load_section+0x48>
    {
      *to++ = *from++;
   a1b1c:	e0bffe17 	ldw	r2,-8(fp)
   a1b20:	10c00104 	addi	r3,r2,4
   a1b24:	e0fffe15 	stw	r3,-8(fp)
   a1b28:	e0fffd17 	ldw	r3,-12(fp)
   a1b2c:	19000104 	addi	r4,r3,4
   a1b30:	e13ffd15 	stw	r4,-12(fp)
   a1b34:	18c00017 	ldw	r3,0(r3)
   a1b38:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   a1b3c:	e0fffe17 	ldw	r3,-8(fp)
   a1b40:	e0bfff17 	ldw	r2,-4(fp)
   a1b44:	18bff51e 	bne	r3,r2,a1b1c <__alt_data_end+0xfffe1b1c>
    {
      *to++ = *from++;
    }
  }
}
   a1b48:	0001883a 	nop
   a1b4c:	e037883a 	mov	sp,fp
   a1b50:	df000017 	ldw	fp,0(sp)
   a1b54:	dec00104 	addi	sp,sp,4
   a1b58:	f800283a 	ret

000a1b5c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   a1b5c:	defffe04 	addi	sp,sp,-8
   a1b60:	dfc00115 	stw	ra,4(sp)
   a1b64:	df000015 	stw	fp,0(sp)
   a1b68:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   a1b6c:	018002b4 	movhi	r6,10
   a1b70:	31961b04 	addi	r6,r6,22636
   a1b74:	014002b4 	movhi	r5,10
   a1b78:	29553d04 	addi	r5,r5,21748
   a1b7c:	010002b4 	movhi	r4,10
   a1b80:	21161b04 	addi	r4,r4,22636
   a1b84:	00a1af40 	call	a1af4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   a1b88:	018002b4 	movhi	r6,10
   a1b8c:	3180a704 	addi	r6,r6,668
   a1b90:	014002b4 	movhi	r5,10
   a1b94:	29400804 	addi	r5,r5,32
   a1b98:	010002b4 	movhi	r4,10
   a1b9c:	21000804 	addi	r4,r4,32
   a1ba0:	00a1af40 	call	a1af4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   a1ba4:	018002b4 	movhi	r6,10
   a1ba8:	31953d04 	addi	r6,r6,21748
   a1bac:	014002b4 	movhi	r5,10
   a1bb0:	2953d604 	addi	r5,r5,20312
   a1bb4:	010002b4 	movhi	r4,10
   a1bb8:	2113d604 	addi	r4,r4,20312
   a1bbc:	00a1af40 	call	a1af4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   a1bc0:	00a42a00 	call	a42a0 <alt_dcache_flush_all>
  alt_icache_flush_all();
   a1bc4:	00a43cc0 	call	a43cc <alt_icache_flush_all>
}
   a1bc8:	0001883a 	nop
   a1bcc:	e037883a 	mov	sp,fp
   a1bd0:	dfc00117 	ldw	ra,4(sp)
   a1bd4:	df000017 	ldw	fp,0(sp)
   a1bd8:	dec00204 	addi	sp,sp,8
   a1bdc:	f800283a 	ret

000a1be0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   a1be0:	defffd04 	addi	sp,sp,-12
   a1be4:	dfc00215 	stw	ra,8(sp)
   a1be8:	df000115 	stw	fp,4(sp)
   a1bec:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   a1bf0:	0009883a 	mov	r4,zero
   a1bf4:	00a1dbc0 	call	a1dbc <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   a1bf8:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   a1bfc:	00a1df40 	call	a1df4 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   a1c00:	018002b4 	movhi	r6,10
   a1c04:	31942604 	addi	r6,r6,20632
   a1c08:	014002b4 	movhi	r5,10
   a1c0c:	29542604 	addi	r5,r5,20632
   a1c10:	010002b4 	movhi	r4,10
   a1c14:	21142604 	addi	r4,r4,20632
   a1c18:	00a44d00 	call	a44d0 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   a1c1c:	d0a0ee17 	ldw	r2,-31816(gp)
   a1c20:	d0e0ef17 	ldw	r3,-31812(gp)
   a1c24:	d120f017 	ldw	r4,-31808(gp)
   a1c28:	200d883a 	mov	r6,r4
   a1c2c:	180b883a 	mov	r5,r3
   a1c30:	1009883a 	mov	r4,r2
   a1c34:	00a02d80 	call	a02d8 <main>
   a1c38:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   a1c3c:	01000044 	movi	r4,1
   a1c40:	00a41c80 	call	a41c8 <close>
  exit (result);
   a1c44:	e13fff17 	ldw	r4,-4(fp)
   a1c48:	00a4d440 	call	a4d44 <exit>

000a1c4c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   a1c4c:	defffe04 	addi	sp,sp,-8
   a1c50:	dfc00115 	stw	ra,4(sp)
   a1c54:	df000015 	stw	fp,0(sp)
   a1c58:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   a1c5c:	d0a00717 	ldw	r2,-32740(gp)
   a1c60:	10000326 	beq	r2,zero,a1c70 <alt_get_errno+0x24>
   a1c64:	d0a00717 	ldw	r2,-32740(gp)
   a1c68:	103ee83a 	callr	r2
   a1c6c:	00000106 	br	a1c74 <alt_get_errno+0x28>
   a1c70:	d0a0ed04 	addi	r2,gp,-31820
}
   a1c74:	e037883a 	mov	sp,fp
   a1c78:	dfc00117 	ldw	ra,4(sp)
   a1c7c:	df000017 	ldw	fp,0(sp)
   a1c80:	dec00204 	addi	sp,sp,8
   a1c84:	f800283a 	ret

000a1c88 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   a1c88:	defff904 	addi	sp,sp,-28
   a1c8c:	dfc00615 	stw	ra,24(sp)
   a1c90:	df000515 	stw	fp,20(sp)
   a1c94:	df000504 	addi	fp,sp,20
   a1c98:	e13ffd15 	stw	r4,-12(fp)
   a1c9c:	e17ffe15 	stw	r5,-8(fp)
   a1ca0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   a1ca4:	e0bffd17 	ldw	r2,-12(fp)
   a1ca8:	10000816 	blt	r2,zero,a1ccc <write+0x44>
   a1cac:	01400304 	movi	r5,12
   a1cb0:	e13ffd17 	ldw	r4,-12(fp)
   a1cb4:	00a1acc0 	call	a1acc <__mulsi3>
   a1cb8:	1007883a 	mov	r3,r2
   a1cbc:	008002b4 	movhi	r2,10
   a1cc0:	1095b204 	addi	r2,r2,22216
   a1cc4:	1885883a 	add	r2,r3,r2
   a1cc8:	00000106 	br	a1cd0 <write+0x48>
   a1ccc:	0005883a 	mov	r2,zero
   a1cd0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   a1cd4:	e0bffb17 	ldw	r2,-20(fp)
   a1cd8:	10002126 	beq	r2,zero,a1d60 <write+0xd8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   a1cdc:	e0bffb17 	ldw	r2,-20(fp)
   a1ce0:	10800217 	ldw	r2,8(r2)
   a1ce4:	108000cc 	andi	r2,r2,3
   a1ce8:	10001826 	beq	r2,zero,a1d4c <write+0xc4>
   a1cec:	e0bffb17 	ldw	r2,-20(fp)
   a1cf0:	10800017 	ldw	r2,0(r2)
   a1cf4:	10800617 	ldw	r2,24(r2)
   a1cf8:	10001426 	beq	r2,zero,a1d4c <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   a1cfc:	e0bffb17 	ldw	r2,-20(fp)
   a1d00:	10800017 	ldw	r2,0(r2)
   a1d04:	10800617 	ldw	r2,24(r2)
   a1d08:	e0ffff17 	ldw	r3,-4(fp)
   a1d0c:	180d883a 	mov	r6,r3
   a1d10:	e17ffe17 	ldw	r5,-8(fp)
   a1d14:	e13ffb17 	ldw	r4,-20(fp)
   a1d18:	103ee83a 	callr	r2
   a1d1c:	e0bffc15 	stw	r2,-16(fp)
   a1d20:	e0bffc17 	ldw	r2,-16(fp)
   a1d24:	1000070e 	bge	r2,zero,a1d44 <write+0xbc>
      {
        ALT_ERRNO = -rval;
   a1d28:	00a1c4c0 	call	a1c4c <alt_get_errno>
   a1d2c:	1007883a 	mov	r3,r2
   a1d30:	e0bffc17 	ldw	r2,-16(fp)
   a1d34:	0085c83a 	sub	r2,zero,r2
   a1d38:	18800015 	stw	r2,0(r3)
        return -1;
   a1d3c:	00bfffc4 	movi	r2,-1
   a1d40:	00000c06 	br	a1d74 <write+0xec>
      }
      return rval;
   a1d44:	e0bffc17 	ldw	r2,-16(fp)
   a1d48:	00000a06 	br	a1d74 <write+0xec>
    }
    else
    {
      ALT_ERRNO = EACCES;
   a1d4c:	00a1c4c0 	call	a1c4c <alt_get_errno>
   a1d50:	1007883a 	mov	r3,r2
   a1d54:	00800344 	movi	r2,13
   a1d58:	18800015 	stw	r2,0(r3)
   a1d5c:	00000406 	br	a1d70 <write+0xe8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   a1d60:	00a1c4c0 	call	a1c4c <alt_get_errno>
   a1d64:	1007883a 	mov	r3,r2
   a1d68:	00801444 	movi	r2,81
   a1d6c:	18800015 	stw	r2,0(r3)
  }
  return -1;
   a1d70:	00bfffc4 	movi	r2,-1
}
   a1d74:	e037883a 	mov	sp,fp
   a1d78:	dfc00117 	ldw	ra,4(sp)
   a1d7c:	df000017 	ldw	fp,0(sp)
   a1d80:	dec00204 	addi	sp,sp,8
   a1d84:	f800283a 	ret

000a1d88 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   a1d88:	defffd04 	addi	sp,sp,-12
   a1d8c:	dfc00215 	stw	ra,8(sp)
   a1d90:	df000115 	stw	fp,4(sp)
   a1d94:	df000104 	addi	fp,sp,4
   a1d98:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   a1d9c:	d1600404 	addi	r5,gp,-32752
   a1da0:	e13fff17 	ldw	r4,-4(fp)
   a1da4:	00a43280 	call	a4328 <alt_dev_llist_insert>
}
   a1da8:	e037883a 	mov	sp,fp
   a1dac:	dfc00117 	ldw	ra,4(sp)
   a1db0:	df000017 	ldw	fp,0(sp)
   a1db4:	dec00204 	addi	sp,sp,8
   a1db8:	f800283a 	ret

000a1dbc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   a1dbc:	defffd04 	addi	sp,sp,-12
   a1dc0:	dfc00215 	stw	ra,8(sp)
   a1dc4:	df000115 	stw	fp,4(sp)
   a1dc8:	df000104 	addi	fp,sp,4
   a1dcc:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, cpu);
   a1dd0:	00a49d40 	call	a49d4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   a1dd4:	00800044 	movi	r2,1
   a1dd8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   a1ddc:	0001883a 	nop
   a1de0:	e037883a 	mov	sp,fp
   a1de4:	dfc00117 	ldw	ra,4(sp)
   a1de8:	df000017 	ldw	fp,0(sp)
   a1dec:	dec00204 	addi	sp,sp,8
   a1df0:	f800283a 	ret

000a1df4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   a1df4:	defffe04 	addi	sp,sp,-8
   a1df8:	dfc00115 	stw	ra,4(sp)
   a1dfc:	df000015 	stw	fp,0(sp)
   a1e00:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   a1e04:	010002b4 	movhi	r4,10
   a1e08:	21159d04 	addi	r4,r4,22132
   a1e0c:	00a1d880 	call	a1d88 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   a1e10:	0001883a 	nop
}
   a1e14:	0001883a 	nop
   a1e18:	e037883a 	mov	sp,fp
   a1e1c:	dfc00117 	ldw	ra,4(sp)
   a1e20:	df000017 	ldw	fp,0(sp)
   a1e24:	dec00204 	addi	sp,sp,8
   a1e28:	f800283a 	ret

000a1e2c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   a1e2c:	defffa04 	addi	sp,sp,-24
   a1e30:	dfc00515 	stw	ra,20(sp)
   a1e34:	df000415 	stw	fp,16(sp)
   a1e38:	df000404 	addi	fp,sp,16
   a1e3c:	e13ffd15 	stw	r4,-12(fp)
   a1e40:	e17ffe15 	stw	r5,-8(fp)
   a1e44:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   a1e48:	e0bffd17 	ldw	r2,-12(fp)
   a1e4c:	10800017 	ldw	r2,0(r2)
   a1e50:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   a1e54:	e0bffc17 	ldw	r2,-16(fp)
   a1e58:	10c00a04 	addi	r3,r2,40
   a1e5c:	e0bffd17 	ldw	r2,-12(fp)
   a1e60:	10800217 	ldw	r2,8(r2)
   a1e64:	100f883a 	mov	r7,r2
   a1e68:	e1bfff17 	ldw	r6,-4(fp)
   a1e6c:	e17ffe17 	ldw	r5,-8(fp)
   a1e70:	1809883a 	mov	r4,r3
   a1e74:	00a1eec0 	call	a1eec <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   a1e78:	e037883a 	mov	sp,fp
   a1e7c:	dfc00117 	ldw	ra,4(sp)
   a1e80:	df000017 	ldw	fp,0(sp)
   a1e84:	dec00204 	addi	sp,sp,8
   a1e88:	f800283a 	ret

000a1e8c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   a1e8c:	defffa04 	addi	sp,sp,-24
   a1e90:	dfc00515 	stw	ra,20(sp)
   a1e94:	df000415 	stw	fp,16(sp)
   a1e98:	df000404 	addi	fp,sp,16
   a1e9c:	e13ffd15 	stw	r4,-12(fp)
   a1ea0:	e17ffe15 	stw	r5,-8(fp)
   a1ea4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   a1ea8:	e0bffd17 	ldw	r2,-12(fp)
   a1eac:	10800017 	ldw	r2,0(r2)
   a1eb0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   a1eb4:	e0bffc17 	ldw	r2,-16(fp)
   a1eb8:	10c00a04 	addi	r3,r2,40
   a1ebc:	e0bffd17 	ldw	r2,-12(fp)
   a1ec0:	10800217 	ldw	r2,8(r2)
   a1ec4:	100f883a 	mov	r7,r2
   a1ec8:	e1bfff17 	ldw	r6,-4(fp)
   a1ecc:	e17ffe17 	ldw	r5,-8(fp)
   a1ed0:	1809883a 	mov	r4,r3
   a1ed4:	00a1fd80 	call	a1fd8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   a1ed8:	e037883a 	mov	sp,fp
   a1edc:	dfc00117 	ldw	ra,4(sp)
   a1ee0:	df000017 	ldw	fp,0(sp)
   a1ee4:	dec00204 	addi	sp,sp,8
   a1ee8:	f800283a 	ret

000a1eec <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
   a1eec:	defff704 	addi	sp,sp,-36
   a1ef0:	df000815 	stw	fp,32(sp)
   a1ef4:	df000804 	addi	fp,sp,32
   a1ef8:	e13ffc15 	stw	r4,-16(fp)
   a1efc:	e17ffd15 	stw	r5,-12(fp)
   a1f00:	e1bffe15 	stw	r6,-8(fp)
   a1f04:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   a1f08:	e0bffc17 	ldw	r2,-16(fp)
   a1f0c:	10800017 	ldw	r2,0(r2)
   a1f10:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
   a1f14:	e0bffd17 	ldw	r2,-12(fp)
   a1f18:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
   a1f1c:	e0bffe17 	ldw	r2,-8(fp)
   a1f20:	e0fffd17 	ldw	r3,-12(fp)
   a1f24:	1885883a 	add	r2,r3,r2
   a1f28:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
   a1f2c:	00001206 	br	a1f78 <altera_avalon_jtag_uart_read+0x8c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   a1f30:	e0bff917 	ldw	r2,-28(fp)
   a1f34:	10800037 	ldwio	r2,0(r2)
   a1f38:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
   a1f3c:	e0bffb17 	ldw	r2,-20(fp)
   a1f40:	10a0000c 	andi	r2,r2,32768
   a1f44:	10000626 	beq	r2,zero,a1f60 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   a1f48:	e0bff817 	ldw	r2,-32(fp)
   a1f4c:	10c00044 	addi	r3,r2,1
   a1f50:	e0fff815 	stw	r3,-32(fp)
   a1f54:	e0fffb17 	ldw	r3,-20(fp)
   a1f58:	10c00005 	stb	r3,0(r2)
   a1f5c:	00000606 	br	a1f78 <altera_avalon_jtag_uart_read+0x8c>
    else if (ptr != buffer)
   a1f60:	e0fff817 	ldw	r3,-32(fp)
   a1f64:	e0bffd17 	ldw	r2,-12(fp)
   a1f68:	1880071e 	bne	r3,r2,a1f88 <altera_avalon_jtag_uart_read+0x9c>
      break;
    else if(flags & O_NONBLOCK)
   a1f6c:	e0bfff17 	ldw	r2,-4(fp)
   a1f70:	1090000c 	andi	r2,r2,16384
   a1f74:	1000061e 	bne	r2,zero,a1f90 <altera_avalon_jtag_uart_read+0xa4>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
   a1f78:	e0fff817 	ldw	r3,-32(fp)
   a1f7c:	e0bffa17 	ldw	r2,-24(fp)
   a1f80:	18bfeb36 	bltu	r3,r2,a1f30 <__alt_data_end+0xfffe1f30>
   a1f84:	00000306 	br	a1f94 <altera_avalon_jtag_uart_read+0xa8>
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
   a1f88:	0001883a 	nop
   a1f8c:	00000106 	br	a1f94 <altera_avalon_jtag_uart_read+0xa8>
    else if(flags & O_NONBLOCK)
      break;   
   a1f90:	0001883a 	nop
    
  }

  if (ptr != buffer)
   a1f94:	e0fff817 	ldw	r3,-32(fp)
   a1f98:	e0bffd17 	ldw	r2,-12(fp)
   a1f9c:	18800426 	beq	r3,r2,a1fb0 <altera_avalon_jtag_uart_read+0xc4>
    return ptr - buffer;
   a1fa0:	e0fff817 	ldw	r3,-32(fp)
   a1fa4:	e0bffd17 	ldw	r2,-12(fp)
   a1fa8:	1885c83a 	sub	r2,r3,r2
   a1fac:	00000606 	br	a1fc8 <altera_avalon_jtag_uart_read+0xdc>
  else if (flags & O_NONBLOCK)
   a1fb0:	e0bfff17 	ldw	r2,-4(fp)
   a1fb4:	1090000c 	andi	r2,r2,16384
   a1fb8:	10000226 	beq	r2,zero,a1fc4 <altera_avalon_jtag_uart_read+0xd8>
    return -EWOULDBLOCK;
   a1fbc:	00bffd44 	movi	r2,-11
   a1fc0:	00000106 	br	a1fc8 <altera_avalon_jtag_uart_read+0xdc>
  else
    return -EIO;
   a1fc4:	00bffec4 	movi	r2,-5
}
   a1fc8:	e037883a 	mov	sp,fp
   a1fcc:	df000017 	ldw	fp,0(sp)
   a1fd0:	dec00104 	addi	sp,sp,4
   a1fd4:	f800283a 	ret

000a1fd8 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   a1fd8:	defff904 	addi	sp,sp,-28
   a1fdc:	df000615 	stw	fp,24(sp)
   a1fe0:	df000604 	addi	fp,sp,24
   a1fe4:	e13ffc15 	stw	r4,-16(fp)
   a1fe8:	e17ffd15 	stw	r5,-12(fp)
   a1fec:	e1bffe15 	stw	r6,-8(fp)
   a1ff0:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   a1ff4:	e0bffc17 	ldw	r2,-16(fp)
   a1ff8:	10800017 	ldw	r2,0(r2)
   a1ffc:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
   a2000:	e0bffe17 	ldw	r2,-8(fp)
   a2004:	e0fffd17 	ldw	r3,-12(fp)
   a2008:	1885883a 	add	r2,r3,r2
   a200c:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
   a2010:	00000e06 	br	a204c <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   a2014:	e0bffa17 	ldw	r2,-24(fp)
   a2018:	10800104 	addi	r2,r2,4
   a201c:	10800037 	ldwio	r2,0(r2)
   a2020:	10bfffec 	andhi	r2,r2,65535
   a2024:	10000926 	beq	r2,zero,a204c <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   a2028:	e0fffa17 	ldw	r3,-24(fp)
   a202c:	e0bffd17 	ldw	r2,-12(fp)
   a2030:	11000044 	addi	r4,r2,1
   a2034:	e13ffd15 	stw	r4,-12(fp)
   a2038:	10800003 	ldbu	r2,0(r2)
   a203c:	10803fcc 	andi	r2,r2,255
   a2040:	1080201c 	xori	r2,r2,128
   a2044:	10bfe004 	addi	r2,r2,-128
   a2048:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   a204c:	e0fffd17 	ldw	r3,-12(fp)
   a2050:	e0bffb17 	ldw	r2,-20(fp)
   a2054:	18bfef36 	bltu	r3,r2,a2014 <__alt_data_end+0xfffe2014>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
   a2058:	e0bffe17 	ldw	r2,-8(fp)
}
   a205c:	e037883a 	mov	sp,fp
   a2060:	df000017 	ldw	fp,0(sp)
   a2064:	dec00104 	addi	sp,sp,4
   a2068:	f800283a 	ret

000a206c <clear_screen>:
void draw_pixel(alt_32 x,alt_32 y,alt_32 color){
    write_pixel(x,y,color);
}
*/

void clear_screen(alt_u32 color) {
   a206c:	defffb04 	addi	sp,sp,-20
   a2070:	dfc00415 	stw	ra,16(sp)
   a2074:	df000315 	stw	fp,12(sp)
   a2078:	df000304 	addi	fp,sp,12
   a207c:	e13fff15 	stw	r4,-4(fp)
    alt_u32 x,y;
    for(y=0;y<240;y++) {
   a2080:	e03ffe15 	stw	zero,-8(fp)
   a2084:	00001606 	br	a20e0 <clear_screen+0x74>
        for(x=0;x<320;x++) {
   a2088:	e03ffd15 	stw	zero,-12(fp)
   a208c:	00000e06 	br	a20c8 <clear_screen+0x5c>
            write_pixel(x,y,color);
   a2090:	01405004 	movi	r5,320
   a2094:	e13ffe17 	ldw	r4,-8(fp)
   a2098:	00a1acc0 	call	a1acc <__mulsi3>
   a209c:	1007883a 	mov	r3,r2
   a20a0:	e0bffd17 	ldw	r2,-12(fp)
   a20a4:	1885883a 	add	r2,r3,r2
   a20a8:	1085883a 	add	r2,r2,r2
   a20ac:	1085883a 	add	r2,r2,r2
   a20b0:	1007883a 	mov	r3,r2
   a20b4:	e0bfff17 	ldw	r2,-4(fp)
   a20b8:	18800035 	stwio	r2,0(r3)
*/

void clear_screen(alt_u32 color) {
    alt_u32 x,y;
    for(y=0;y<240;y++) {
        for(x=0;x<320;x++) {
   a20bc:	e0bffd17 	ldw	r2,-12(fp)
   a20c0:	10800044 	addi	r2,r2,1
   a20c4:	e0bffd15 	stw	r2,-12(fp)
   a20c8:	e0bffd17 	ldw	r2,-12(fp)
   a20cc:	10805030 	cmpltui	r2,r2,320
   a20d0:	103fef1e 	bne	r2,zero,a2090 <__alt_data_end+0xfffe2090>
}
*/

void clear_screen(alt_u32 color) {
    alt_u32 x,y;
    for(y=0;y<240;y++) {
   a20d4:	e0bffe17 	ldw	r2,-8(fp)
   a20d8:	10800044 	addi	r2,r2,1
   a20dc:	e0bffe15 	stw	r2,-8(fp)
   a20e0:	e0bffe17 	ldw	r2,-8(fp)
   a20e4:	10803c30 	cmpltui	r2,r2,240
   a20e8:	103fe71e 	bne	r2,zero,a2088 <__alt_data_end+0xfffe2088>
        for(x=0;x<320;x++) {
            write_pixel(x,y,color);
        }
    }
}
   a20ec:	0001883a 	nop
   a20f0:	e037883a 	mov	sp,fp
   a20f4:	dfc00117 	ldw	ra,4(sp)
   a20f8:	df000017 	ldw	fp,0(sp)
   a20fc:	dec00204 	addi	sp,sp,8
   a2100:	f800283a 	ret

000a2104 <draw_hline>:

void draw_hline(alt_u32 x_start,alt_u32 y_start,alt_u32 line_lenght,alt_u32 color){
   a2104:	defff904 	addi	sp,sp,-28
   a2108:	dfc00615 	stw	ra,24(sp)
   a210c:	df000515 	stw	fp,20(sp)
   a2110:	df000504 	addi	fp,sp,20
   a2114:	e13ffc15 	stw	r4,-16(fp)
   a2118:	e17ffd15 	stw	r5,-12(fp)
   a211c:	e1bffe15 	stw	r6,-8(fp)
   a2120:	e1ffff15 	stw	r7,-4(fp)
    alt_u32 x;
    for(x=0;x<line_lenght;x++){
   a2124:	e03ffb15 	stw	zero,-20(fp)
   a2128:	00001006 	br	a216c <draw_hline+0x68>
        write_pixel(x_start+x,y_start,color);
   a212c:	01405004 	movi	r5,320
   a2130:	e13ffd17 	ldw	r4,-12(fp)
   a2134:	00a1acc0 	call	a1acc <__mulsi3>
   a2138:	1009883a 	mov	r4,r2
   a213c:	e0fffc17 	ldw	r3,-16(fp)
   a2140:	e0bffb17 	ldw	r2,-20(fp)
   a2144:	1885883a 	add	r2,r3,r2
   a2148:	2085883a 	add	r2,r4,r2
   a214c:	1085883a 	add	r2,r2,r2
   a2150:	1085883a 	add	r2,r2,r2
   a2154:	1007883a 	mov	r3,r2
   a2158:	e0bfff17 	ldw	r2,-4(fp)
   a215c:	18800035 	stwio	r2,0(r3)
    }
}

void draw_hline(alt_u32 x_start,alt_u32 y_start,alt_u32 line_lenght,alt_u32 color){
    alt_u32 x;
    for(x=0;x<line_lenght;x++){
   a2160:	e0bffb17 	ldw	r2,-20(fp)
   a2164:	10800044 	addi	r2,r2,1
   a2168:	e0bffb15 	stw	r2,-20(fp)
   a216c:	e0fffb17 	ldw	r3,-20(fp)
   a2170:	e0bffe17 	ldw	r2,-8(fp)
   a2174:	18bfed36 	bltu	r3,r2,a212c <__alt_data_end+0xfffe212c>
        write_pixel(x_start+x,y_start,color);
    }
}
   a2178:	0001883a 	nop
   a217c:	e037883a 	mov	sp,fp
   a2180:	dfc00117 	ldw	ra,4(sp)
   a2184:	df000017 	ldw	fp,0(sp)
   a2188:	dec00204 	addi	sp,sp,8
   a218c:	f800283a 	ret

000a2190 <draw_vline>:

void draw_vline(alt_u32 x_start,alt_u32 y_start,alt_u32 line_lenght,alt_u32 color){
   a2190:	defff904 	addi	sp,sp,-28
   a2194:	dfc00615 	stw	ra,24(sp)
   a2198:	df000515 	stw	fp,20(sp)
   a219c:	df000504 	addi	fp,sp,20
   a21a0:	e13ffc15 	stw	r4,-16(fp)
   a21a4:	e17ffd15 	stw	r5,-12(fp)
   a21a8:	e1bffe15 	stw	r6,-8(fp)
   a21ac:	e1ffff15 	stw	r7,-4(fp)
    alt_u32 x;
    for(x=0;x<line_lenght;x++){
   a21b0:	e03ffb15 	stw	zero,-20(fp)
   a21b4:	00001106 	br	a21fc <draw_vline+0x6c>
        write_pixel(x_start,y_start+x,color);
   a21b8:	e0fffd17 	ldw	r3,-12(fp)
   a21bc:	e0bffb17 	ldw	r2,-20(fp)
   a21c0:	1885883a 	add	r2,r3,r2
   a21c4:	01405004 	movi	r5,320
   a21c8:	1009883a 	mov	r4,r2
   a21cc:	00a1acc0 	call	a1acc <__mulsi3>
   a21d0:	1007883a 	mov	r3,r2
   a21d4:	e0bffc17 	ldw	r2,-16(fp)
   a21d8:	1885883a 	add	r2,r3,r2
   a21dc:	1085883a 	add	r2,r2,r2
   a21e0:	1085883a 	add	r2,r2,r2
   a21e4:	1007883a 	mov	r3,r2
   a21e8:	e0bfff17 	ldw	r2,-4(fp)
   a21ec:	18800035 	stwio	r2,0(r3)
    }
}

void draw_vline(alt_u32 x_start,alt_u32 y_start,alt_u32 line_lenght,alt_u32 color){
    alt_u32 x;
    for(x=0;x<line_lenght;x++){
   a21f0:	e0bffb17 	ldw	r2,-20(fp)
   a21f4:	10800044 	addi	r2,r2,1
   a21f8:	e0bffb15 	stw	r2,-20(fp)
   a21fc:	e0fffb17 	ldw	r3,-20(fp)
   a2200:	e0bffe17 	ldw	r2,-8(fp)
   a2204:	18bfec36 	bltu	r3,r2,a21b8 <__alt_data_end+0xfffe21b8>
        write_pixel(x_start,y_start+x,color);
    }

}
   a2208:	0001883a 	nop
   a220c:	e037883a 	mov	sp,fp
   a2210:	dfc00117 	ldw	ra,4(sp)
   a2214:	df000017 	ldw	fp,0(sp)
   a2218:	dec00204 	addi	sp,sp,8
   a221c:	f800283a 	ret

000a2220 <draw_circle>:


void draw_circle(alt_u32 x_start,alt_u32 y_start,alt_u32 radius,alt_u32 color){
   a2220:	defff504 	addi	sp,sp,-44
   a2224:	dfc00a15 	stw	ra,40(sp)
   a2228:	df000915 	stw	fp,36(sp)
   a222c:	df000904 	addi	fp,sp,36
   a2230:	e13ffc15 	stw	r4,-16(fp)
   a2234:	e17ffd15 	stw	r5,-12(fp)
   a2238:	e1bffe15 	stw	r6,-8(fp)
   a223c:	e1ffff15 	stw	r7,-4(fp)
    //  Bresenham's circle algorithm
    alt_32 x = radius-1;
   a2240:	e0bffe17 	ldw	r2,-8(fp)
   a2244:	10bfffc4 	addi	r2,r2,-1
   a2248:	e0bff715 	stw	r2,-36(fp)
    alt_32 y = 0;
   a224c:	e03ff815 	stw	zero,-32(fp)
    alt_32 dx = 1;
   a2250:	00800044 	movi	r2,1
   a2254:	e0bff915 	stw	r2,-28(fp)
    alt_32 dy = 1;
   a2258:	00800044 	movi	r2,1
   a225c:	e0bffa15 	stw	r2,-24(fp)
    alt_32 err = dx - (radius << 1);
   a2260:	e0fff917 	ldw	r3,-28(fp)
   a2264:	e0bffe17 	ldw	r2,-8(fp)
   a2268:	1085883a 	add	r2,r2,r2
   a226c:	1885c83a 	sub	r2,r3,r2
   a2270:	e0bffb15 	stw	r2,-20(fp)
    while (x >= y)
   a2274:	00009b06 	br	a24e4 <draw_circle+0x2c4>
    {
        write_pixel(x_start + x, y_start + y, color);
   a2278:	e0fff817 	ldw	r3,-32(fp)
   a227c:	e0bffd17 	ldw	r2,-12(fp)
   a2280:	1885883a 	add	r2,r3,r2
   a2284:	01405004 	movi	r5,320
   a2288:	1009883a 	mov	r4,r2
   a228c:	00a1acc0 	call	a1acc <__mulsi3>
   a2290:	1009883a 	mov	r4,r2
   a2294:	e0fff717 	ldw	r3,-36(fp)
   a2298:	e0bffc17 	ldw	r2,-16(fp)
   a229c:	1885883a 	add	r2,r3,r2
   a22a0:	2085883a 	add	r2,r4,r2
   a22a4:	1085883a 	add	r2,r2,r2
   a22a8:	1085883a 	add	r2,r2,r2
   a22ac:	1007883a 	mov	r3,r2
   a22b0:	e0bfff17 	ldw	r2,-4(fp)
   a22b4:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start + y, y_start + x, color);
   a22b8:	e0fff717 	ldw	r3,-36(fp)
   a22bc:	e0bffd17 	ldw	r2,-12(fp)
   a22c0:	1885883a 	add	r2,r3,r2
   a22c4:	01405004 	movi	r5,320
   a22c8:	1009883a 	mov	r4,r2
   a22cc:	00a1acc0 	call	a1acc <__mulsi3>
   a22d0:	1009883a 	mov	r4,r2
   a22d4:	e0fff817 	ldw	r3,-32(fp)
   a22d8:	e0bffc17 	ldw	r2,-16(fp)
   a22dc:	1885883a 	add	r2,r3,r2
   a22e0:	2085883a 	add	r2,r4,r2
   a22e4:	1085883a 	add	r2,r2,r2
   a22e8:	1085883a 	add	r2,r2,r2
   a22ec:	1007883a 	mov	r3,r2
   a22f0:	e0bfff17 	ldw	r2,-4(fp)
   a22f4:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start - y, y_start + x, color);
   a22f8:	e0fff717 	ldw	r3,-36(fp)
   a22fc:	e0bffd17 	ldw	r2,-12(fp)
   a2300:	1885883a 	add	r2,r3,r2
   a2304:	01405004 	movi	r5,320
   a2308:	1009883a 	mov	r4,r2
   a230c:	00a1acc0 	call	a1acc <__mulsi3>
   a2310:	1009883a 	mov	r4,r2
   a2314:	e0bff817 	ldw	r2,-32(fp)
   a2318:	e0fffc17 	ldw	r3,-16(fp)
   a231c:	1885c83a 	sub	r2,r3,r2
   a2320:	2085883a 	add	r2,r4,r2
   a2324:	1085883a 	add	r2,r2,r2
   a2328:	1085883a 	add	r2,r2,r2
   a232c:	1007883a 	mov	r3,r2
   a2330:	e0bfff17 	ldw	r2,-4(fp)
   a2334:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start - x, y_start + y, color);
   a2338:	e0fff817 	ldw	r3,-32(fp)
   a233c:	e0bffd17 	ldw	r2,-12(fp)
   a2340:	1885883a 	add	r2,r3,r2
   a2344:	01405004 	movi	r5,320
   a2348:	1009883a 	mov	r4,r2
   a234c:	00a1acc0 	call	a1acc <__mulsi3>
   a2350:	1009883a 	mov	r4,r2
   a2354:	e0bff717 	ldw	r2,-36(fp)
   a2358:	e0fffc17 	ldw	r3,-16(fp)
   a235c:	1885c83a 	sub	r2,r3,r2
   a2360:	2085883a 	add	r2,r4,r2
   a2364:	1085883a 	add	r2,r2,r2
   a2368:	1085883a 	add	r2,r2,r2
   a236c:	1007883a 	mov	r3,r2
   a2370:	e0bfff17 	ldw	r2,-4(fp)
   a2374:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start - x, y_start - y, color);
   a2378:	e0bff817 	ldw	r2,-32(fp)
   a237c:	e0fffd17 	ldw	r3,-12(fp)
   a2380:	1885c83a 	sub	r2,r3,r2
   a2384:	01405004 	movi	r5,320
   a2388:	1009883a 	mov	r4,r2
   a238c:	00a1acc0 	call	a1acc <__mulsi3>
   a2390:	1009883a 	mov	r4,r2
   a2394:	e0bff717 	ldw	r2,-36(fp)
   a2398:	e0fffc17 	ldw	r3,-16(fp)
   a239c:	1885c83a 	sub	r2,r3,r2
   a23a0:	2085883a 	add	r2,r4,r2
   a23a4:	1085883a 	add	r2,r2,r2
   a23a8:	1085883a 	add	r2,r2,r2
   a23ac:	1007883a 	mov	r3,r2
   a23b0:	e0bfff17 	ldw	r2,-4(fp)
   a23b4:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start - y, y_start - x, color);
   a23b8:	e0bff717 	ldw	r2,-36(fp)
   a23bc:	e0fffd17 	ldw	r3,-12(fp)
   a23c0:	1885c83a 	sub	r2,r3,r2
   a23c4:	01405004 	movi	r5,320
   a23c8:	1009883a 	mov	r4,r2
   a23cc:	00a1acc0 	call	a1acc <__mulsi3>
   a23d0:	1009883a 	mov	r4,r2
   a23d4:	e0bff817 	ldw	r2,-32(fp)
   a23d8:	e0fffc17 	ldw	r3,-16(fp)
   a23dc:	1885c83a 	sub	r2,r3,r2
   a23e0:	2085883a 	add	r2,r4,r2
   a23e4:	1085883a 	add	r2,r2,r2
   a23e8:	1085883a 	add	r2,r2,r2
   a23ec:	1007883a 	mov	r3,r2
   a23f0:	e0bfff17 	ldw	r2,-4(fp)
   a23f4:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start + y, y_start - x, color);
   a23f8:	e0bff717 	ldw	r2,-36(fp)
   a23fc:	e0fffd17 	ldw	r3,-12(fp)
   a2400:	1885c83a 	sub	r2,r3,r2
   a2404:	01405004 	movi	r5,320
   a2408:	1009883a 	mov	r4,r2
   a240c:	00a1acc0 	call	a1acc <__mulsi3>
   a2410:	1009883a 	mov	r4,r2
   a2414:	e0fff817 	ldw	r3,-32(fp)
   a2418:	e0bffc17 	ldw	r2,-16(fp)
   a241c:	1885883a 	add	r2,r3,r2
   a2420:	2085883a 	add	r2,r4,r2
   a2424:	1085883a 	add	r2,r2,r2
   a2428:	1085883a 	add	r2,r2,r2
   a242c:	1007883a 	mov	r3,r2
   a2430:	e0bfff17 	ldw	r2,-4(fp)
   a2434:	18800035 	stwio	r2,0(r3)
        write_pixel(x_start + x, y_start - y, color);
   a2438:	e0bff817 	ldw	r2,-32(fp)
   a243c:	e0fffd17 	ldw	r3,-12(fp)
   a2440:	1885c83a 	sub	r2,r3,r2
   a2444:	01405004 	movi	r5,320
   a2448:	1009883a 	mov	r4,r2
   a244c:	00a1acc0 	call	a1acc <__mulsi3>
   a2450:	1009883a 	mov	r4,r2
   a2454:	e0fff717 	ldw	r3,-36(fp)
   a2458:	e0bffc17 	ldw	r2,-16(fp)
   a245c:	1885883a 	add	r2,r3,r2
   a2460:	2085883a 	add	r2,r4,r2
   a2464:	1085883a 	add	r2,r2,r2
   a2468:	1085883a 	add	r2,r2,r2
   a246c:	1007883a 	mov	r3,r2
   a2470:	e0bfff17 	ldw	r2,-4(fp)
   a2474:	18800035 	stwio	r2,0(r3)

        if (err <= 0)
   a2478:	e0bffb17 	ldw	r2,-20(fp)
   a247c:	00800a16 	blt	zero,r2,a24a8 <draw_circle+0x288>
        {
            y++;
   a2480:	e0bff817 	ldw	r2,-32(fp)
   a2484:	10800044 	addi	r2,r2,1
   a2488:	e0bff815 	stw	r2,-32(fp)
            err += dy;
   a248c:	e0fffb17 	ldw	r3,-20(fp)
   a2490:	e0bffa17 	ldw	r2,-24(fp)
   a2494:	1885883a 	add	r2,r3,r2
   a2498:	e0bffb15 	stw	r2,-20(fp)
            dy += 2;
   a249c:	e0bffa17 	ldw	r2,-24(fp)
   a24a0:	10800084 	addi	r2,r2,2
   a24a4:	e0bffa15 	stw	r2,-24(fp)
        }
        if (err > 0)
   a24a8:	e0bffb17 	ldw	r2,-20(fp)
   a24ac:	00800d0e 	bge	zero,r2,a24e4 <draw_circle+0x2c4>
        {
            x--;
   a24b0:	e0bff717 	ldw	r2,-36(fp)
   a24b4:	10bfffc4 	addi	r2,r2,-1
   a24b8:	e0bff715 	stw	r2,-36(fp)
            dx += 2;
   a24bc:	e0bff917 	ldw	r2,-28(fp)
   a24c0:	10800084 	addi	r2,r2,2
   a24c4:	e0bff915 	stw	r2,-28(fp)
            err += dx - (radius << 1);
   a24c8:	e0fff917 	ldw	r3,-28(fp)
   a24cc:	e0bffe17 	ldw	r2,-8(fp)
   a24d0:	1085883a 	add	r2,r2,r2
   a24d4:	1887c83a 	sub	r3,r3,r2
   a24d8:	e0bffb17 	ldw	r2,-20(fp)
   a24dc:	1885883a 	add	r2,r3,r2
   a24e0:	e0bffb15 	stw	r2,-20(fp)
    alt_32 x = radius-1;
    alt_32 y = 0;
    alt_32 dx = 1;
    alt_32 dy = 1;
    alt_32 err = dx - (radius << 1);
    while (x >= y)
   a24e4:	e0fff717 	ldw	r3,-36(fp)
   a24e8:	e0bff817 	ldw	r2,-32(fp)
   a24ec:	18bf620e 	bge	r3,r2,a2278 <__alt_data_end+0xfffe2278>
            x--;
            dx += 2;
            err += dx - (radius << 1);
        }
    }
}
   a24f0:	0001883a 	nop
   a24f4:	e037883a 	mov	sp,fp
   a24f8:	dfc00117 	ldw	ra,4(sp)
   a24fc:	df000017 	ldw	fp,0(sp)
   a2500:	dec00204 	addi	sp,sp,8
   a2504:	f800283a 	ret

000a2508 <draw_filled_circle>:


void draw_filled_circle(alt_32 x0, alt_32 y0, alt_32 radius,alt_32 color)
{
   a2508:	defff304 	addi	sp,sp,-52
   a250c:	dfc00c15 	stw	ra,48(sp)
   a2510:	df000b15 	stw	fp,44(sp)
   a2514:	df000b04 	addi	fp,sp,44
   a2518:	e13ffc15 	stw	r4,-16(fp)
   a251c:	e17ffd15 	stw	r5,-12(fp)
   a2520:	e1bffe15 	stw	r6,-8(fp)
   a2524:	e1ffff15 	stw	r7,-4(fp)
    alt_32 x = radius;
   a2528:	e0bffe17 	ldw	r2,-8(fp)
   a252c:	e0bff515 	stw	r2,-44(fp)
    alt_32 y = 0;
   a2530:	e03ff615 	stw	zero,-40(fp)
    alt_32 xChange = 1 - (radius << 1);
   a2534:	e0bffe17 	ldw	r2,-8(fp)
   a2538:	1085883a 	add	r2,r2,r2
   a253c:	1007883a 	mov	r3,r2
   a2540:	00800044 	movi	r2,1
   a2544:	10c5c83a 	sub	r2,r2,r3
   a2548:	e0bff715 	stw	r2,-36(fp)
    alt_32 yChange = 0;
   a254c:	e03ff815 	stw	zero,-32(fp)
    alt_32 radiusError = 0;
   a2550:	e03ff915 	stw	zero,-28(fp)

    while (x >= y)
   a2554:	00006c06 	br	a2708 <draw_filled_circle+0x200>
    {
        for (alt_32 i = x0 - x; i <= x0 + x; i++)
   a2558:	e0fffc17 	ldw	r3,-16(fp)
   a255c:	e0bff517 	ldw	r2,-44(fp)
   a2560:	1885c83a 	sub	r2,r3,r2
   a2564:	e0bffa15 	stw	r2,-24(fp)
   a2568:	00001f06 	br	a25e8 <draw_filled_circle+0xe0>
        {
            write_pixel(i, y0 + y, color);
   a256c:	e0fffd17 	ldw	r3,-12(fp)
   a2570:	e0bff617 	ldw	r2,-40(fp)
   a2574:	1885883a 	add	r2,r3,r2
   a2578:	01405004 	movi	r5,320
   a257c:	1009883a 	mov	r4,r2
   a2580:	00a1acc0 	call	a1acc <__mulsi3>
   a2584:	1007883a 	mov	r3,r2
   a2588:	e0bffa17 	ldw	r2,-24(fp)
   a258c:	1885883a 	add	r2,r3,r2
   a2590:	1085883a 	add	r2,r2,r2
   a2594:	1085883a 	add	r2,r2,r2
   a2598:	1007883a 	mov	r3,r2
   a259c:	e0bfff17 	ldw	r2,-4(fp)
   a25a0:	18800035 	stwio	r2,0(r3)
            write_pixel(i, y0 - y, color);
   a25a4:	e0fffd17 	ldw	r3,-12(fp)
   a25a8:	e0bff617 	ldw	r2,-40(fp)
   a25ac:	1885c83a 	sub	r2,r3,r2
   a25b0:	01405004 	movi	r5,320
   a25b4:	1009883a 	mov	r4,r2
   a25b8:	00a1acc0 	call	a1acc <__mulsi3>
   a25bc:	1007883a 	mov	r3,r2
   a25c0:	e0bffa17 	ldw	r2,-24(fp)
   a25c4:	1885883a 	add	r2,r3,r2
   a25c8:	1085883a 	add	r2,r2,r2
   a25cc:	1085883a 	add	r2,r2,r2
   a25d0:	1007883a 	mov	r3,r2
   a25d4:	e0bfff17 	ldw	r2,-4(fp)
   a25d8:	18800035 	stwio	r2,0(r3)
    alt_32 yChange = 0;
    alt_32 radiusError = 0;

    while (x >= y)
    {
        for (alt_32 i = x0 - x; i <= x0 + x; i++)
   a25dc:	e0bffa17 	ldw	r2,-24(fp)
   a25e0:	10800044 	addi	r2,r2,1
   a25e4:	e0bffa15 	stw	r2,-24(fp)
   a25e8:	e0fffc17 	ldw	r3,-16(fp)
   a25ec:	e0bff517 	ldw	r2,-44(fp)
   a25f0:	1887883a 	add	r3,r3,r2
   a25f4:	e0bffa17 	ldw	r2,-24(fp)
   a25f8:	18bfdc0e 	bge	r3,r2,a256c <__alt_data_end+0xfffe256c>
        {
            write_pixel(i, y0 + y, color);
            write_pixel(i, y0 - y, color);
        }
        for (alt_32 i = x0 - y; i <= x0 + y; i++)
   a25fc:	e0fffc17 	ldw	r3,-16(fp)
   a2600:	e0bff617 	ldw	r2,-40(fp)
   a2604:	1885c83a 	sub	r2,r3,r2
   a2608:	e0bffb15 	stw	r2,-20(fp)
   a260c:	00001f06 	br	a268c <draw_filled_circle+0x184>
        {
            write_pixel(i, y0 + x, color);
   a2610:	e0fffd17 	ldw	r3,-12(fp)
   a2614:	e0bff517 	ldw	r2,-44(fp)
   a2618:	1885883a 	add	r2,r3,r2
   a261c:	01405004 	movi	r5,320
   a2620:	1009883a 	mov	r4,r2
   a2624:	00a1acc0 	call	a1acc <__mulsi3>
   a2628:	1007883a 	mov	r3,r2
   a262c:	e0bffb17 	ldw	r2,-20(fp)
   a2630:	1885883a 	add	r2,r3,r2
   a2634:	1085883a 	add	r2,r2,r2
   a2638:	1085883a 	add	r2,r2,r2
   a263c:	1007883a 	mov	r3,r2
   a2640:	e0bfff17 	ldw	r2,-4(fp)
   a2644:	18800035 	stwio	r2,0(r3)
            write_pixel(i, y0 - x, color);
   a2648:	e0fffd17 	ldw	r3,-12(fp)
   a264c:	e0bff517 	ldw	r2,-44(fp)
   a2650:	1885c83a 	sub	r2,r3,r2
   a2654:	01405004 	movi	r5,320
   a2658:	1009883a 	mov	r4,r2
   a265c:	00a1acc0 	call	a1acc <__mulsi3>
   a2660:	1007883a 	mov	r3,r2
   a2664:	e0bffb17 	ldw	r2,-20(fp)
   a2668:	1885883a 	add	r2,r3,r2
   a266c:	1085883a 	add	r2,r2,r2
   a2670:	1085883a 	add	r2,r2,r2
   a2674:	1007883a 	mov	r3,r2
   a2678:	e0bfff17 	ldw	r2,-4(fp)
   a267c:	18800035 	stwio	r2,0(r3)
        for (alt_32 i = x0 - x; i <= x0 + x; i++)
        {
            write_pixel(i, y0 + y, color);
            write_pixel(i, y0 - y, color);
        }
        for (alt_32 i = x0 - y; i <= x0 + y; i++)
   a2680:	e0bffb17 	ldw	r2,-20(fp)
   a2684:	10800044 	addi	r2,r2,1
   a2688:	e0bffb15 	stw	r2,-20(fp)
   a268c:	e0fffc17 	ldw	r3,-16(fp)
   a2690:	e0bff617 	ldw	r2,-40(fp)
   a2694:	1887883a 	add	r3,r3,r2
   a2698:	e0bffb17 	ldw	r2,-20(fp)
   a269c:	18bfdc0e 	bge	r3,r2,a2610 <__alt_data_end+0xfffe2610>
        {
            write_pixel(i, y0 + x, color);
            write_pixel(i, y0 - x, color);
        }

        y++;
   a26a0:	e0bff617 	ldw	r2,-40(fp)
   a26a4:	10800044 	addi	r2,r2,1
   a26a8:	e0bff615 	stw	r2,-40(fp)
        radiusError += yChange;
   a26ac:	e0fff917 	ldw	r3,-28(fp)
   a26b0:	e0bff817 	ldw	r2,-32(fp)
   a26b4:	1885883a 	add	r2,r3,r2
   a26b8:	e0bff915 	stw	r2,-28(fp)
        yChange += 2;
   a26bc:	e0bff817 	ldw	r2,-32(fp)
   a26c0:	10800084 	addi	r2,r2,2
   a26c4:	e0bff815 	stw	r2,-32(fp)
        if (((radiusError << 1) + xChange) > 0)
   a26c8:	e0bff917 	ldw	r2,-28(fp)
   a26cc:	1085883a 	add	r2,r2,r2
   a26d0:	1007883a 	mov	r3,r2
   a26d4:	e0bff717 	ldw	r2,-36(fp)
   a26d8:	1885883a 	add	r2,r3,r2
   a26dc:	00800a0e 	bge	zero,r2,a2708 <draw_filled_circle+0x200>
        {
            x--;
   a26e0:	e0bff517 	ldw	r2,-44(fp)
   a26e4:	10bfffc4 	addi	r2,r2,-1
   a26e8:	e0bff515 	stw	r2,-44(fp)
            radiusError += xChange;
   a26ec:	e0fff917 	ldw	r3,-28(fp)
   a26f0:	e0bff717 	ldw	r2,-36(fp)
   a26f4:	1885883a 	add	r2,r3,r2
   a26f8:	e0bff915 	stw	r2,-28(fp)
            xChange += 2;
   a26fc:	e0bff717 	ldw	r2,-36(fp)
   a2700:	10800084 	addi	r2,r2,2
   a2704:	e0bff715 	stw	r2,-36(fp)
    alt_32 y = 0;
    alt_32 xChange = 1 - (radius << 1);
    alt_32 yChange = 0;
    alt_32 radiusError = 0;

    while (x >= y)
   a2708:	e0fff517 	ldw	r3,-44(fp)
   a270c:	e0bff617 	ldw	r2,-40(fp)
   a2710:	18bf910e 	bge	r3,r2,a2558 <__alt_data_end+0xfffe2558>
            x--;
            radiusError += xChange;
            xChange += 2;
        }
    }
}
   a2714:	0001883a 	nop
   a2718:	e037883a 	mov	sp,fp
   a271c:	dfc00117 	ldw	ra,4(sp)
   a2720:	df000017 	ldw	fp,0(sp)
   a2724:	dec00204 	addi	sp,sp,8
   a2728:	f800283a 	ret

000a272c <draw_angled_line>:

void draw_angled_line(alt_u32 x_start,alt_u32 y_start,alt_u32 x_end,alt_u32 y_end,alt_u32 color){
   a272c:	deffef04 	addi	sp,sp,-68
   a2730:	dfc01015 	stw	ra,64(sp)
   a2734:	df000f15 	stw	fp,60(sp)
   a2738:	df000f04 	addi	fp,sp,60
   a273c:	e13ffc15 	stw	r4,-16(fp)
   a2740:	e17ffd15 	stw	r5,-12(fp)
   a2744:	e1bffe15 	stw	r6,-8(fp)
   a2748:	e1ffff15 	stw	r7,-4(fp)
    alt_u32 steep = 0;
   a274c:	e03ff115 	stw	zero,-60(fp)
    alt_32 x0,x1,y0,y1;
    x0 = x_start;
   a2750:	e0bffc17 	ldw	r2,-16(fp)
   a2754:	e0bff215 	stw	r2,-56(fp)
    x1 = x_end;
   a2758:	e0bffe17 	ldw	r2,-8(fp)
   a275c:	e0bff315 	stw	r2,-52(fp)
    y0 = y_start;
   a2760:	e0bffd17 	ldw	r2,-12(fp)
   a2764:	e0bff415 	stw	r2,-48(fp)
    y1 = y_end;
   a2768:	e0bfff17 	ldw	r2,-4(fp)
   a276c:	e0bff515 	stw	r2,-44(fp)

    // Justera vinklar
    if (abs(x_start-x_end)<abs(y_start-y_end)) {
   a2770:	e0fffc17 	ldw	r3,-16(fp)
   a2774:	e0bffe17 	ldw	r2,-8(fp)
   a2778:	1885c83a 	sub	r2,r3,r2
   a277c:	1000010e 	bge	r2,zero,a2784 <draw_angled_line+0x58>
   a2780:	0085c83a 	sub	r2,zero,r2
   a2784:	1009883a 	mov	r4,r2
   a2788:	e0fffd17 	ldw	r3,-12(fp)
   a278c:	e0bfff17 	ldw	r2,-4(fp)
   a2790:	1885c83a 	sub	r2,r3,r2
   a2794:	1000010e 	bge	r2,zero,a279c <draw_angled_line+0x70>
   a2798:	0085c83a 	sub	r2,zero,r2
   a279c:	2080180e 	bge	r4,r2,a2800 <draw_angled_line+0xd4>
        if (y_start > y_end){
   a27a0:	e0bffd17 	ldw	r2,-12(fp)
   a27a4:	e0ffff17 	ldw	r3,-4(fp)
   a27a8:	18800b2e 	bgeu	r3,r2,a27d8 <draw_angled_line+0xac>
            steep = 1;
   a27ac:	00800044 	movi	r2,1
   a27b0:	e0bff115 	stw	r2,-60(fp)
            x0 = y_end;
   a27b4:	e0bfff17 	ldw	r2,-4(fp)
   a27b8:	e0bff215 	stw	r2,-56(fp)
            x1 = y_start;
   a27bc:	e0bffd17 	ldw	r2,-12(fp)
   a27c0:	e0bff315 	stw	r2,-52(fp)
            y0 = x_end;
   a27c4:	e0bffe17 	ldw	r2,-8(fp)
   a27c8:	e0bff415 	stw	r2,-48(fp)
            y1 = x_start;
   a27cc:	e0bffc17 	ldw	r2,-16(fp)
   a27d0:	e0bff515 	stw	r2,-44(fp)
   a27d4:	00000a06 	br	a2800 <draw_angled_line+0xd4>
        }else{
        x0 = y_start;
   a27d8:	e0bffd17 	ldw	r2,-12(fp)
   a27dc:	e0bff215 	stw	r2,-56(fp)
        y0 = x_start;
   a27e0:	e0bffc17 	ldw	r2,-16(fp)
   a27e4:	e0bff415 	stw	r2,-48(fp)
        x1 = y_end;
   a27e8:	e0bfff17 	ldw	r2,-4(fp)
   a27ec:	e0bff315 	stw	r2,-52(fp)
        y1 = x_end;
   a27f0:	e0bffe17 	ldw	r2,-8(fp)
   a27f4:	e0bff515 	stw	r2,-44(fp)
        steep = 1;
   a27f8:	00800044 	movi	r2,1
   a27fc:	e0bff115 	stw	r2,-60(fp)
        }
    }
    if ((x_start>x_end)&&!steep) {
   a2800:	e0bffc17 	ldw	r2,-16(fp)
   a2804:	e0fffe17 	ldw	r3,-8(fp)
   a2808:	18800a2e 	bgeu	r3,r2,a2834 <draw_angled_line+0x108>
   a280c:	e0bff117 	ldw	r2,-60(fp)
   a2810:	1000081e 	bne	r2,zero,a2834 <draw_angled_line+0x108>
        x0 = x_end;
   a2814:	e0bffe17 	ldw	r2,-8(fp)
   a2818:	e0bff215 	stw	r2,-56(fp)
        x1 = x_start;
   a281c:	e0bffc17 	ldw	r2,-16(fp)
   a2820:	e0bff315 	stw	r2,-52(fp)
        y0 = y_end;
   a2824:	e0bfff17 	ldw	r2,-4(fp)
   a2828:	e0bff415 	stw	r2,-48(fp)
        y1 = y_start;
   a282c:	e0bffd17 	ldw	r2,-12(fp)
   a2830:	e0bff515 	stw	r2,-44(fp)
    }


    alt_32 dx = x1-x0;
   a2834:	e0fff317 	ldw	r3,-52(fp)
   a2838:	e0bff217 	ldw	r2,-56(fp)
   a283c:	1885c83a 	sub	r2,r3,r2
   a2840:	e0bff915 	stw	r2,-28(fp)
    alt_32 dy = y1-y0;
   a2844:	e0fff517 	ldw	r3,-44(fp)
   a2848:	e0bff417 	ldw	r2,-48(fp)
   a284c:	1885c83a 	sub	r2,r3,r2
   a2850:	e0bffa15 	stw	r2,-24(fp)
    alt_32 derror = abs(dy)*2;
   a2854:	e0bffa17 	ldw	r2,-24(fp)
   a2858:	1000010e 	bge	r2,zero,a2860 <draw_angled_line+0x134>
   a285c:	0085c83a 	sub	r2,zero,r2
   a2860:	1085883a 	add	r2,r2,r2
   a2864:	e0bffb15 	stw	r2,-20(fp)
    alt_32 error = 0;
   a2868:	e03ff615 	stw	zero,-40(fp)
    alt_32 y = y0;
   a286c:	e0bff417 	ldw	r2,-48(fp)
   a2870:	e0bff715 	stw	r2,-36(fp)
    for (alt_32 x=x0; x<=x1; x++) {
   a2874:	e0bff217 	ldw	r2,-56(fp)
   a2878:	e0bff815 	stw	r2,-32(fp)
   a287c:	00003206 	br	a2948 <draw_angled_line+0x21c>
            if (steep) {
   a2880:	e0bff117 	ldw	r2,-60(fp)
   a2884:	10000c26 	beq	r2,zero,a28b8 <draw_angled_line+0x18c>
                write_pixel(y, x, color);
   a2888:	01405004 	movi	r5,320
   a288c:	e13ff817 	ldw	r4,-32(fp)
   a2890:	00a1acc0 	call	a1acc <__mulsi3>
   a2894:	1007883a 	mov	r3,r2
   a2898:	e0bff717 	ldw	r2,-36(fp)
   a289c:	1885883a 	add	r2,r3,r2
   a28a0:	1085883a 	add	r2,r2,r2
   a28a4:	1085883a 	add	r2,r2,r2
   a28a8:	1007883a 	mov	r3,r2
   a28ac:	e0800217 	ldw	r2,8(fp)
   a28b0:	18800035 	stwio	r2,0(r3)
   a28b4:	00000b06 	br	a28e4 <draw_angled_line+0x1b8>
            } else {
                write_pixel(x, y, color);
   a28b8:	01405004 	movi	r5,320
   a28bc:	e13ff717 	ldw	r4,-36(fp)
   a28c0:	00a1acc0 	call	a1acc <__mulsi3>
   a28c4:	1007883a 	mov	r3,r2
   a28c8:	e0bff817 	ldw	r2,-32(fp)
   a28cc:	1885883a 	add	r2,r3,r2
   a28d0:	1085883a 	add	r2,r2,r2
   a28d4:	1085883a 	add	r2,r2,r2
   a28d8:	1007883a 	mov	r3,r2
   a28dc:	e0800217 	ldw	r2,8(fp)
   a28e0:	18800035 	stwio	r2,0(r3)
            }

        error += derror;
   a28e4:	e0fff617 	ldw	r3,-40(fp)
   a28e8:	e0bffb17 	ldw	r2,-20(fp)
   a28ec:	1885883a 	add	r2,r3,r2
   a28f0:	e0bff615 	stw	r2,-40(fp)
        if (error > dx) {
   a28f4:	e0bff617 	ldw	r2,-40(fp)
   a28f8:	e0fff917 	ldw	r3,-28(fp)
   a28fc:	18800f0e 	bge	r3,r2,a293c <draw_angled_line+0x210>
            y += (y1>y0?1:-1);
   a2900:	e0bff517 	ldw	r2,-44(fp)
   a2904:	e0fff417 	ldw	r3,-48(fp)
   a2908:	1880020e 	bge	r3,r2,a2914 <draw_angled_line+0x1e8>
   a290c:	00800044 	movi	r2,1
   a2910:	00000106 	br	a2918 <draw_angled_line+0x1ec>
   a2914:	00bfffc4 	movi	r2,-1
   a2918:	e0fff717 	ldw	r3,-36(fp)
   a291c:	1885883a 	add	r2,r3,r2
   a2920:	e0bff715 	stw	r2,-36(fp)
            error -= dx*2;
   a2924:	e0bff917 	ldw	r2,-28(fp)
   a2928:	1085883a 	add	r2,r2,r2
   a292c:	1007883a 	mov	r3,r2
   a2930:	e0bff617 	ldw	r2,-40(fp)
   a2934:	10c5c83a 	sub	r2,r2,r3
   a2938:	e0bff615 	stw	r2,-40(fp)
    alt_32 dx = x1-x0;
    alt_32 dy = y1-y0;
    alt_32 derror = abs(dy)*2;
    alt_32 error = 0;
    alt_32 y = y0;
    for (alt_32 x=x0; x<=x1; x++) {
   a293c:	e0bff817 	ldw	r2,-32(fp)
   a2940:	10800044 	addi	r2,r2,1
   a2944:	e0bff815 	stw	r2,-32(fp)
   a2948:	e0bff817 	ldw	r2,-32(fp)
   a294c:	e0fff317 	ldw	r3,-52(fp)
   a2950:	18bfcb0e 	bge	r3,r2,a2880 <__alt_data_end+0xfffe2880>
        if (error > dx) {
            y += (y1>y0?1:-1);
            error -= dx*2;
        }
    }
}
   a2954:	0001883a 	nop
   a2958:	e037883a 	mov	sp,fp
   a295c:	dfc00117 	ldw	ra,4(sp)
   a2960:	df000017 	ldw	fp,0(sp)
   a2964:	dec00204 	addi	sp,sp,8
   a2968:	f800283a 	ret

000a296c <tty_print>:

 void tty_print(alt_32 x_start, alt_32 y_start, alt_8 *tty_string,alt_32 color, alt_u32 BGcolor){
   a296c:	deffeb04 	addi	sp,sp,-84
   a2970:	dfc01415 	stw	ra,80(sp)
   a2974:	df001315 	stw	fp,76(sp)
   a2978:	df001304 	addi	fp,sp,76
   a297c:	e13ffc15 	stw	r4,-16(fp)
   a2980:	e17ffd15 	stw	r5,-12(fp)
   a2984:	e1bffe15 	stw	r6,-8(fp)
   a2988:	e1ffff15 	stw	r7,-4(fp)
     alt_u8 *tpek;
     alt_u32 n = strlen(tty_string);
   a298c:	e13ffe17 	ldw	r4,-8(fp)
   a2990:	00a13ec0 	call	a13ec <strlen>
   a2994:	e0bff715 	stw	r2,-36(fp)
     tpek = tty_string;
   a2998:	e0bffe17 	ldw	r2,-8(fp)
   a299c:	e0bfed15 	stw	r2,-76(fp)
     for(alt_u32 i=0;i<n;i++){ // antal tecken
   a29a0:	e03fee15 	stw	zero,-72(fp)
   a29a4:	00007906 	br	a2b8c <tty_print+0x220>
         alt_u8 tkn = *tpek;
   a29a8:	e0bfed17 	ldw	r2,-76(fp)
   a29ac:	10800003 	ldbu	r2,0(r2)
   a29b0:	e0bff805 	stb	r2,-32(fp)
         alt_u32 pry = y_start ;
   a29b4:	e0bffd17 	ldw	r2,-12(fp)
   a29b8:	e0bfef15 	stw	r2,-68(fp)
         alt_u32 half_tkn = upper_char_line(tkn-0x20);
   a29bc:	e0bff803 	ldbu	r2,-32(fp)
   a29c0:	10bff804 	addi	r2,r2,-32
   a29c4:	10803fcc 	andi	r2,r2,255
   a29c8:	1009883a 	mov	r4,r2
   a29cc:	00a49f80 	call	a49f8 <upper_char_line>
   a29d0:	e0bff915 	stw	r2,-28(fp)
         alt_u32 dot =  half_tkn;
   a29d4:	e0bff917 	ldw	r2,-28(fp)
   a29d8:	e0bff015 	stw	r2,-64(fp)
             for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a29dc:	e03ff115 	stw	zero,-60(fp)
   a29e0:	00002a06 	br	a2a8c <tty_print+0x120>
                 alt_u32 prx = x_start +i*8;
   a29e4:	e0bfee17 	ldw	r2,-72(fp)
   a29e8:	100690fa 	slli	r3,r2,3
   a29ec:	e0bffc17 	ldw	r2,-16(fp)
   a29f0:	1885883a 	add	r2,r3,r2
   a29f4:	e0bff215 	stw	r2,-56(fp)
                     for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a29f8:	e03ff315 	stw	zero,-52(fp)
   a29fc:	00001a06 	br	a2a68 <tty_print+0xfc>
                     alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
   a2a00:	e0bff017 	ldw	r2,-64(fp)
   a2a04:	1000020e 	bge	r2,zero,a2a10 <tty_print+0xa4>
   a2a08:	e0bfff17 	ldw	r2,-4(fp)
   a2a0c:	00000106 	br	a2a14 <tty_print+0xa8>
   a2a10:	e0800217 	ldw	r2,8(fp)
   a2a14:	e0bffa15 	stw	r2,-24(fp)
                     write_pixel(prx,pry,dotcolor);
   a2a18:	01405004 	movi	r5,320
   a2a1c:	e13fef17 	ldw	r4,-68(fp)
   a2a20:	00a1acc0 	call	a1acc <__mulsi3>
   a2a24:	1007883a 	mov	r3,r2
   a2a28:	e0bff217 	ldw	r2,-56(fp)
   a2a2c:	1885883a 	add	r2,r3,r2
   a2a30:	1085883a 	add	r2,r2,r2
   a2a34:	1085883a 	add	r2,r2,r2
   a2a38:	1007883a 	mov	r3,r2
   a2a3c:	e0bffa17 	ldw	r2,-24(fp)
   a2a40:	18800035 	stwio	r2,0(r3)
                     dot = dot<<1;
   a2a44:	e0bff017 	ldw	r2,-64(fp)
   a2a48:	1085883a 	add	r2,r2,r2
   a2a4c:	e0bff015 	stw	r2,-64(fp)
                     prx++;
   a2a50:	e0bff217 	ldw	r2,-56(fp)
   a2a54:	10800044 	addi	r2,r2,1
   a2a58:	e0bff215 	stw	r2,-56(fp)
         alt_u32 pry = y_start ;
         alt_u32 half_tkn = upper_char_line(tkn-0x20);
         alt_u32 dot =  half_tkn;
             for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
                 alt_u32 prx = x_start +i*8;
                     for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2a5c:	e0bff317 	ldw	r2,-52(fp)
   a2a60:	10800044 	addi	r2,r2,1
   a2a64:	e0bff315 	stw	r2,-52(fp)
   a2a68:	e0bff317 	ldw	r2,-52(fp)
   a2a6c:	10800230 	cmpltui	r2,r2,8
   a2a70:	103fe31e 	bne	r2,zero,a2a00 <__alt_data_end+0xfffe2a00>
                     alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
                     write_pixel(prx,pry,dotcolor);
                     dot = dot<<1;
                     prx++;
                 }
                 pry++;
   a2a74:	e0bfef17 	ldw	r2,-68(fp)
   a2a78:	10800044 	addi	r2,r2,1
   a2a7c:	e0bfef15 	stw	r2,-68(fp)
     for(alt_u32 i=0;i<n;i++){ // antal tecken
         alt_u8 tkn = *tpek;
         alt_u32 pry = y_start ;
         alt_u32 half_tkn = upper_char_line(tkn-0x20);
         alt_u32 dot =  half_tkn;
             for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2a80:	e0bff117 	ldw	r2,-60(fp)
   a2a84:	10800044 	addi	r2,r2,1
   a2a88:	e0bff115 	stw	r2,-60(fp)
   a2a8c:	e0bff117 	ldw	r2,-60(fp)
   a2a90:	10800130 	cmpltui	r2,r2,4
   a2a94:	103fd31e 	bne	r2,zero,a29e4 <__alt_data_end+0xfffe29e4>
                     prx++;
                 }
                 pry++;
             }
            // nederdel
             half_tkn = lower_char_line(tkn-0x20);
   a2a98:	e0bff803 	ldbu	r2,-32(fp)
   a2a9c:	10bff804 	addi	r2,r2,-32
   a2aa0:	10803fcc 	andi	r2,r2,255
   a2aa4:	1009883a 	mov	r4,r2
   a2aa8:	00a4a380 	call	a4a38 <lower_char_line>
   a2aac:	e0bff915 	stw	r2,-28(fp)
              dot =  half_tkn;  // p/av frg  // 0x80000000 &
   a2ab0:	e0bff917 	ldw	r2,-28(fp)
   a2ab4:	e0bff015 	stw	r2,-64(fp)
                 for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2ab8:	e03ff415 	stw	zero,-48(fp)
   a2abc:	00002a06 	br	a2b68 <tty_print+0x1fc>
                     alt_u32 prx = x_start +i*8;
   a2ac0:	e0bfee17 	ldw	r2,-72(fp)
   a2ac4:	100690fa 	slli	r3,r2,3
   a2ac8:	e0bffc17 	ldw	r2,-16(fp)
   a2acc:	1885883a 	add	r2,r3,r2
   a2ad0:	e0bff515 	stw	r2,-44(fp)
                         for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2ad4:	e03ff615 	stw	zero,-40(fp)
   a2ad8:	00001a06 	br	a2b44 <tty_print+0x1d8>
                         alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
   a2adc:	e0bff017 	ldw	r2,-64(fp)
   a2ae0:	1000020e 	bge	r2,zero,a2aec <tty_print+0x180>
   a2ae4:	e0bfff17 	ldw	r2,-4(fp)
   a2ae8:	00000106 	br	a2af0 <tty_print+0x184>
   a2aec:	e0800217 	ldw	r2,8(fp)
   a2af0:	e0bffb15 	stw	r2,-20(fp)
                         write_pixel(prx,pry,dotcolor);
   a2af4:	01405004 	movi	r5,320
   a2af8:	e13fef17 	ldw	r4,-68(fp)
   a2afc:	00a1acc0 	call	a1acc <__mulsi3>
   a2b00:	1007883a 	mov	r3,r2
   a2b04:	e0bff517 	ldw	r2,-44(fp)
   a2b08:	1885883a 	add	r2,r3,r2
   a2b0c:	1085883a 	add	r2,r2,r2
   a2b10:	1085883a 	add	r2,r2,r2
   a2b14:	1007883a 	mov	r3,r2
   a2b18:	e0bffb17 	ldw	r2,-20(fp)
   a2b1c:	18800035 	stwio	r2,0(r3)
                         dot = dot<<1;
   a2b20:	e0bff017 	ldw	r2,-64(fp)
   a2b24:	1085883a 	add	r2,r2,r2
   a2b28:	e0bff015 	stw	r2,-64(fp)
                         prx++;
   a2b2c:	e0bff517 	ldw	r2,-44(fp)
   a2b30:	10800044 	addi	r2,r2,1
   a2b34:	e0bff515 	stw	r2,-44(fp)
            // nederdel
             half_tkn = lower_char_line(tkn-0x20);
              dot =  half_tkn;  // p/av frg  // 0x80000000 &
                 for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
                     alt_u32 prx = x_start +i*8;
                         for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2b38:	e0bff617 	ldw	r2,-40(fp)
   a2b3c:	10800044 	addi	r2,r2,1
   a2b40:	e0bff615 	stw	r2,-40(fp)
   a2b44:	e0bff617 	ldw	r2,-40(fp)
   a2b48:	10800230 	cmpltui	r2,r2,8
   a2b4c:	103fe31e 	bne	r2,zero,a2adc <__alt_data_end+0xfffe2adc>
                         alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
                         write_pixel(prx,pry,dotcolor);
                         dot = dot<<1;
                         prx++;
                     }
                     pry++;
   a2b50:	e0bfef17 	ldw	r2,-68(fp)
   a2b54:	10800044 	addi	r2,r2,1
   a2b58:	e0bfef15 	stw	r2,-68(fp)
                 pry++;
             }
            // nederdel
             half_tkn = lower_char_line(tkn-0x20);
              dot =  half_tkn;  // p/av frg  // 0x80000000 &
                 for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2b5c:	e0bff417 	ldw	r2,-48(fp)
   a2b60:	10800044 	addi	r2,r2,1
   a2b64:	e0bff415 	stw	r2,-48(fp)
   a2b68:	e0bff417 	ldw	r2,-48(fp)
   a2b6c:	10800130 	cmpltui	r2,r2,4
   a2b70:	103fd31e 	bne	r2,zero,a2ac0 <__alt_data_end+0xfffe2ac0>
                         dot = dot<<1;
                         prx++;
                     }
                     pry++;
                 }
         tpek ++;
   a2b74:	e0bfed17 	ldw	r2,-76(fp)
   a2b78:	10800044 	addi	r2,r2,1
   a2b7c:	e0bfed15 	stw	r2,-76(fp)

 void tty_print(alt_32 x_start, alt_32 y_start, alt_8 *tty_string,alt_32 color, alt_u32 BGcolor){
     alt_u8 *tpek;
     alt_u32 n = strlen(tty_string);
     tpek = tty_string;
     for(alt_u32 i=0;i<n;i++){ // antal tecken
   a2b80:	e0bfee17 	ldw	r2,-72(fp)
   a2b84:	10800044 	addi	r2,r2,1
   a2b88:	e0bfee15 	stw	r2,-72(fp)
   a2b8c:	e0ffee17 	ldw	r3,-72(fp)
   a2b90:	e0bff717 	ldw	r2,-36(fp)
   a2b94:	18bf8436 	bltu	r3,r2,a29a8 <__alt_data_end+0xfffe29a8>
                     }
                     pry++;
                 }
         tpek ++;
     }
 };
   a2b98:	0001883a 	nop
   a2b9c:	e037883a 	mov	sp,fp
   a2ba0:	dfc00117 	ldw	ra,4(sp)
   a2ba4:	df000017 	ldw	fp,0(sp)
   a2ba8:	dec00204 	addi	sp,sp,8
   a2bac:	f800283a 	ret

000a2bb0 <char_print>:


 void char_print(alt_32 x_start, alt_32 y_start, alt_u8 tty_char,alt_32 color, alt_u32 BGcolor){
   a2bb0:	deffef04 	addi	sp,sp,-68
   a2bb4:	dfc01015 	stw	ra,64(sp)
   a2bb8:	df000f15 	stw	fp,60(sp)
   a2bbc:	df000f04 	addi	fp,sp,60
   a2bc0:	e13ffc15 	stw	r4,-16(fp)
   a2bc4:	e17ffd15 	stw	r5,-12(fp)
   a2bc8:	3005883a 	mov	r2,r6
   a2bcc:	e1ffff15 	stw	r7,-4(fp)
   a2bd0:	e0bffe05 	stb	r2,-8(fp)
     alt_u8 tkn = tty_char;
   a2bd4:	e0bffe03 	ldbu	r2,-8(fp)
   a2bd8:	e0bff905 	stb	r2,-28(fp)
         alt_u32 pry = y_start ;
   a2bdc:	e0bffd17 	ldw	r2,-12(fp)
   a2be0:	e0bff115 	stw	r2,-60(fp)
         alt_u32 dot = upper_char_line(tkn-0x20);
   a2be4:	e0bff903 	ldbu	r2,-28(fp)
   a2be8:	10bff804 	addi	r2,r2,-32
   a2bec:	10803fcc 	andi	r2,r2,255
   a2bf0:	1009883a 	mov	r4,r2
   a2bf4:	00a49f80 	call	a49f8 <upper_char_line>
   a2bf8:	e0bff215 	stw	r2,-56(fp)
             for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2bfc:	e03ff315 	stw	zero,-52(fp)
   a2c00:	00002706 	br	a2ca0 <char_print+0xf0>
                 alt_u32 prx = x_start;
   a2c04:	e0bffc17 	ldw	r2,-16(fp)
   a2c08:	e0bff415 	stw	r2,-48(fp)
                 for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2c0c:	e03ff515 	stw	zero,-44(fp)
   a2c10:	00001a06 	br	a2c7c <char_print+0xcc>
                     alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
   a2c14:	e0bff217 	ldw	r2,-56(fp)
   a2c18:	1000020e 	bge	r2,zero,a2c24 <char_print+0x74>
   a2c1c:	e0bfff17 	ldw	r2,-4(fp)
   a2c20:	00000106 	br	a2c28 <char_print+0x78>
   a2c24:	e0800217 	ldw	r2,8(fp)
   a2c28:	e0bffa15 	stw	r2,-24(fp)
                     write_pixel(prx,pry,dotcolor);
   a2c2c:	01405004 	movi	r5,320
   a2c30:	e13ff117 	ldw	r4,-60(fp)
   a2c34:	00a1acc0 	call	a1acc <__mulsi3>
   a2c38:	1007883a 	mov	r3,r2
   a2c3c:	e0bff417 	ldw	r2,-48(fp)
   a2c40:	1885883a 	add	r2,r3,r2
   a2c44:	1085883a 	add	r2,r2,r2
   a2c48:	1085883a 	add	r2,r2,r2
   a2c4c:	1007883a 	mov	r3,r2
   a2c50:	e0bffa17 	ldw	r2,-24(fp)
   a2c54:	18800035 	stwio	r2,0(r3)
                     dot = dot<<1;
   a2c58:	e0bff217 	ldw	r2,-56(fp)
   a2c5c:	1085883a 	add	r2,r2,r2
   a2c60:	e0bff215 	stw	r2,-56(fp)
                     prx++;
   a2c64:	e0bff417 	ldw	r2,-48(fp)
   a2c68:	10800044 	addi	r2,r2,1
   a2c6c:	e0bff415 	stw	r2,-48(fp)
     alt_u8 tkn = tty_char;
         alt_u32 pry = y_start ;
         alt_u32 dot = upper_char_line(tkn-0x20);
             for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
                 alt_u32 prx = x_start;
                 for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2c70:	e0bff517 	ldw	r2,-44(fp)
   a2c74:	10800044 	addi	r2,r2,1
   a2c78:	e0bff515 	stw	r2,-44(fp)
   a2c7c:	e0bff517 	ldw	r2,-44(fp)
   a2c80:	10800230 	cmpltui	r2,r2,8
   a2c84:	103fe31e 	bne	r2,zero,a2c14 <__alt_data_end+0xfffe2c14>
                     alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
                     write_pixel(prx,pry,dotcolor);
                     dot = dot<<1;
                     prx++;
                 }
                 pry++;
   a2c88:	e0bff117 	ldw	r2,-60(fp)
   a2c8c:	10800044 	addi	r2,r2,1
   a2c90:	e0bff115 	stw	r2,-60(fp)

 void char_print(alt_32 x_start, alt_32 y_start, alt_u8 tty_char,alt_32 color, alt_u32 BGcolor){
     alt_u8 tkn = tty_char;
         alt_u32 pry = y_start ;
         alt_u32 dot = upper_char_line(tkn-0x20);
             for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2c94:	e0bff317 	ldw	r2,-52(fp)
   a2c98:	10800044 	addi	r2,r2,1
   a2c9c:	e0bff315 	stw	r2,-52(fp)
   a2ca0:	e0bff317 	ldw	r2,-52(fp)
   a2ca4:	10800130 	cmpltui	r2,r2,4
   a2ca8:	103fd61e 	bne	r2,zero,a2c04 <__alt_data_end+0xfffe2c04>
                     prx++;
                 }
                 pry++;
             }
            // nederdel
             dot = lower_char_line(tkn-0x20);
   a2cac:	e0bff903 	ldbu	r2,-28(fp)
   a2cb0:	10bff804 	addi	r2,r2,-32
   a2cb4:	10803fcc 	andi	r2,r2,255
   a2cb8:	1009883a 	mov	r4,r2
   a2cbc:	00a4a380 	call	a4a38 <lower_char_line>
   a2cc0:	e0bff215 	stw	r2,-56(fp)
                 for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2cc4:	e03ff615 	stw	zero,-40(fp)
   a2cc8:	00002706 	br	a2d68 <char_print+0x1b8>
                     alt_u32 prx = x_start;
   a2ccc:	e0bffc17 	ldw	r2,-16(fp)
   a2cd0:	e0bff715 	stw	r2,-36(fp)
                     for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2cd4:	e03ff815 	stw	zero,-32(fp)
   a2cd8:	00001a06 	br	a2d44 <char_print+0x194>
                         alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
   a2cdc:	e0bff217 	ldw	r2,-56(fp)
   a2ce0:	1000020e 	bge	r2,zero,a2cec <char_print+0x13c>
   a2ce4:	e0bfff17 	ldw	r2,-4(fp)
   a2ce8:	00000106 	br	a2cf0 <char_print+0x140>
   a2cec:	e0800217 	ldw	r2,8(fp)
   a2cf0:	e0bffb15 	stw	r2,-20(fp)
                         write_pixel(prx,pry,dotcolor);
   a2cf4:	01405004 	movi	r5,320
   a2cf8:	e13ff117 	ldw	r4,-60(fp)
   a2cfc:	00a1acc0 	call	a1acc <__mulsi3>
   a2d00:	1007883a 	mov	r3,r2
   a2d04:	e0bff717 	ldw	r2,-36(fp)
   a2d08:	1885883a 	add	r2,r3,r2
   a2d0c:	1085883a 	add	r2,r2,r2
   a2d10:	1085883a 	add	r2,r2,r2
   a2d14:	1007883a 	mov	r3,r2
   a2d18:	e0bffb17 	ldw	r2,-20(fp)
   a2d1c:	18800035 	stwio	r2,0(r3)
                         dot = dot<<1;
   a2d20:	e0bff217 	ldw	r2,-56(fp)
   a2d24:	1085883a 	add	r2,r2,r2
   a2d28:	e0bff215 	stw	r2,-56(fp)
                         prx++;
   a2d2c:	e0bff717 	ldw	r2,-36(fp)
   a2d30:	10800044 	addi	r2,r2,1
   a2d34:	e0bff715 	stw	r2,-36(fp)
             }
            // nederdel
             dot = lower_char_line(tkn-0x20);
                 for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
                     alt_u32 prx = x_start;
                     for(alt_u32 jj=0;jj<8;jj++){ // pixlar p rad (8)
   a2d38:	e0bff817 	ldw	r2,-32(fp)
   a2d3c:	10800044 	addi	r2,r2,1
   a2d40:	e0bff815 	stw	r2,-32(fp)
   a2d44:	e0bff817 	ldw	r2,-32(fp)
   a2d48:	10800230 	cmpltui	r2,r2,8
   a2d4c:	103fe31e 	bne	r2,zero,a2cdc <__alt_data_end+0xfffe2cdc>
                         alt_u32 dotcolor = (0x80000000 &dot)?color:BGcolor;
                         write_pixel(prx,pry,dotcolor);
                         dot = dot<<1;
                         prx++;
                     }
                     pry++;
   a2d50:	e0bff117 	ldw	r2,-60(fp)
   a2d54:	10800044 	addi	r2,r2,1
   a2d58:	e0bff115 	stw	r2,-60(fp)
                 }
                 pry++;
             }
            // nederdel
             dot = lower_char_line(tkn-0x20);
                 for(alt_u32 ii=0;ii<4;ii++){ // rader per  tecken
   a2d5c:	e0bff617 	ldw	r2,-40(fp)
   a2d60:	10800044 	addi	r2,r2,1
   a2d64:	e0bff615 	stw	r2,-40(fp)
   a2d68:	e0bff617 	ldw	r2,-40(fp)
   a2d6c:	10800130 	cmpltui	r2,r2,4
   a2d70:	103fd61e 	bne	r2,zero,a2ccc <__alt_data_end+0xfffe2ccc>
                         dot = dot<<1;
                         prx++;
                     }
                     pry++;
                 }
 };
   a2d74:	0001883a 	nop
   a2d78:	e037883a 	mov	sp,fp
   a2d7c:	dfc00117 	ldw	ra,4(sp)
   a2d80:	df000017 	ldw	fp,0(sp)
   a2d84:	dec00204 	addi	sp,sp,8
   a2d88:	f800283a 	ret

000a2d8c <int_print>:
Bakgrundsfrg: 0x000 (svart)
*/

void int_print(alt_32 x_start, alt_32 y_start, int data, int data_l,
alt_32 color, alt_u32 BGcolor) 
{
   a2d8c:	defff504 	addi	sp,sp,-44
   a2d90:	dfc00a15 	stw	ra,40(sp)
   a2d94:	df000915 	stw	fp,36(sp)
   a2d98:	dc000815 	stw	r16,32(sp)
   a2d9c:	df000904 	addi	fp,sp,36
   a2da0:	e13ffb15 	stw	r4,-20(fp)
   a2da4:	e17ffc15 	stw	r5,-16(fp)
   a2da8:	e1bffd15 	stw	r6,-12(fp)
   a2dac:	e1fffe15 	stw	r7,-8(fp)
int i = 0, j = 1;
   a2db0:	e03ff815 	stw	zero,-32(fp)
   a2db4:	00800044 	movi	r2,1
   a2db8:	e0bff915 	stw	r2,-28(fp)
alt_32 x = 0;
   a2dbc:	e03ffa15 	stw	zero,-24(fp)
if (data < 0) {
   a2dc0:	e0bffd17 	ldw	r2,-12(fp)
   a2dc4:	10000b0e 	bge	r2,zero,a2df4 <int_print+0x68>
char_print(x_start, y_start, '-', color, BGcolor);
   a2dc8:	e0800317 	ldw	r2,12(fp)
   a2dcc:	d8800015 	stw	r2,0(sp)
   a2dd0:	e1c00217 	ldw	r7,8(fp)
   a2dd4:	01800b44 	movi	r6,45
   a2dd8:	e17ffc17 	ldw	r5,-16(fp)
   a2ddc:	e13ffb17 	ldw	r4,-20(fp)
   a2de0:	00a2bb00 	call	a2bb0 <char_print>
data = -data;
   a2de4:	e0bffd17 	ldw	r2,-12(fp)
   a2de8:	0085c83a 	sub	r2,zero,r2
   a2dec:	e0bffd15 	stw	r2,-12(fp)
   a2df0:	00000706 	br	a2e10 <int_print+0x84>
} else {
char_print(x_start, y_start, '+', color, BGcolor);
   a2df4:	e0800317 	ldw	r2,12(fp)
   a2df8:	d8800015 	stw	r2,0(sp)
   a2dfc:	e1c00217 	ldw	r7,8(fp)
   a2e00:	01800ac4 	movi	r6,43
   a2e04:	e17ffc17 	ldw	r5,-16(fp)
   a2e08:	e13ffb17 	ldw	r4,-20(fp)
   a2e0c:	00a2bb00 	call	a2bb0 <char_print>
}
for (i = 0; i < data_l; i++) {
   a2e10:	e03ff815 	stw	zero,-32(fp)
   a2e14:	00002106 	br	a2e9c <int_print+0x110>
char_print(x_start + 10 * data_l - x, y_start, data / j % 10 + 48,
   a2e18:	01400284 	movi	r5,10
   a2e1c:	e13ffe17 	ldw	r4,-8(fp)
   a2e20:	00a1acc0 	call	a1acc <__mulsi3>
   a2e24:	1007883a 	mov	r3,r2
   a2e28:	e0bffb17 	ldw	r2,-20(fp)
   a2e2c:	1887883a 	add	r3,r3,r2
   a2e30:	e0bffa17 	ldw	r2,-24(fp)
   a2e34:	18a1c83a 	sub	r16,r3,r2
   a2e38:	e17ff917 	ldw	r5,-28(fp)
   a2e3c:	e13ffd17 	ldw	r4,-12(fp)
   a2e40:	00a111c0 	call	a111c <__divsi3>
   a2e44:	01400284 	movi	r5,10
   a2e48:	1009883a 	mov	r4,r2
   a2e4c:	00a11a00 	call	a11a0 <__modsi3>
   a2e50:	10800c04 	addi	r2,r2,48
   a2e54:	10c03fcc 	andi	r3,r2,255
   a2e58:	e0800317 	ldw	r2,12(fp)
   a2e5c:	d8800015 	stw	r2,0(sp)
   a2e60:	e1c00217 	ldw	r7,8(fp)
   a2e64:	180d883a 	mov	r6,r3
   a2e68:	e17ffc17 	ldw	r5,-16(fp)
   a2e6c:	8009883a 	mov	r4,r16
   a2e70:	00a2bb00 	call	a2bb0 <char_print>
color, BGcolor);
j *= 10;
   a2e74:	01400284 	movi	r5,10
   a2e78:	e13ff917 	ldw	r4,-28(fp)
   a2e7c:	00a1acc0 	call	a1acc <__mulsi3>
   a2e80:	e0bff915 	stw	r2,-28(fp)
x += 10;
   a2e84:	e0bffa17 	ldw	r2,-24(fp)
   a2e88:	10800284 	addi	r2,r2,10
   a2e8c:	e0bffa15 	stw	r2,-24(fp)
char_print(x_start, y_start, '-', color, BGcolor);
data = -data;
} else {
char_print(x_start, y_start, '+', color, BGcolor);
}
for (i = 0; i < data_l; i++) {
   a2e90:	e0bff817 	ldw	r2,-32(fp)
   a2e94:	10800044 	addi	r2,r2,1
   a2e98:	e0bff815 	stw	r2,-32(fp)
   a2e9c:	e0fff817 	ldw	r3,-32(fp)
   a2ea0:	e0bffe17 	ldw	r2,-8(fp)
   a2ea4:	18bfdc16 	blt	r3,r2,a2e18 <__alt_data_end+0xfffe2e18>
char_print(x_start + 10 * data_l - x, y_start, data / j % 10 + 48,
color, BGcolor);
j *= 10;
x += 10;
}
}
   a2ea8:	0001883a 	nop
   a2eac:	e6ffff04 	addi	sp,fp,-4
   a2eb0:	dfc00217 	ldw	ra,8(sp)
   a2eb4:	df000117 	ldw	fp,4(sp)
   a2eb8:	dc000017 	ldw	r16,0(sp)
   a2ebc:	dec00304 	addi	sp,sp,12
   a2ec0:	f800283a 	ret

000a2ec4 <init_Sierra_interrupt>:
/*
 *  Register Sierra HW IRQ with NiosII ISR (HW_CTX_SWTICH in csw.S)
 */
/* #ifdef SIERRA_RTOS_BASE */
static void init_Sierra_interrupt()
{
   a2ec4:	defffe04 	addi	sp,sp,-8
   a2ec8:	dfc00115 	stw	ra,4(sp)
   a2ecc:	df000015 	stw	fp,0(sp)
   a2ed0:	d839883a 	mov	fp,sp
 // int ret=0xffffffff;
  if (alt_irq_register( SIERRA_RTOS_IRQ, NULL, HW_CTX_SWITCH )) printf("error registration Sierra irq");
   a2ed4:	018002b4 	movhi	r6,10
   a2ed8:	31929e04 	addi	r6,r6,19064
   a2edc:	000b883a 	mov	r5,zero
   a2ee0:	0009883a 	mov	r4,zero
   a2ee4:	00a454c0 	call	a454c <alt_irq_register>
   a2ee8:	10000326 	beq	r2,zero,a2ef8 <init_Sierra_interrupt+0x34>
   a2eec:	010002b4 	movhi	r4,10
   a2ef0:	21142e04 	addi	r4,r4,20664
   a2ef4:	00a130c0 	call	a130c <printf>
 
}
   a2ef8:	0001883a 	nop
   a2efc:	e037883a 	mov	sp,fp
   a2f00:	dfc00117 	ldw	ra,4(sp)
   a2f04:	df000017 	ldw	fp,0(sp)
   a2f08:	dec00204 	addi	sp,sp,8
   a2f0c:	f800283a 	ret

000a2f10 <sierra_SW_driver_version>:
  Arguments   : none

  Return      : visions number
-----------------------------------------------------------------------------*/
unsigned int sierra_SW_driver_version(void)
{
   a2f10:	defffe04 	addi	sp,sp,-8
   a2f14:	df000115 	stw	fp,4(sp)
   a2f18:	df000104 	addi	fp,sp,4
  unsigned int svar = 0;
   a2f1c:	e03fff15 	stw	zero,-4(fp)
  svar = C_Sierra_SW_driver_version;
   a2f20:	008000b4 	movhi	r2,2
   a2f24:	10a1f6c4 	addi	r2,r2,-30757
   a2f28:	e0bfff15 	stw	r2,-4(fp)
return svar;
   a2f2c:	e0bfff17 	ldw	r2,-4(fp)
  }
   a2f30:	e037883a 	mov	sp,fp
   a2f34:	df000017 	ldw	fp,0(sp)
   a2f38:	dec00104 	addi	sp,sp,4
   a2f3c:	f800283a 	ret

000a2f40 <sierra_HW_version>:
  Arguments   : none

  Return      : visions number
-----------------------------------------------------------------------------*/
unsigned int sierra_HW_version(void)
{
   a2f40:	defffe04 	addi	sp,sp,-8
   a2f44:	df000115 	stw	fp,4(sp)
   a2f48:	df000104 	addi	fp,sp,4
  unsigned int svar = 0;
   a2f4c:	e03fff15 	stw	zero,-4(fp)
  svar = M_Sierra_HW_Version_reg;
   a2f50:	00800334 	movhi	r2,12
   a2f54:	10840004 	addi	r2,r2,4096
   a2f58:	10800037 	ldwio	r2,0(r2)
   a2f5c:	e0bfff15 	stw	r2,-4(fp)
return svar;
   a2f60:	e0bfff17 	ldw	r2,-4(fp)
  }
   a2f64:	e037883a 	mov	sp,fp
   a2f68:	df000017 	ldw	fp,0(sp)
   a2f6c:	dec00104 	addi	sp,sp,4
   a2f70:	f800283a 	ret

000a2f74 <SierraTime_base_reg>:
  Arguments   : none

  Return      : none
-----------------------------------------------------------------------------*/
unsigned int SierraTime_base_reg(void)
{
   a2f74:	defffe04 	addi	sp,sp,-8
   a2f78:	df000115 	stw	fp,4(sp)
   a2f7c:	df000104 	addi	fp,sp,4
  unsigned int svar = 0;
   a2f80:	e03fff15 	stw	zero,-4(fp)
  svar = M_RD_SierraTime_base_reg;
   a2f84:	00800334 	movhi	r2,12
   a2f88:	10840404 	addi	r2,r2,4112
   a2f8c:	10800037 	ldwio	r2,0(r2)
   a2f90:	e0bfff15 	stw	r2,-4(fp)
return svar;
   a2f94:	e0bfff17 	ldw	r2,-4(fp)
}
   a2f98:	e037883a 	mov	sp,fp
   a2f9c:	df000017 	ldw	fp,0(sp)
   a2fa0:	dec00104 	addi	sp,sp,4
   a2fa4:	f800283a 	ret

000a2fa8 <set_timebase>:
              : Wanted tick time : 10us
              : Formula gives    : 10us x 100MHz / 1000 => 1(dec) or 1(hex)
              : --> set_timebase(0x1);
-----------------------------------------------------------------------------*/
void set_timebase (unsigned int hex)
{
   a2fa8:	defffe04 	addi	sp,sp,-8
   a2fac:	df000115 	stw	fp,4(sp)
   a2fb0:	df000104 	addi	fp,sp,4
   a2fb4:	e13fff15 	stw	r4,-4(fp)
M_IOWR_SierraTime_base_reg(hex);
   a2fb8:	e0ffff17 	ldw	r3,-4(fp)
   a2fbc:	00800334 	movhi	r2,12
   a2fc0:	10840404 	addi	r2,r2,4112
   a2fc4:	10c00035 	stwio	r3,0(r2)
}
   a2fc8:	0001883a 	nop
   a2fcc:	e037883a 	mov	sp,fp
   a2fd0:	df000017 	ldw	fp,0(sp)
   a2fd4:	dec00104 	addi	sp,sp,4
   a2fd8:	f800283a 	ret

000a2fdc <Sierra_Initiation_HW_and_SW>:
  Arguments   : none
  Return      : none

-----------------------------------------------------------------------------*/
void Sierra_Initiation_HW_and_SW(void)
{
   a2fdc:	defffc04 	addi	sp,sp,-16
   a2fe0:	dfc00315 	stw	ra,12(sp)
   a2fe4:	df000215 	stw	fp,8(sp)
   a2fe8:	dc000115 	stw	r16,4(sp)
   a2fec:	df000204 	addi	fp,sp,8
  int i;
  //SW reset of HW Sierran
  M_WD_SW_RESET_REGISTER(0x15);
   a2ff0:	00c00544 	movi	r3,21
   a2ff4:	00800334 	movhi	r2,12
   a2ff8:	10841804 	addi	r2,r2,4192
   a2ffc:	10c00035 	stwio	r3,0(r2)
  M_WD_SW_RESET_REGISTER(0x00);
   a3000:	0007883a 	mov	r3,zero
   a3004:	00800334 	movhi	r2,12
   a3008:	10841804 	addi	r2,r2,4192
   a300c:	10c00035 	stwio	r3,0(r2)
  
 /*Initialize TCBs*/
  for (i = 0; i < N_TASKS; TCB_LIST[i++].taskID = 0xff);
   a3010:	e03ffe15 	stw	zero,-8(fp)
   a3014:	00000b06 	br	a3044 <Sierra_Initiation_HW_and_SW+0x68>
   a3018:	e0bffe17 	ldw	r2,-8(fp)
   a301c:	10c00044 	addi	r3,r2,1
   a3020:	e0fffe15 	stw	r3,-8(fp)
   a3024:	040002b4 	movhi	r16,10
   a3028:	841aef04 	addi	r16,r16,27580
   a302c:	01402304 	movi	r5,140
   a3030:	1009883a 	mov	r4,r2
   a3034:	00a1acc0 	call	a1acc <__mulsi3>
   a3038:	8085883a 	add	r2,r16,r2
   a303c:	00c03fc4 	movi	r3,255
   a3040:	10c00015 	stw	r3,0(r2)
   a3044:	e0bffe17 	ldw	r2,-8(fp)
   a3048:	10800210 	cmplti	r2,r2,8
   a304c:	103ff21e 	bne	r2,zero,a3018 <__alt_data_end+0xfffe3018>
  current_tcb=NULL;
   a3050:	d020f215 	stw	zero,-31800(gp)
  
  /* Initiate Sierra hw irq for NiosII*/
    init_Sierra_interrupt();
   a3054:	00a2ec40 	call	a2ec4 <init_Sierra_interrupt>
}
   a3058:	0001883a 	nop
   a305c:	e6ffff04 	addi	sp,fp,-4
   a3060:	dfc00217 	ldw	ra,8(sp)
   a3064:	df000117 	ldw	fp,4(sp)
   a3068:	dc000017 	ldw	r16,0(sp)
   a306c:	dec00304 	addi	sp,sp,12
   a3070:	f800283a 	ret

000a3074 <get_next_task>:
  Arguments   : none
 
  Return      : none
-----------------------------------------------------------------------------*/
void get_next_task(void)
{
   a3074:	defffc04 	addi	sp,sp,-16
   a3078:	dfc00315 	stw	ra,12(sp)
   a307c:	df000215 	stw	fp,8(sp)
   a3080:	df000204 	addi	fp,sp,8
  statusB_union status;
  ctrl_union CPU_CTRL_reg;

  /* Ack. on TSW req */
  CPU_CTRL_reg.ctrl_t.tswoff_req = 0;
   a3084:	e0ffff17 	ldw	r3,-4(fp)
   a3088:	00bfff44 	movi	r2,-3
   a308c:	1884703a 	and	r2,r3,r2
   a3090:	e0bfff15 	stw	r2,-4(fp)
  CPU_CTRL_reg.ctrl_t.tsw_req_ack = 1;
   a3094:	e0bfff17 	ldw	r2,-4(fp)
   a3098:	10800054 	ori	r2,r2,1
   a309c:	e0bfff15 	stw	r2,-4(fp)
  IOWR_ALT_CTRL_REGISTER(CPU_CTRL_reg.ctrl_integer);
   a30a0:	e0ffff17 	ldw	r3,-4(fp)
   a30a4:	00800334 	movhi	r2,12
   a30a8:	10841404 	addi	r2,r2,4176
   a30ac:	10c00035 	stwio	r3,0(r2)
  
  do {
    //MB: status = CPUstatusB_reg;
  //  status = *CPUstatusB_reg;
      status.statusB_reg_integer = M_RD_Sierra_statusB_reg;
   a30b0:	00800334 	movhi	r2,12
   a30b4:	10840c04 	addi	r2,r2,4144
   a30b8:	10800037 	ldwio	r2,0(r2)
   a30bc:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusB_t.tsw_req_flag != 0);
   a30c0:	e0bffe17 	ldw	r2,-8(fp)
   a30c4:	1080004c 	andi	r2,r2,1
   a30c8:	103ff91e 	bne	r2,zero,a30b0 <__alt_data_end+0xfffe30b0>

  /* Get next task ID */
RUNNING_TASKID = constant_task_mask & status.statusB_t.running_taskID;
   a30cc:	e0bffe17 	ldw	r2,-8(fp)
   a30d0:	1004d07a 	srli	r2,r2,1
   a30d4:	1007883a 	mov	r3,r2
   a30d8:	00bfffc4 	movi	r2,-1
   a30dc:	1884703a 	and	r2,r3,r2
   a30e0:	108001cc 	andi	r2,r2,7
   a30e4:	d0a0f345 	stb	r2,-31795(gp)

//   printf(" get next task id, runing_taskid = %d\n", RUNNING_TASKID); /* testning */
  
  current_tcb = &TCB_LIST[RUNNING_TASKID];
   a30e8:	d0a0f343 	ldbu	r2,-31795(gp)
   a30ec:	10803fcc 	andi	r2,r2,255
   a30f0:	01402304 	movi	r5,140
   a30f4:	1009883a 	mov	r4,r2
   a30f8:	00a1acc0 	call	a1acc <__mulsi3>
   a30fc:	1007883a 	mov	r3,r2
   a3100:	008002b4 	movhi	r2,10
   a3104:	109aef04 	addi	r2,r2,27580
   a3108:	1885883a 	add	r2,r3,r2
   a310c:	d0a0f215 	stw	r2,-31800(gp)
 
  /* Nack on TSW req */
  CPU_CTRL_reg.ctrl_t.tsw_req_ack = 0;
   a3110:	e0ffff17 	ldw	r3,-4(fp)
   a3114:	00bfff84 	movi	r2,-2
   a3118:	1884703a 	and	r2,r3,r2
   a311c:	e0bfff15 	stw	r2,-4(fp)
  IOWR_ALT_CTRL_REGISTER(CPU_CTRL_reg.ctrl_integer);
   a3120:	e0ffff17 	ldw	r3,-4(fp)
   a3124:	00800334 	movhi	r2,12
   a3128:	10841404 	addi	r2,r2,4176
   a312c:	10c00035 	stwio	r3,0(r2)
}
   a3130:	0001883a 	nop
   a3134:	e037883a 	mov	sp,fp
   a3138:	dfc00117 	ldw	ra,4(sp)
   a313c:	df000017 	ldw	fp,0(sp)
   a3140:	dec00204 	addi	sp,sp,8
   a3144:	f800283a 	ret

000a3148 <tsw_on>:
  Arguments   : none

  Return      : none
-----------------------------------------------------------------------------*/
void tsw_on(void)
{
   a3148:	defffe04 	addi	sp,sp,-8
   a314c:	df000115 	stw	fp,4(sp)
   a3150:	df000104 	addi	fp,sp,4
  /* Current CPU control status */
  ctrl_union CPU_CTRL_reg;
 
  CPU_CTRL_reg.ctrl_t.tswoff_req = 0;
   a3154:	e0ffff17 	ldw	r3,-4(fp)
   a3158:	00bfff44 	movi	r2,-3
   a315c:	1884703a 	and	r2,r3,r2
   a3160:	e0bfff15 	stw	r2,-4(fp)
  CPU_CTRL_reg.ctrl_t.tsw_req_ack = 0;
   a3164:	e0ffff17 	ldw	r3,-4(fp)
   a3168:	00bfff84 	movi	r2,-2
   a316c:	1884703a 	and	r2,r3,r2
   a3170:	e0bfff15 	stw	r2,-4(fp)

IOWR_ALT_CTRL_REGISTER(CPU_CTRL_reg.ctrl_integer);
   a3174:	e0ffff17 	ldw	r3,-4(fp)
   a3178:	00800334 	movhi	r2,12
   a317c:	10841404 	addi	r2,r2,4176
   a3180:	10c00035 	stwio	r3,0(r2)
}
   a3184:	0001883a 	nop
   a3188:	e037883a 	mov	sp,fp
   a318c:	df000017 	ldw	fp,0(sp)
   a3190:	dec00104 	addi	sp,sp,4
   a3194:	f800283a 	ret

000a3198 <tsw_off>:
  Arguments   : none

  Return      : none
-----------------------------------------------------------------------------*/
void tsw_off(void)
{
   a3198:	defffe04 	addi	sp,sp,-8
   a319c:	df000115 	stw	fp,4(sp)
   a31a0:	df000104 	addi	fp,sp,4
  /* Current CPU control status */
  ctrl_union CPU_CTRL_reg;
  
  CPU_CTRL_reg.ctrl_t.tswoff_req = 1;
   a31a4:	e0bfff17 	ldw	r2,-4(fp)
   a31a8:	10800094 	ori	r2,r2,2
   a31ac:	e0bfff15 	stw	r2,-4(fp)
  CPU_CTRL_reg.ctrl_t.tsw_req_ack = 0;
   a31b0:	e0ffff17 	ldw	r3,-4(fp)
   a31b4:	00bfff84 	movi	r2,-2
   a31b8:	1884703a 	and	r2,r3,r2
   a31bc:	e0bfff15 	stw	r2,-4(fp)

  IOWR_ALT_CTRL_REGISTER(CPU_CTRL_reg.ctrl_integer);
   a31c0:	e0ffff17 	ldw	r3,-4(fp)
   a31c4:	00800334 	movhi	r2,12
   a31c8:	10841404 	addi	r2,r2,4176
   a31cc:	10c00035 	stwio	r3,0(r2)

}
   a31d0:	0001883a 	nop
   a31d4:	e037883a 	mov	sp,fp
   a31d8:	df000017 	ldw	fp,0(sp)
   a31dc:	dec00104 	addi	sp,sp,4
   a31e0:	f800283a 	ret

000a31e4 <get_new_task>:
                contextswitch is performed manually).
  Arguments   : none
  Return      : none
-----------------------------------------------------------------------------*/
void get_new_task(void)
{
   a31e4:	defffe04 	addi	sp,sp,-8
   a31e8:	dfc00115 	stw	ra,4(sp)
   a31ec:	df000015 	stw	fp,0(sp)
   a31f0:	d839883a 	mov	fp,sp
   /* New task to start is fetched from NEXT_TASKID */
  RUNNING_TASKID = NEXT_TASKID;
   a31f4:	d0a0f303 	ldbu	r2,-31796(gp)
   a31f8:	d0a0f345 	stb	r2,-31795(gp)
   /* Point to new tasks tcb */
  current_tcb = &TCB_LIST[RUNNING_TASKID];
   a31fc:	d0a0f343 	ldbu	r2,-31795(gp)
   a3200:	10803fcc 	andi	r2,r2,255
   a3204:	01402304 	movi	r5,140
   a3208:	1009883a 	mov	r4,r2
   a320c:	00a1acc0 	call	a1acc <__mulsi3>
   a3210:	1007883a 	mov	r3,r2
   a3214:	008002b4 	movhi	r2,10
   a3218:	109aef04 	addi	r2,r2,27580
   a321c:	1885883a 	add	r2,r3,r2
   a3220:	d0a0f215 	stw	r2,-31800(gp)
}
   a3224:	0001883a 	nop
   a3228:	e037883a 	mov	sp,fp
   a322c:	dfc00117 	ldw	ra,4(sp)
   a3230:	df000017 	ldw	fp,0(sp)
   a3234:	dec00204 	addi	sp,sp,8
   a3238:	f800283a 	ret

000a323c <irq_wait>:
  Arguments   : int irq     - irq level

  Return      : none
-----------------------------------------------------------------------------*/
void irq_wait(int IRQ_number)
{
   a323c:	defffb04 	addi	sp,sp,-20
   a3240:	dfc00415 	stw	ra,16(sp)
   a3244:	df000315 	stw	fp,12(sp)
   a3248:	df000304 	addi	fp,sp,12
   a324c:	e13fff15 	stw	r4,-4(fp)
  svc_t           svc;
  statusA_union   statusA;
  int             retval;

  tsw_off();
   a3250:	00a31980 	call	a3198 <tsw_off>
  svc.irq_wait_t.type =  sierra_irq_wait;
   a3254:	e0fffd17 	ldw	r3,-12(fp)
   a3258:	00810034 	movhi	r2,1024
   a325c:	10bfffc4 	addi	r2,r2,-1
   a3260:	1884703a 	and	r2,r3,r2
   a3264:	10890034 	orhi	r2,r2,9216
   a3268:	e0bffd15 	stw	r2,-12(fp)
  svc.irq_wait_t.irq_type =  IRQ_number;
   a326c:	e0bfff17 	ldw	r2,-4(fp)
   a3270:	100491ba 	slli	r2,r2,6
   a3274:	10803fcc 	andi	r2,r2,255
   a3278:	1080201c 	xori	r2,r2,128
   a327c:	10bfe004 	addi	r2,r2,-128
   a3280:	1005d1ba 	srai	r2,r2,6
   a3284:	10803fcc 	andi	r2,r2,255
   a3288:	108000cc 	andi	r2,r2,3
   a328c:	e13ffd17 	ldw	r4,-12(fp)
   a3290:	00ffff04 	movi	r3,-4
   a3294:	20c6703a 	and	r3,r4,r3
   a3298:	1884b03a 	or	r2,r3,r2
   a329c:	e0bffd15 	stw	r2,-12(fp)
  
  /* Start service call*/
  
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a32a0:	e0fffd17 	ldw	r3,-12(fp)
   a32a4:	00800334 	movhi	r2,12
   a32a8:	10841004 	addi	r2,r2,4160
   a32ac:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a32b0:	00800334 	movhi	r2,12
   a32b4:	10840804 	addi	r2,r2,4128
   a32b8:	10800037 	ldwio	r2,0(r2)
   a32bc:	e0bffe15 	stw	r2,-8(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a32c0:	e0bffe17 	ldw	r2,-8(fp)
   a32c4:	1080004c 	andi	r2,r2,1
   a32c8:	103ff91e 	bne	r2,zero,a32b0 <__alt_data_end+0xfffe32b0>
  
   NEXT_TASKID=constant_task_mask & statusA.statusA_t.svc_return;
   a32cc:	e0bffe17 	ldw	r2,-8(fp)
   a32d0:	1004d0ba 	srli	r2,r2,2
   a32d4:	108fffcc 	andi	r2,r2,16383
   a32d8:	108001cc 	andi	r2,r2,7
   a32dc:	d0a0f305 	stb	r2,-31796(gp)
//   printf("  NEXTTASK_ID_IRQ = %d\n", NEXT_TASKID); /* testning */
   tsw_on();
   a32e0:	00a31480 	call	a3148 <tsw_on>
   taskswitch; /* perform manual contextswitch */
   a32e4:	003b683a 	trap	0
}
   a32e8:	0001883a 	nop
   a32ec:	e037883a 	mov	sp,fp
   a32f0:	dfc00117 	ldw	ra,4(sp)
   a32f4:	df000017 	ldw	fp,0(sp)
   a32f8:	dec00204 	addi	sp,sp,8
   a32fc:	f800283a 	ret

000a3300 <sem_take>:
  Arguments   : int semid - Semaphore ID number

  Return      : none
-----------------------------------------------------------------------------*/
void sem_take(int semid)
{
   a3300:	defffb04 	addi	sp,sp,-20
   a3304:	df000415 	stw	fp,16(sp)
   a3308:	df000404 	addi	fp,sp,16
   a330c:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;
  int retval;
  
  svc.take_sem.type =  sierra_sem_take;
   a3310:	e0fffd17 	ldw	r3,-12(fp)
   a3314:	00810034 	movhi	r2,1024
   a3318:	10bfffc4 	addi	r2,r2,-1
   a331c:	1884703a 	and	r2,r3,r2
   a3320:	109c0034 	orhi	r2,r2,28672
   a3324:	e0bffd15 	stw	r2,-12(fp)
  svc.take_sem.semid =  semid;
   a3328:	e0bfff17 	ldw	r2,-4(fp)
   a332c:	1083ffcc 	andi	r2,r2,4095
   a3330:	10bfffcc 	andi	r2,r2,65535
   a3334:	1083ffcc 	andi	r2,r2,4095
   a3338:	e13ffd17 	ldw	r4,-12(fp)
   a333c:	00fc0004 	movi	r3,-4096
   a3340:	20c6703a 	and	r3,r4,r3
   a3344:	1884b03a 	or	r2,r3,r2
   a3348:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a334c:	e0fffd17 	ldw	r3,-12(fp)
   a3350:	00800334 	movhi	r2,12
   a3354:	10841004 	addi	r2,r2,4160
   a3358:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a335c:	00800334 	movhi	r2,12
   a3360:	10840804 	addi	r2,r2,4128
   a3364:	10800037 	ldwio	r2,0(r2)
   a3368:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a336c:	e0bffe17 	ldw	r2,-8(fp)
   a3370:	1080004c 	andi	r2,r2,1
   a3374:	103ff91e 	bne	r2,zero,a335c <__alt_data_end+0xfffe335c>

  retval=status.statusA_t.svc_return & 0x3f;
   a3378:	e0bffe17 	ldw	r2,-8(fp)
   a337c:	1004d0ba 	srli	r2,r2,2
   a3380:	108fffcc 	andi	r2,r2,16383
   a3384:	10bfffcc 	andi	r2,r2,65535
   a3388:	10800fcc 	andi	r2,r2,63
   a338c:	e0bffc15 	stw	r2,-16(fp)

  if (0 != (retval & 0x1)) { /*Task becomes blocked*/
   a3390:	e0bffc17 	ldw	r2,-16(fp)
   a3394:	1080004c 	andi	r2,r2,1
   a3398:	10000526 	beq	r2,zero,a33b0 <sem_take+0xb0>
    NEXT_TASKID = constant_task_mask & (retval >> 1);
   a339c:	e0bffc17 	ldw	r2,-16(fp)
   a33a0:	1005d07a 	srai	r2,r2,1
   a33a4:	108001cc 	andi	r2,r2,7
   a33a8:	d0a0f305 	stb	r2,-31796(gp)
    taskswitch; /* perform manual contextswitch */
   a33ac:	003b683a 	trap	0
  }

}
   a33b0:	0001883a 	nop
   a33b4:	e037883a 	mov	sp,fp
   a33b8:	df000017 	ldw	fp,0(sp)
   a33bc:	dec00104 	addi	sp,sp,4
   a33c0:	f800283a 	ret

000a33c4 <sem_release>:
  Arguments   : int semid - Semaphore ID number

  Return      : none
-----------------------------------------------------------------------------*/
void sem_release(int semid)
{
   a33c4:	defffc04 	addi	sp,sp,-16
   a33c8:	df000315 	stw	fp,12(sp)
   a33cc:	df000304 	addi	fp,sp,12
   a33d0:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union statusA;

  svc.release_sem.type =  sierra_sem_release;
   a33d4:	e0fffd17 	ldw	r3,-12(fp)
   a33d8:	00810034 	movhi	r2,1024
   a33dc:	10bfffc4 	addi	r2,r2,-1
   a33e0:	1884703a 	and	r2,r3,r2
   a33e4:	109d0034 	orhi	r2,r2,29696
   a33e8:	e0bffd15 	stw	r2,-12(fp)
  svc.release_sem.semid =  semid;
   a33ec:	e0bfff17 	ldw	r2,-4(fp)
   a33f0:	1083ffcc 	andi	r2,r2,4095
   a33f4:	10bfffcc 	andi	r2,r2,65535
   a33f8:	1083ffcc 	andi	r2,r2,4095
   a33fc:	e13ffd17 	ldw	r4,-12(fp)
   a3400:	00fc0004 	movi	r3,-4096
   a3404:	20c6703a 	and	r3,r4,r3
   a3408:	1884b03a 	or	r2,r3,r2
   a340c:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3410:	e0fffd17 	ldw	r3,-12(fp)
   a3414:	00800334 	movhi	r2,12
   a3418:	10841004 	addi	r2,r2,4160
   a341c:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3420:	00800334 	movhi	r2,12
   a3424:	10840804 	addi	r2,r2,4128
   a3428:	10800037 	ldwio	r2,0(r2)
   a342c:	e0bffe15 	stw	r2,-8(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a3430:	e0bffe17 	ldw	r2,-8(fp)
   a3434:	1080004c 	andi	r2,r2,1
   a3438:	103ff91e 	bne	r2,zero,a3420 <__alt_data_end+0xfffe3420>
}
   a343c:	0001883a 	nop
   a3440:	e037883a 	mov	sp,fp
   a3444:	df000017 	ldw	fp,0(sp)
   a3448:	dec00104 	addi	sp,sp,4
   a344c:	f800283a 	ret

000a3450 <sem_read>:
  Arguments   : int semid - Semaphore ID number

  Return      : Datastructure of type sem_info_t. 
-----------------------------------------------------------------------------*/
sem_info_t sem_read(int taskID)
{
   a3450:	defffa04 	addi	sp,sp,-24
   a3454:	df000515 	stw	fp,20(sp)
   a3458:	df000504 	addi	fp,sp,20
   a345c:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;
  unsigned char info;
  sem_info_t info_t;
  
  svc.read_sem.type =  sierra_sem_read;
   a3460:	e0fffb17 	ldw	r3,-20(fp)
   a3464:	00810034 	movhi	r2,1024
   a3468:	10bfffc4 	addi	r2,r2,-1
   a346c:	1884703a 	and	r2,r3,r2
   a3470:	10980034 	orhi	r2,r2,24576
   a3474:	e0bffb15 	stw	r2,-20(fp)
  svc.read_sem.taskID =  taskID;
   a3478:	e0bfff17 	ldw	r2,-4(fp)
   a347c:	1083ffcc 	andi	r2,r2,4095
   a3480:	10bfffcc 	andi	r2,r2,65535
   a3484:	1083ffcc 	andi	r2,r2,4095
   a3488:	e13ffb17 	ldw	r4,-20(fp)
   a348c:	00fc0004 	movi	r3,-4096
   a3490:	20c6703a 	and	r3,r4,r3
   a3494:	1884b03a 	or	r2,r3,r2
   a3498:	e0bffb15 	stw	r2,-20(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a349c:	e0fffb17 	ldw	r3,-20(fp)
   a34a0:	00800334 	movhi	r2,12
   a34a4:	10841004 	addi	r2,r2,4160
   a34a8:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a34ac:	00800334 	movhi	r2,12
   a34b0:	10840804 	addi	r2,r2,4128
   a34b4:	10800037 	ldwio	r2,0(r2)
   a34b8:	e0bffc15 	stw	r2,-16(fp)
  } while (status.statusA_t.svc_ack == 1);
   a34bc:	e0bffc17 	ldw	r2,-16(fp)
   a34c0:	1080004c 	andi	r2,r2,1
   a34c4:	103ff91e 	bne	r2,zero,a34ac <__alt_data_end+0xfffe34ac>

  info = status.statusA_t.svc_return & 0x7f;
   a34c8:	e0bffc17 	ldw	r2,-16(fp)
   a34cc:	1004d0ba 	srli	r2,r2,2
   a34d0:	108fffcc 	andi	r2,r2,16383
   a34d4:	10801fcc 	andi	r2,r2,127
   a34d8:	e0bffd05 	stb	r2,-12(fp)
  return *(sem_info_t *)&info;
   a34dc:	e0bffd04 	addi	r2,fp,-12
   a34e0:	10800017 	ldw	r2,0(r2)
}
   a34e4:	e037883a 	mov	sp,fp
   a34e8:	df000017 	ldw	fp,0(sp)
   a34ec:	dec00104 	addi	sp,sp,4
   a34f0:	f800283a 	ret

000a34f4 <flag_wait>:
  Arguments   : int flag_mask - flag bits

  Return      : none
-----------------------------------------------------------------------------*/
void flag_wait(int flag_mask)
{
   a34f4:	defffb04 	addi	sp,sp,-20
   a34f8:	df000415 	stw	fp,16(sp)
   a34fc:	df000404 	addi	fp,sp,16
   a3500:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;
  int retval;

  svc.flag_wait.type = sierra_flag_wait;
   a3504:	e0fffd17 	ldw	r3,-12(fp)
   a3508:	00810034 	movhi	r2,1024
   a350c:	10bfffc4 	addi	r2,r2,-1
   a3510:	1884703a 	and	r2,r3,r2
   a3514:	10990034 	orhi	r2,r2,25600
   a3518:	e0bffd15 	stw	r2,-12(fp)
  svc.flag_wait.flag_mask =  flag_mask;
   a351c:	e0bfff17 	ldw	r2,-4(fp)
   a3520:	1083ffcc 	andi	r2,r2,4095
   a3524:	10bfffcc 	andi	r2,r2,65535
   a3528:	1083ffcc 	andi	r2,r2,4095
   a352c:	e13ffd17 	ldw	r4,-12(fp)
   a3530:	00fc0004 	movi	r3,-4096
   a3534:	20c6703a 	and	r3,r4,r3
   a3538:	1884b03a 	or	r2,r3,r2
   a353c:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3540:	e0fffd17 	ldw	r3,-12(fp)
   a3544:	00800334 	movhi	r2,12
   a3548:	10841004 	addi	r2,r2,4160
   a354c:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3550:	00800334 	movhi	r2,12
   a3554:	10840804 	addi	r2,r2,4128
   a3558:	10800037 	ldwio	r2,0(r2)
   a355c:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a3560:	e0bffe17 	ldw	r2,-8(fp)
   a3564:	1080004c 	andi	r2,r2,1
   a3568:	103ff91e 	bne	r2,zero,a3550 <__alt_data_end+0xfffe3550>

  retval=status.statusA_t.svc_return & 0x3f;
   a356c:	e0bffe17 	ldw	r2,-8(fp)
   a3570:	1004d0ba 	srli	r2,r2,2
   a3574:	108fffcc 	andi	r2,r2,16383
   a3578:	10bfffcc 	andi	r2,r2,65535
   a357c:	10800fcc 	andi	r2,r2,63
   a3580:	e0bffc15 	stw	r2,-16(fp)

  if (0 != (retval & 0x1)) { /*Task becomes blocked*/
   a3584:	e0bffc17 	ldw	r2,-16(fp)
   a3588:	1080004c 	andi	r2,r2,1
   a358c:	10000526 	beq	r2,zero,a35a4 <flag_wait+0xb0>
    NEXT_TASKID = constant_task_mask & (retval >> 1);
   a3590:	e0bffc17 	ldw	r2,-16(fp)
   a3594:	1005d07a 	srai	r2,r2,1
   a3598:	108001cc 	andi	r2,r2,7
   a359c:	d0a0f305 	stb	r2,-31796(gp)
    taskswitch; /* perform manual contextswitch */
   a35a0:	003b683a 	trap	0
  }
}
   a35a4:	0001883a 	nop
   a35a8:	e037883a 	mov	sp,fp
   a35ac:	df000017 	ldw	fp,0(sp)
   a35b0:	dec00104 	addi	sp,sp,4
   a35b4:	f800283a 	ret

000a35b8 <flag_set>:
  Arguments   : int flag_mask - flagbits

  Return      : none
-----------------------------------------------------------------------------*/
void flag_set(int flag_mask)
{
   a35b8:	defffc04 	addi	sp,sp,-16
   a35bc:	df000315 	stw	fp,12(sp)
   a35c0:	df000304 	addi	fp,sp,12
   a35c4:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;

  svc.flag_set.type = sierra_flag_set;
   a35c8:	e0fffd17 	ldw	r3,-12(fp)
   a35cc:	00810034 	movhi	r2,1024
   a35d0:	10bfffc4 	addi	r2,r2,-1
   a35d4:	1884703a 	and	r2,r3,r2
   a35d8:	109a0034 	orhi	r2,r2,26624
   a35dc:	e0bffd15 	stw	r2,-12(fp)
  svc.flag_set.flag_mask =  flag_mask;
   a35e0:	e0bfff17 	ldw	r2,-4(fp)
   a35e4:	1083ffcc 	andi	r2,r2,4095
   a35e8:	10bfffcc 	andi	r2,r2,65535
   a35ec:	1083ffcc 	andi	r2,r2,4095
   a35f0:	e13ffd17 	ldw	r4,-12(fp)
   a35f4:	00fc0004 	movi	r3,-4096
   a35f8:	20c6703a 	and	r3,r4,r3
   a35fc:	1884b03a 	or	r2,r3,r2
   a3600:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3604:	e0fffd17 	ldw	r3,-12(fp)
   a3608:	00800334 	movhi	r2,12
   a360c:	10841004 	addi	r2,r2,4160
   a3610:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3614:	00800334 	movhi	r2,12
   a3618:	10840804 	addi	r2,r2,4128
   a361c:	10800037 	ldwio	r2,0(r2)
   a3620:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a3624:	e0bffe17 	ldw	r2,-8(fp)
   a3628:	1080004c 	andi	r2,r2,1
   a362c:	103ff91e 	bne	r2,zero,a3614 <__alt_data_end+0xfffe3614>
}
   a3630:	0001883a 	nop
   a3634:	e037883a 	mov	sp,fp
   a3638:	df000017 	ldw	fp,0(sp)
   a363c:	dec00104 	addi	sp,sp,4
   a3640:	f800283a 	ret

000a3644 <flag_clear>:
  Arguments   : int flag_mask - flagbits

  Return      : none
-----------------------------------------------------------------------------*/
void flag_clear(int flag_mask)
{
   a3644:	defffc04 	addi	sp,sp,-16
   a3648:	df000315 	stw	fp,12(sp)
   a364c:	df000304 	addi	fp,sp,12
   a3650:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;

  svc.flag_clear.type = sierra_flag_clear;
   a3654:	e0fffd17 	ldw	r3,-12(fp)
   a3658:	00810034 	movhi	r2,1024
   a365c:	10bfffc4 	addi	r2,r2,-1
   a3660:	1884703a 	and	r2,r3,r2
   a3664:	109b0034 	orhi	r2,r2,27648
   a3668:	e0bffd15 	stw	r2,-12(fp)
  svc.flag_clear.flag_mask =  flag_mask;
   a366c:	e0bfff17 	ldw	r2,-4(fp)
   a3670:	1083ffcc 	andi	r2,r2,4095
   a3674:	10bfffcc 	andi	r2,r2,65535
   a3678:	1083ffcc 	andi	r2,r2,4095
   a367c:	e13ffd17 	ldw	r4,-12(fp)
   a3680:	00fc0004 	movi	r3,-4096
   a3684:	20c6703a 	and	r3,r4,r3
   a3688:	1884b03a 	or	r2,r3,r2
   a368c:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3690:	e0fffd17 	ldw	r3,-12(fp)
   a3694:	00800334 	movhi	r2,12
   a3698:	10841004 	addi	r2,r2,4160
   a369c:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a36a0:	00800334 	movhi	r2,12
   a36a4:	10840804 	addi	r2,r2,4128
   a36a8:	10800037 	ldwio	r2,0(r2)
   a36ac:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a36b0:	e0bffe17 	ldw	r2,-8(fp)
   a36b4:	1080004c 	andi	r2,r2,1
   a36b8:	103ff91e 	bne	r2,zero,a36a0 <__alt_data_end+0xfffe36a0>
}
   a36bc:	0001883a 	nop
   a36c0:	e037883a 	mov	sp,fp
   a36c4:	df000017 	ldw	fp,0(sp)
   a36c8:	dec00104 	addi	sp,sp,4
   a36cc:	f800283a 	ret

000a36d0 <task_create>:
                   int priority,
                   int taskstate,
                   void (*taskptr)(void),
                   void *stackptr,
                   int stacksz)
{
   a36d0:	defff704 	addi	sp,sp,-36
   a36d4:	dfc00815 	stw	ra,32(sp)
   a36d8:	df000715 	stw	fp,28(sp)
   a36dc:	df000704 	addi	fp,sp,28
   a36e0:	e13ffc15 	stw	r4,-16(fp)
   a36e4:	e17ffd15 	stw	r5,-12(fp)
   a36e8:	e1bffe15 	stw	r6,-8(fp)
   a36ec:	e1ffff15 	stw	r7,-4(fp)
  tcb_t *newTask;
  svc_t svc;
  statusA_union status;

  newTask = &(TCB_LIST[taskID]);
   a36f0:	01402304 	movi	r5,140
   a36f4:	e13ffc17 	ldw	r4,-16(fp)
   a36f8:	00a1acc0 	call	a1acc <__mulsi3>
   a36fc:	1007883a 	mov	r3,r2
   a3700:	008002b4 	movhi	r2,10
   a3704:	109aef04 	addi	r2,r2,27580
   a3708:	1885883a 	add	r2,r3,r2
   a370c:	e0bff915 	stw	r2,-28(fp)

  /* Parameters to tcb*/
  newTask->taskID = taskID;
   a3710:	e0fffc17 	ldw	r3,-16(fp)
   a3714:	e0bff917 	ldw	r2,-28(fp)
   a3718:	10c00015 	stw	r3,0(r2)
  newTask->task = taskptr;
   a371c:	e0bff917 	ldw	r2,-28(fp)
   a3720:	e0ffff17 	ldw	r3,-4(fp)
   a3724:	10c00115 	stw	r3,4(r2)
  newTask->ea_reg = taskptr;  
   a3728:	e0ffff17 	ldw	r3,-4(fp)
   a372c:	e0bff917 	ldw	r2,-28(fp)
   a3730:	10c01c15 	stw	r3,112(r2)
  newTask->ra_reg = taskptr;
   a3734:	e0ffff17 	ldw	r3,-4(fp)
   a3738:	e0bff917 	ldw	r2,-28(fp)
   a373c:	10c01d15 	stw	r3,116(r2)
  newTask->stacktop = stackptr;
   a3740:	e0bff917 	ldw	r2,-28(fp)
   a3744:	e0c00217 	ldw	r3,8(fp)
   a3748:	10c01f15 	stw	r3,124(r2)
  /* Stack counts backwards, set pointer to highest address */
  newTask->stack = (unsigned int *) (stackptr + stacksz - sizeof(int));
   a374c:	e0800317 	ldw	r2,12(fp)
   a3750:	10bfff04 	addi	r2,r2,-4
   a3754:	e0c00217 	ldw	r3,8(fp)
   a3758:	1887883a 	add	r3,r3,r2
   a375c:	e0bff917 	ldw	r2,-28(fp)
   a3760:	10c01e15 	stw	r3,120(r2)
  newTask->stacksz = stacksz;
   a3764:	e0c00317 	ldw	r3,12(fp)
   a3768:	e0bff917 	ldw	r2,-28(fp)
   a376c:	10c02015 	stw	r3,128(r2)
  newTask->fp_reg = stackptr;
   a3770:	e0c00217 	ldw	r3,8(fp)
   a3774:	e0bff917 	ldw	r2,-28(fp)
   a3778:	10c01b15 	stw	r3,108(r2)
  newTask->priority = priority;
   a377c:	e0fffd17 	ldw	r3,-12(fp)
   a3780:	e0bff917 	ldw	r2,-28(fp)
   a3784:	10c02215 	stw	r3,136(r2)

  svc.task_create.type = sierra_task_create;
   a3788:	e0fffa17 	ldw	r3,-24(fp)
   a378c:	00810034 	movhi	r2,1024
   a3790:	10bfffc4 	addi	r2,r2,-1
   a3794:	1884703a 	and	r2,r3,r2
   a3798:	e0bffa15 	stw	r2,-24(fp)
  svc.task_create.state = taskstate;
   a379c:	e0bffe17 	ldw	r2,-8(fp)
   a37a0:	1080004c 	andi	r2,r2,1
   a37a4:	10803fcc 	andi	r2,r2,255
   a37a8:	1080004c 	andi	r2,r2,1
   a37ac:	1006963a 	slli	r3,r2,24
   a37b0:	e13ffa17 	ldw	r4,-24(fp)
   a37b4:	00bfc034 	movhi	r2,65280
   a37b8:	10bfffc4 	addi	r2,r2,-1
   a37bc:	2084703a 	and	r2,r4,r2
   a37c0:	10c4b03a 	or	r2,r2,r3
   a37c4:	e0bffa15 	stw	r2,-24(fp)
  svc.task_create.priority = priority;
   a37c8:	e0bffd17 	ldw	r2,-12(fp)
   a37cc:	1083ffcc 	andi	r2,r2,4095
   a37d0:	10bfffcc 	andi	r2,r2,65535
   a37d4:	1083ffcc 	andi	r2,r2,4095
   a37d8:	1006933a 	slli	r3,r2,12
   a37dc:	e13ffa17 	ldw	r4,-24(fp)
   a37e0:	00bfc034 	movhi	r2,65280
   a37e4:	1083ffc4 	addi	r2,r2,4095
   a37e8:	2084703a 	and	r2,r4,r2
   a37ec:	10c4b03a 	or	r2,r2,r3
   a37f0:	e0bffa15 	stw	r2,-24(fp)
  svc.task_create.taskID = taskID;
   a37f4:	e0bffc17 	ldw	r2,-16(fp)
   a37f8:	1083ffcc 	andi	r2,r2,4095
   a37fc:	10bfffcc 	andi	r2,r2,65535
   a3800:	1083ffcc 	andi	r2,r2,4095
   a3804:	e13ffa17 	ldw	r4,-24(fp)
   a3808:	00fc0004 	movi	r3,-4096
   a380c:	20c6703a 	and	r3,r4,r3
   a3810:	1884b03a 	or	r2,r3,r2
   a3814:	e0bffa15 	stw	r2,-24(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3818:	e0fffa17 	ldw	r3,-24(fp)
   a381c:	00800334 	movhi	r2,12
   a3820:	10841004 	addi	r2,r2,4160
   a3824:	10c00035 	stwio	r3,0(r2)

  //  ack_wait(&status);
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3828:	00800334 	movhi	r2,12
   a382c:	10840804 	addi	r2,r2,4128
   a3830:	10800037 	ldwio	r2,0(r2)
   a3834:	e0bffb15 	stw	r2,-20(fp)
  } while (status.statusA_t.svc_ack == 1);
   a3838:	e0bffb17 	ldw	r2,-20(fp)
   a383c:	1080004c 	andi	r2,r2,1
   a3840:	103ff91e 	bne	r2,zero,a3828 <__alt_data_end+0xfffe3828>

}
   a3844:	0001883a 	nop
   a3848:	e037883a 	mov	sp,fp
   a384c:	dfc00117 	ldw	ra,4(sp)
   a3850:	df000017 	ldw	fp,0(sp)
   a3854:	dec00204 	addi	sp,sp,8
   a3858:	f800283a 	ret

000a385c <task_getinfo>:
  Arguments   : int taskID

  Return      : Datastructure of type task_info_t.
-----------------------------------------------------------------------------*/
task_info_t task_getinfo(int taskID)
{
   a385c:	defffb04 	addi	sp,sp,-20
   a3860:	df000415 	stw	fp,16(sp)
   a3864:	df000404 	addi	fp,sp,16
   a3868:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  unsigned int info;
  statusA_union status;

  svc.task_getinfo.type =  sierra_task_getinfo;
   a386c:	e0fffc17 	ldw	r3,-16(fp)
   a3870:	00810034 	movhi	r2,1024
   a3874:	10bfffc4 	addi	r2,r2,-1
   a3878:	1884703a 	and	r2,r3,r2
   a387c:	10850034 	orhi	r2,r2,5120
   a3880:	e0bffc15 	stw	r2,-16(fp)
  svc.task_getinfo.taskID = taskID;
   a3884:	e0bfff17 	ldw	r2,-4(fp)
   a3888:	1083ffcc 	andi	r2,r2,4095
   a388c:	10bfffcc 	andi	r2,r2,65535
   a3890:	1083ffcc 	andi	r2,r2,4095
   a3894:	e13ffc17 	ldw	r4,-16(fp)
   a3898:	00fc0004 	movi	r3,-4096
   a389c:	20c6703a 	and	r3,r4,r3
   a38a0:	1884b03a 	or	r2,r3,r2
   a38a4:	e0bffc15 	stw	r2,-16(fp)
  
  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a38a8:	e0fffc17 	ldw	r3,-16(fp)
   a38ac:	00800334 	movhi	r2,12
   a38b0:	10841004 	addi	r2,r2,4160
   a38b4:	10c00035 	stwio	r3,0(r2)

  /* return vale */
  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a38b8:	00800334 	movhi	r2,12
   a38bc:	10840804 	addi	r2,r2,4128
   a38c0:	10800037 	ldwio	r2,0(r2)
   a38c4:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a38c8:	e0bffe17 	ldw	r2,-8(fp)
   a38cc:	1080004c 	andi	r2,r2,1
   a38d0:	103ff91e 	bne	r2,zero,a38b8 <__alt_data_end+0xfffe38b8>
    
//  info  = status.statusA_t.svc_return & 0x3FF; 
  info  = status.statusA_t.svc_return;
   a38d4:	e0bffe17 	ldw	r2,-8(fp)
   a38d8:	1004d0ba 	srli	r2,r2,2
   a38dc:	108fffcc 	andi	r2,r2,16383
   a38e0:	10bfffcc 	andi	r2,r2,65535
   a38e4:	e0bffd15 	stw	r2,-12(fp)

  return *(task_info_t *) &info;
   a38e8:	e0bffd04 	addi	r2,fp,-12
   a38ec:	10800017 	ldw	r2,0(r2)
}
   a38f0:	e037883a 	mov	sp,fp
   a38f4:	df000017 	ldw	fp,0(sp)
   a38f8:	dec00104 	addi	sp,sp,4
   a38fc:	f800283a 	ret

000a3900 <task_start>:
  Arguments   : int taskID

  Return      : none
-----------------------------------------------------------------------------*/
void task_start(int taskID)
{
   a3900:	defffc04 	addi	sp,sp,-16
   a3904:	df000315 	stw	fp,12(sp)
   a3908:	df000304 	addi	fp,sp,12
   a390c:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;
  
  svc.task_start.type =  sierra_task_start;
   a3910:	e0fffd17 	ldw	r3,-12(fp)
   a3914:	00810034 	movhi	r2,1024
   a3918:	10bfffc4 	addi	r2,r2,-1
   a391c:	1884703a 	and	r2,r3,r2
   a3920:	10820034 	orhi	r2,r2,2048
   a3924:	e0bffd15 	stw	r2,-12(fp)
  svc.task_start.taskID = taskID;
   a3928:	e0bfff17 	ldw	r2,-4(fp)
   a392c:	1083ffcc 	andi	r2,r2,4095
   a3930:	10bfffcc 	andi	r2,r2,65535
   a3934:	1083ffcc 	andi	r2,r2,4095
   a3938:	e13ffd17 	ldw	r4,-12(fp)
   a393c:	00fc0004 	movi	r3,-4096
   a3940:	20c6703a 	and	r3,r4,r3
   a3944:	1884b03a 	or	r2,r3,r2
   a3948:	e0bffd15 	stw	r2,-12(fp)
  
  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a394c:	e0fffd17 	ldw	r3,-12(fp)
   a3950:	00800334 	movhi	r2,12
   a3954:	10841004 	addi	r2,r2,4160
   a3958:	10c00035 	stwio	r3,0(r2)
  
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a395c:	00800334 	movhi	r2,12
   a3960:	10840804 	addi	r2,r2,4128
   a3964:	10800037 	ldwio	r2,0(r2)
   a3968:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a396c:	e0bffe17 	ldw	r2,-8(fp)
   a3970:	1080004c 	andi	r2,r2,1
   a3974:	103ff91e 	bne	r2,zero,a395c <__alt_data_end+0xfffe395c>
  
}
   a3978:	0001883a 	nop
   a397c:	e037883a 	mov	sp,fp
   a3980:	df000017 	ldw	fp,0(sp)
   a3984:	dec00104 	addi	sp,sp,4
   a3988:	f800283a 	ret

000a398c <task_block>:
  Arguments   : none
  Return      : none
-----------------------------------------------------------------------------*/

void task_block(int taskID)
{
   a398c:	defffb04 	addi	sp,sp,-20
   a3990:	df000415 	stw	fp,16(sp)
   a3994:	df000404 	addi	fp,sp,16
   a3998:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union statusA;
  int retval;

  svc.task_block.type =  sierra_task_block;
   a399c:	e0fffd17 	ldw	r3,-12(fp)
   a39a0:	00810034 	movhi	r2,1024
   a39a4:	10bfffc4 	addi	r2,r2,-1
   a39a8:	1884703a 	and	r2,r3,r2
   a39ac:	10830034 	orhi	r2,r2,3072
   a39b0:	e0bffd15 	stw	r2,-12(fp)
  svc.task_block.taskID = taskID;
   a39b4:	e0bfff17 	ldw	r2,-4(fp)
   a39b8:	1083ffcc 	andi	r2,r2,4095
   a39bc:	10bfffcc 	andi	r2,r2,65535
   a39c0:	1083ffcc 	andi	r2,r2,4095
   a39c4:	e13ffd17 	ldw	r4,-12(fp)
   a39c8:	00fc0004 	movi	r3,-4096
   a39cc:	20c6703a 	and	r3,r4,r3
   a39d0:	1884b03a 	or	r2,r3,r2
   a39d4:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a39d8:	e0fffd17 	ldw	r3,-12(fp)
   a39dc:	00800334 	movhi	r2,12
   a39e0:	10841004 	addi	r2,r2,4160
   a39e4:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
    statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a39e8:	00800334 	movhi	r2,12
   a39ec:	10840804 	addi	r2,r2,4128
   a39f0:	10800037 	ldwio	r2,0(r2)
   a39f4:	e0bffe15 	stw	r2,-8(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a39f8:	e0bffe17 	ldw	r2,-8(fp)
   a39fc:	1080004c 	andi	r2,r2,1
   a3a00:	103ff91e 	bne	r2,zero,a39e8 <__alt_data_end+0xfffe39e8>
 
  retval=statusA.statusA_t.svc_return & 0x3f;
   a3a04:	e0bffe17 	ldw	r2,-8(fp)
   a3a08:	1004d0ba 	srli	r2,r2,2
   a3a0c:	108fffcc 	andi	r2,r2,16383
   a3a10:	10bfffcc 	andi	r2,r2,65535
   a3a14:	10800fcc 	andi	r2,r2,63
   a3a18:	e0bffc15 	stw	r2,-16(fp)

//if runing task_id blocked the return is true (1) else false (0)
  if (0 != (retval & 0x1)) { /*Task becomes blocked*/
   a3a1c:	e0bffc17 	ldw	r2,-16(fp)
   a3a20:	1080004c 	andi	r2,r2,1
   a3a24:	10000526 	beq	r2,zero,a3a3c <task_block+0xb0>
    /* Get next task ID */
    NEXT_TASKID = constant_task_mask & (retval >> 1);
   a3a28:	e0bffc17 	ldw	r2,-16(fp)
   a3a2c:	1005d07a 	srai	r2,r2,1
   a3a30:	108001cc 	andi	r2,r2,7
   a3a34:	d0a0f305 	stb	r2,-31796(gp)
    taskswitch; /* perform manual contextswitch */
   a3a38:	003b683a 	trap	0

// NEXT_TASKID = constant_task_mask & statusA.statusA_t.svc_return;
 
//  taskswitch; /* perform manual contextswitch */

}
   a3a3c:	0001883a 	nop
   a3a40:	e037883a 	mov	sp,fp
   a3a44:	df000017 	ldw	fp,0(sp)
   a3a48:	dec00104 	addi	sp,sp,4
   a3a4c:	f800283a 	ret

000a3a50 <task_delete>:
  Return      : none
-----------------------------------------------------------------------------*/


void task_delete(void)
{
   a3a50:	defffd04 	addi	sp,sp,-12
   a3a54:	df000215 	stw	fp,8(sp)
   a3a58:	df000204 	addi	fp,sp,8
  svc_t svc;
  statusA_union statusA;

  svc.wait_for_next_period.type =  sierra_task_delete;
   a3a5c:	e0fffe17 	ldw	r3,-8(fp)
   a3a60:	00810034 	movhi	r2,1024
   a3a64:	10bfffc4 	addi	r2,r2,-1
   a3a68:	1884703a 	and	r2,r3,r2
   a3a6c:	10810034 	orhi	r2,r2,1024
   a3a70:	e0bffe15 	stw	r2,-8(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3a74:	e0fffe17 	ldw	r3,-8(fp)
   a3a78:	00800334 	movhi	r2,12
   a3a7c:	10841004 	addi	r2,r2,4160
   a3a80:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
    statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3a84:	00800334 	movhi	r2,12
   a3a88:	10840804 	addi	r2,r2,4128
   a3a8c:	10800037 	ldwio	r2,0(r2)
   a3a90:	e0bfff15 	stw	r2,-4(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a3a94:	e0bfff17 	ldw	r2,-4(fp)
   a3a98:	1080004c 	andi	r2,r2,1
   a3a9c:	103ff91e 	bne	r2,zero,a3a84 <__alt_data_end+0xfffe3a84>

  /* Get next task ID */

 NEXT_TASKID = constant_task_mask & statusA.statusA_t.svc_return;
   a3aa0:	e0bfff17 	ldw	r2,-4(fp)
   a3aa4:	1004d0ba 	srli	r2,r2,2
   a3aa8:	108fffcc 	andi	r2,r2,16383
   a3aac:	108001cc 	andi	r2,r2,7
   a3ab0:	d0a0f305 	stb	r2,-31796(gp)

  taskswitch; /* perform manual contextswitch */
   a3ab4:	003b683a 	trap	0

}
   a3ab8:	0001883a 	nop
   a3abc:	e037883a 	mov	sp,fp
   a3ac0:	df000017 	ldw	fp,0(sp)
   a3ac4:	dec00104 	addi	sp,sp,4
   a3ac8:	f800283a 	ret

000a3acc <task_change_prio>:
  Arguments   : int taskID and int priority

  Return      : none
-----------------------------------------------------------------------------*/
void task_change_prio(int taskID, int priority)
{
   a3acc:	defffb04 	addi	sp,sp,-20
   a3ad0:	df000415 	stw	fp,16(sp)
   a3ad4:	df000404 	addi	fp,sp,16
   a3ad8:	e13ffe15 	stw	r4,-8(fp)
   a3adc:	e17fff15 	stw	r5,-4(fp)
  svc_t svc;
  statusA_union status;
  
  svc.task_start.type =  sierra_task_change_prio;
   a3ae0:	e0fffc17 	ldw	r3,-16(fp)
   a3ae4:	00810034 	movhi	r2,1024
   a3ae8:	10bfffc4 	addi	r2,r2,-1
   a3aec:	1884703a 	and	r2,r3,r2
   a3af0:	10860034 	orhi	r2,r2,6144
   a3af4:	e0bffc15 	stw	r2,-16(fp)
  svc.task_create.priority = priority;
   a3af8:	e0bfff17 	ldw	r2,-4(fp)
   a3afc:	1083ffcc 	andi	r2,r2,4095
   a3b00:	10bfffcc 	andi	r2,r2,65535
   a3b04:	1083ffcc 	andi	r2,r2,4095
   a3b08:	1006933a 	slli	r3,r2,12
   a3b0c:	e13ffc17 	ldw	r4,-16(fp)
   a3b10:	00bfc034 	movhi	r2,65280
   a3b14:	1083ffc4 	addi	r2,r2,4095
   a3b18:	2084703a 	and	r2,r4,r2
   a3b1c:	10c4b03a 	or	r2,r2,r3
   a3b20:	e0bffc15 	stw	r2,-16(fp)
  svc.task_start.taskID = taskID;
   a3b24:	e0bffe17 	ldw	r2,-8(fp)
   a3b28:	1083ffcc 	andi	r2,r2,4095
   a3b2c:	10bfffcc 	andi	r2,r2,65535
   a3b30:	1083ffcc 	andi	r2,r2,4095
   a3b34:	e13ffc17 	ldw	r4,-16(fp)
   a3b38:	00fc0004 	movi	r3,-4096
   a3b3c:	20c6703a 	and	r3,r4,r3
   a3b40:	1884b03a 	or	r2,r3,r2
   a3b44:	e0bffc15 	stw	r2,-16(fp)
  
  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3b48:	e0fffc17 	ldw	r3,-16(fp)
   a3b4c:	00800334 	movhi	r2,12
   a3b50:	10841004 	addi	r2,r2,4160
   a3b54:	10c00035 	stwio	r3,0(r2)
  
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3b58:	00800334 	movhi	r2,12
   a3b5c:	10840804 	addi	r2,r2,4128
   a3b60:	10800037 	ldwio	r2,0(r2)
   a3b64:	e0bffd15 	stw	r2,-12(fp)
  } while (status.statusA_t.svc_ack == 1);
   a3b68:	e0bffd17 	ldw	r2,-12(fp)
   a3b6c:	1080004c 	andi	r2,r2,1
   a3b70:	103ff91e 	bne	r2,zero,a3b58 <__alt_data_end+0xfffe3b58>
  
}
   a3b74:	0001883a 	nop
   a3b78:	e037883a 	mov	sp,fp
   a3b7c:	df000017 	ldw	fp,0(sp)
   a3b80:	dec00104 	addi	sp,sp,4
   a3b84:	f800283a 	ret

000a3b88 <task_yield>:
  Arguments   : none

  Return      : none
-----------------------------------------------------------------------------*/
void task_yield(void)
{
   a3b88:	defffc04 	addi	sp,sp,-16
   a3b8c:	df000315 	stw	fp,12(sp)
   a3b90:	df000304 	addi	fp,sp,12
  statusA_union statusA;
  statusB_union statusB;
  svc_t svc;
 
  svc.task_yield.type = sierra_task_yield;
   a3b94:	e0ffff17 	ldw	r3,-4(fp)
   a3b98:	00810034 	movhi	r2,1024
   a3b9c:	10bfffc4 	addi	r2,r2,-1
   a3ba0:	1884703a 	and	r2,r3,r2
   a3ba4:	10840034 	orhi	r2,r2,4096
   a3ba8:	e0bfff15 	stw	r2,-4(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3bac:	e0ffff17 	ldw	r3,-4(fp)
   a3bb0:	00800334 	movhi	r2,12
   a3bb4:	10841004 	addi	r2,r2,4160
   a3bb8:	10c00035 	stwio	r3,0(r2)

  do {
	statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3bbc:	00800334 	movhi	r2,12
   a3bc0:	10840804 	addi	r2,r2,4128
   a3bc4:	10800037 	ldwio	r2,0(r2)
   a3bc8:	e0bffd15 	stw	r2,-12(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a3bcc:	e0bffd17 	ldw	r2,-12(fp)
   a3bd0:	1080004c 	andi	r2,r2,1
   a3bd4:	103ff91e 	bne	r2,zero,a3bbc <__alt_data_end+0xfffe3bbc>

  
statusB.statusB_reg_integer = M_RD_Sierra_statusB_reg;
   a3bd8:	00800334 	movhi	r2,12
   a3bdc:	10840c04 	addi	r2,r2,4144
   a3be0:	10800037 	ldwio	r2,0(r2)
   a3be4:	e0bffe15 	stw	r2,-8(fp)

  /* Get next task ID */
NEXT_TASKID = constant_task_mask & statusB.statusB_t.running_taskID;
   a3be8:	e0bffe17 	ldw	r2,-8(fp)
   a3bec:	1004d07a 	srli	r2,r2,1
   a3bf0:	1007883a 	mov	r3,r2
   a3bf4:	00bfffc4 	movi	r2,-1
   a3bf8:	1884703a 	and	r2,r3,r2
   a3bfc:	108001cc 	andi	r2,r2,7
   a3c00:	d0a0f305 	stb	r2,-31796(gp)

  taskswitch; /* perform manual contextswitch */
   a3c04:	003b683a 	trap	0
}
   a3c08:	0001883a 	nop
   a3c0c:	e037883a 	mov	sp,fp
   a3c10:	df000017 	ldw	fp,0(sp)
   a3c14:	dec00104 	addi	sp,sp,4
   a3c18:	f800283a 	ret

000a3c1c <init_period_time>:
  Arguments   : Periodtime (in ticks)

  Return      : none
-----------------------------------------------------------------------------*/
void init_period_time(int per_time)
{
   a3c1c:	defffc04 	addi	sp,sp,-16
   a3c20:	df000315 	stw	fp,12(sp)
   a3c24:	df000304 	addi	fp,sp,12
   a3c28:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union status;
  svc.init_period_time.type =  sierra_init_period_time;
   a3c2c:	e0fffd17 	ldw	r3,-12(fp)
   a3c30:	00810034 	movhi	r2,1024
   a3c34:	10bfffc4 	addi	r2,r2,-1
   a3c38:	1884703a 	and	r2,r3,r2
   a3c3c:	10910034 	orhi	r2,r2,17408
   a3c40:	e0bffd15 	stw	r2,-12(fp)
  svc.init_period_time.period =  per_time;
   a3c44:	e0bfff17 	ldw	r2,-4(fp)
   a3c48:	e0bffd0d 	sth	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3c4c:	e0fffd17 	ldw	r3,-12(fp)
   a3c50:	00800334 	movhi	r2,12
   a3c54:	10841004 	addi	r2,r2,4160
   a3c58:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	status.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3c5c:	00800334 	movhi	r2,12
   a3c60:	10840804 	addi	r2,r2,4128
   a3c64:	10800037 	ldwio	r2,0(r2)
   a3c68:	e0bffe15 	stw	r2,-8(fp)
  } while (status.statusA_t.svc_ack == 1);
   a3c6c:	e0bffe17 	ldw	r2,-8(fp)
   a3c70:	1080004c 	andi	r2,r2,1
   a3c74:	103ff91e 	bne	r2,zero,a3c5c <__alt_data_end+0xfffe3c5c>
}
   a3c78:	0001883a 	nop
   a3c7c:	e037883a 	mov	sp,fp
   a3c80:	df000017 	ldw	fp,0(sp)
   a3c84:	dec00104 	addi	sp,sp,4
   a3c88:	f800283a 	ret

000a3c8c <wait_for_next_period>:
  Description : Let current task wait for next period.
  Arguments   : none
  Return      : none
-----------------------------------------------------------------------------*/
task_periodic_start_union wait_for_next_period(void)
{
   a3c8c:	defffa04 	addi	sp,sp,-24
   a3c90:	dfc00515 	stw	ra,20(sp)
   a3c94:	df000415 	stw	fp,16(sp)
   a3c98:	df000404 	addi	fp,sp,16
//  unsigned int info;
  task_periodic_start_union info;
  unsigned int temp;
  statusA_union statusA;

  svc.wait_for_next_period.type =  sierra_wait_for_next_period;
   a3c9c:	e0fffc17 	ldw	r3,-16(fp)
   a3ca0:	00810034 	movhi	r2,1024
   a3ca4:	10bfffc4 	addi	r2,r2,-1
   a3ca8:	1884703a 	and	r2,r3,r2
   a3cac:	10940034 	orhi	r2,r2,20480
   a3cb0:	e0bffc15 	stw	r2,-16(fp)
  tsw_off();
   a3cb4:	00a31980 	call	a3198 <tsw_off>

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3cb8:	e0fffc17 	ldw	r3,-16(fp)
   a3cbc:	00800334 	movhi	r2,12
   a3cc0:	10841004 	addi	r2,r2,4160
   a3cc4:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3cc8:	00800334 	movhi	r2,12
   a3ccc:	10840804 	addi	r2,r2,4128
   a3cd0:	10800037 	ldwio	r2,0(r2)
   a3cd4:	e0bfff15 	stw	r2,-4(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a3cd8:	e0bfff17 	ldw	r2,-4(fp)
   a3cdc:	1080004c 	andi	r2,r2,1
   a3ce0:	103ff91e 	bne	r2,zero,a3cc8 <__alt_data_end+0xfffe3cc8>
 
  /* Get next task ID */
  info.periodic_start_integer = statusA.statusA_t.svc_return;
   a3ce4:	e0bfff17 	ldw	r2,-4(fp)
   a3ce8:	1004d0ba 	srli	r2,r2,2
   a3cec:	108fffcc 	andi	r2,r2,16383
   a3cf0:	10bfffcc 	andi	r2,r2,65535
   a3cf4:	e0bffd15 	stw	r2,-12(fp)

NEXT_TASKID = constant_task_mask & info.task_periodic_start_t.task_id;
   a3cf8:	e0bffd17 	ldw	r2,-12(fp)
   a3cfc:	100493fa 	slli	r2,r2,15
   a3d00:	1005d43a 	srai	r2,r2,16
   a3d04:	108001cc 	andi	r2,r2,7
   a3d08:	d0a0f305 	stb	r2,-31796(gp)
 
 temp = info.periodic_start_integer;
   a3d0c:	e0bffd17 	ldw	r2,-12(fp)
   a3d10:	e0bffe15 	stw	r2,-8(fp)
  tsw_on();
   a3d14:	00a31480 	call	a3148 <tsw_on>
  taskswitch; /* perform manual contextswitch */
   a3d18:	003b683a 	trap	0

  return *(task_periodic_start_union *) & temp; //if you do not use deadline control, you can deleate this row.
   a3d1c:	e0bffe04 	addi	r2,fp,-8
   a3d20:	10800017 	ldw	r2,0(r2)
}
   a3d24:	e037883a 	mov	sp,fp
   a3d28:	dfc00117 	ldw	ra,4(sp)
   a3d2c:	df000017 	ldw	fp,0(sp)
   a3d30:	dec00204 	addi	sp,sp,8
   a3d34:	f800283a 	ret

000a3d38 <delay>:
  Arguments   : Number of ticks to delay task.

  Return      : none
-----------------------------------------------------------------------------*/
void delay(int delay_time)
{
   a3d38:	defffc04 	addi	sp,sp,-16
   a3d3c:	df000315 	stw	fp,12(sp)
   a3d40:	df000304 	addi	fp,sp,12
   a3d44:	e13fff15 	stw	r4,-4(fp)
  svc_t svc;
  statusA_union statusA;
 
  svc.delay.type =  sierra_delay;
   a3d48:	e0fffd17 	ldw	r3,-12(fp)
   a3d4c:	00810034 	movhi	r2,1024
   a3d50:	10bfffc4 	addi	r2,r2,-1
   a3d54:	1884703a 	and	r2,r3,r2
   a3d58:	10900034 	orhi	r2,r2,16384
   a3d5c:	e0bffd15 	stw	r2,-12(fp)
  svc.delay.nroftick =  delay_time;
   a3d60:	e0ffff17 	ldw	r3,-4(fp)
   a3d64:	00810034 	movhi	r2,1024
   a3d68:	10bfffc4 	addi	r2,r2,-1
   a3d6c:	1886703a 	and	r3,r3,r2
   a3d70:	00810034 	movhi	r2,1024
   a3d74:	10bfffc4 	addi	r2,r2,-1
   a3d78:	1884703a 	and	r2,r3,r2
   a3d7c:	e0fffd17 	ldw	r3,-12(fp)
   a3d80:	18ff002c 	andhi	r3,r3,64512
   a3d84:	1884b03a 	or	r2,r3,r2
   a3d88:	e0bffd15 	stw	r2,-12(fp)

  /* Start service call*/
  IOWR_ALT_SVC_REGISTER(svc.svc_input);
   a3d8c:	e0fffd17 	ldw	r3,-12(fp)
   a3d90:	00800334 	movhi	r2,12
   a3d94:	10841004 	addi	r2,r2,4160
   a3d98:	10c00035 	stwio	r3,0(r2)

  //  ack_wait
  do {
	statusA.statusA_reg_integer = M_RD_Sierra_statusA_reg;
   a3d9c:	00800334 	movhi	r2,12
   a3da0:	10840804 	addi	r2,r2,4128
   a3da4:	10800037 	ldwio	r2,0(r2)
   a3da8:	e0bffe15 	stw	r2,-8(fp)
  } while (statusA.statusA_t.svc_ack == 1);
   a3dac:	e0bffe17 	ldw	r2,-8(fp)
   a3db0:	1080004c 	andi	r2,r2,1
   a3db4:	103ff91e 	bne	r2,zero,a3d9c <__alt_data_end+0xfffe3d9c>
  
  /* Get next task ID */
 NEXT_TASKID = constant_task_mask & statusA.statusA_t.svc_return;
   a3db8:	e0bffe17 	ldw	r2,-8(fp)
   a3dbc:	1004d0ba 	srli	r2,r2,2
   a3dc0:	108fffcc 	andi	r2,r2,16383
   a3dc4:	108001cc 	andi	r2,r2,7
   a3dc8:	d0a0f305 	stb	r2,-31796(gp)

  taskswitch; /* perform manual contextswitch */
   a3dcc:	003b683a 	trap	0
}
   a3dd0:	0001883a 	nop
   a3dd4:	e037883a 	mov	sp,fp
   a3dd8:	df000017 	ldw	fp,0(sp)
   a3ddc:	dec00104 	addi	sp,sp,4
   a3de0:	f800283a 	ret

000a3de4 <init_screen>:
#include <servo_motor_drivers.h>



volatile init_screen()
{
   a3de4:	defffd04 	addi	sp,sp,-12
   a3de8:	dfc00215 	stw	ra,8(sp)
   a3dec:	df000115 	stw	fp,4(sp)
   a3df0:	df000104 	addi	fp,sp,4
    clear_screen(0x0);
   a3df4:	0009883a 	mov	r4,zero
   a3df8:	00a206c0 	call	a206c <clear_screen>
    tty_print(10,10,"TEIS AB 21-06-20",COLOR_WHITE,COLOR_BLACK);
   a3dfc:	d8000015 	stw	zero,0(sp)
   a3e00:	01c001c4 	movi	r7,7
   a3e04:	018002b4 	movhi	r6,10
   a3e08:	31943604 	addi	r6,r6,20696
   a3e0c:	01400284 	movi	r5,10
   a3e10:	01000284 	movi	r4,10
   a3e14:	00a296c0 	call	a296c <tty_print>
    tty_print(10,20,"Examens Job",COLOR_WHITE,COLOR_BLACK);
   a3e18:	d8000015 	stw	zero,0(sp)
   a3e1c:	01c001c4 	movi	r7,7
   a3e20:	018002b4 	movhi	r6,10
   a3e24:	31943b04 	addi	r6,r6,20716
   a3e28:	01400504 	movi	r5,20
   a3e2c:	01000284 	movi	r4,10
   a3e30:	00a296c0 	call	a296c <tty_print>
    tty_print(10,40,"By Ashraf Tumah",COLOR_WHITE,COLOR_BLACK);
   a3e34:	d8000015 	stw	zero,0(sp)
   a3e38:	01c001c4 	movi	r7,7
   a3e3c:	018002b4 	movhi	r6,10
   a3e40:	31943e04 	addi	r6,r6,20728
   a3e44:	01400a04 	movi	r5,40
   a3e48:	01000284 	movi	r4,10
   a3e4c:	00a296c0 	call	a296c <tty_print>
    tty_print(70,80,"Range Meter",COLOR_CYAN,COLOR_BLACK);
   a3e50:	d8000015 	stw	zero,0(sp)
   a3e54:	01c00184 	movi	r7,6
   a3e58:	018002b4 	movhi	r6,10
   a3e5c:	31944204 	addi	r6,r6,20744
   a3e60:	01401404 	movi	r5,80
   a3e64:	01001184 	movi	r4,70
   a3e68:	00a296c0 	call	a296c <tty_print>
    tty_print(50,120,"Press Key0 to Test  Servo Motor",COLOR_CYAN,COLOR_BLACK);
   a3e6c:	d8000015 	stw	zero,0(sp)
   a3e70:	01c00184 	movi	r7,6
   a3e74:	018002b4 	movhi	r6,10
   a3e78:	31944504 	addi	r6,r6,20756
   a3e7c:	01401e04 	movi	r5,120
   a3e80:	01000c84 	movi	r4,50
   a3e84:	00a296c0 	call	a296c <tty_print>
    tty_print(50,140,"Press Key1 to Start Software",COLOR_CYAN,COLOR_BLACK);
   a3e88:	d8000015 	stw	zero,0(sp)
   a3e8c:	01c00184 	movi	r7,6
   a3e90:	018002b4 	movhi	r6,10
   a3e94:	31944d04 	addi	r6,r6,20788
   a3e98:	01402304 	movi	r5,140
   a3e9c:	01000c84 	movi	r4,50
   a3ea0:	00a296c0 	call	a296c <tty_print>
}
   a3ea4:	0001883a 	nop
   a3ea8:	e037883a 	mov	sp,fp
   a3eac:	dfc00117 	ldw	ra,4(sp)
   a3eb0:	df000017 	ldw	fp,0(sp)
   a3eb4:	dec00204 	addi	sp,sp,8
   a3eb8:	f800283a 	ret

000a3ebc <pattern>:

void pattern()
{
   a3ebc:	defffd04 	addi	sp,sp,-12
   a3ec0:	dfc00215 	stw	ra,8(sp)
   a3ec4:	df000115 	stw	fp,4(sp)
   a3ec8:	df000104 	addi	fp,sp,4
    //bottom line
    draw_hline(10,200,300,COLOR_GREEN);
   a3ecc:	01c00084 	movi	r7,2
   a3ed0:	01804b04 	movi	r6,300
   a3ed4:	01403204 	movi	r5,200
   a3ed8:	01000284 	movi	r4,10
   a3edc:	00a21040 	call	a2104 <draw_hline>

    //center vlines
    draw_vline(140,10,150,COLOR_GREEN);
   a3ee0:	01c00084 	movi	r7,2
   a3ee4:	01802584 	movi	r6,150
   a3ee8:	01400284 	movi	r5,10
   a3eec:	01002304 	movi	r4,140
   a3ef0:	00a21900 	call	a2190 <draw_vline>
    draw_vline(180,10,150,COLOR_GREEN);
   a3ef4:	01c00084 	movi	r7,2
   a3ef8:	01802584 	movi	r6,150
   a3efc:	01400284 	movi	r5,10
   a3f00:	01002d04 	movi	r4,180
   a3f04:	00a21900 	call	a2190 <draw_vline>

    //left lines
    draw_angled_line(90,10,120,160,COLOR_GREEN);
   a3f08:	00800084 	movi	r2,2
   a3f0c:	d8800015 	stw	r2,0(sp)
   a3f10:	01c02804 	movi	r7,160
   a3f14:	01801e04 	movi	r6,120
   a3f18:	01400284 	movi	r5,10
   a3f1c:	01001684 	movi	r4,90
   a3f20:	00a272c0 	call	a272c <draw_angled_line>
    draw_angled_line(30,50,100,160,0x2);
   a3f24:	00800084 	movi	r2,2
   a3f28:	d8800015 	stw	r2,0(sp)
   a3f2c:	01c02804 	movi	r7,160
   a3f30:	01801904 	movi	r6,100
   a3f34:	01400c84 	movi	r5,50
   a3f38:	01000784 	movi	r4,30
   a3f3c:	00a272c0 	call	a272c <draw_angled_line>
    draw_angled_line(10,110,60,160,0x2);
   a3f40:	00800084 	movi	r2,2
   a3f44:	d8800015 	stw	r2,0(sp)
   a3f48:	01c02804 	movi	r7,160
   a3f4c:	01800f04 	movi	r6,60
   a3f50:	01401b84 	movi	r5,110
   a3f54:	01000284 	movi	r4,10
   a3f58:	00a272c0 	call	a272c <draw_angled_line>

    //right lines
    draw_angled_line(230,10,200,160,COLOR_GREEN);
   a3f5c:	00800084 	movi	r2,2
   a3f60:	d8800015 	stw	r2,0(sp)
   a3f64:	01c02804 	movi	r7,160
   a3f68:	01803204 	movi	r6,200
   a3f6c:	01400284 	movi	r5,10
   a3f70:	01003984 	movi	r4,230
   a3f74:	00a272c0 	call	a272c <draw_angled_line>
    draw_angled_line(290,50,220,160,COLOR_GREEN);
   a3f78:	00800084 	movi	r2,2
   a3f7c:	d8800015 	stw	r2,0(sp)
   a3f80:	01c02804 	movi	r7,160
   a3f84:	01803704 	movi	r6,220
   a3f88:	01400c84 	movi	r5,50
   a3f8c:	01004884 	movi	r4,290
   a3f90:	00a272c0 	call	a272c <draw_angled_line>
    draw_angled_line(310,110,260,160,COLOR_GREEN);
   a3f94:	00800084 	movi	r2,2
   a3f98:	d8800015 	stw	r2,0(sp)
   a3f9c:	01c02804 	movi	r7,160
   a3fa0:	01804104 	movi	r6,260
   a3fa4:	01401b84 	movi	r5,110
   a3fa8:	01004d84 	movi	r4,310
   a3fac:	00a272c0 	call	a272c <draw_angled_line>
}
   a3fb0:	0001883a 	nop
   a3fb4:	e037883a 	mov	sp,fp
   a3fb8:	dfc00117 	ldw	ra,4(sp)
   a3fbc:	df000017 	ldw	fp,0(sp)
   a3fc0:	dec00204 	addi	sp,sp,8
   a3fc4:	f800283a 	ret

000a3fc8 <testFunction>:

void testFunction()
{
   a3fc8:	defffa04 	addi	sp,sp,-24
   a3fcc:	dfc00515 	stw	ra,20(sp)
   a3fd0:	df000415 	stw	fp,16(sp)
   a3fd4:	df000404 	addi	fp,sp,16
    alt_u8 key_r=1;
   a3fd8:	00800044 	movi	r2,1
   a3fdc:	e0bffd05 	stb	r2,-12(fp)
    while(1)
    {
        int key_in = KEY_1 & IORD_ALTERA_AVALON_PIO_DATA(BUTTON_PIO_BASE);
   a3fe0:	00800334 	movhi	r2,12
   a3fe4:	10850404 	addi	r2,r2,5136
   a3fe8:	10800037 	ldwio	r2,0(r2)
   a3fec:	1080008c 	andi	r2,r2,2
   a3ff0:	e0bffe15 	stw	r2,-8(fp)
        int sw=IORD_32DIRECT(SWITCH_PIO_BASE,0);
   a3ff4:	00800334 	movhi	r2,12
   a3ff8:	10850004 	addi	r2,r2,5120
   a3ffc:	10800037 	ldwio	r2,0(r2)
   a4000:	e0bfff15 	stw	r2,-4(fp)

        tty_print(10,20,"Test ServoMotor by Switches",COLOR_GREEN,COLOR_BLACK);
   a4004:	d8000015 	stw	zero,0(sp)
   a4008:	01c00084 	movi	r7,2
   a400c:	018002b4 	movhi	r6,10
   a4010:	31945504 	addi	r6,r6,20820
   a4014:	01400504 	movi	r5,20
   a4018:	01000284 	movi	r4,10
   a401c:	00a296c0 	call	a296c <tty_print>
        tty_print(30,60,"Switch0= Servo Angle 0 Degrees",COLOR_YELLOW,COLOR_BLACK);
   a4020:	d8000015 	stw	zero,0(sp)
   a4024:	01c000c4 	movi	r7,3
   a4028:	018002b4 	movhi	r6,10
   a402c:	31945c04 	addi	r6,r6,20848
   a4030:	01400f04 	movi	r5,60
   a4034:	01000784 	movi	r4,30
   a4038:	00a296c0 	call	a296c <tty_print>
        tty_print(30,80,"Switch1= Servo Angle 90 Degrees",COLOR_YELLOW,COLOR_BLACK);
   a403c:	d8000015 	stw	zero,0(sp)
   a4040:	01c000c4 	movi	r7,3
   a4044:	018002b4 	movhi	r6,10
   a4048:	31946404 	addi	r6,r6,20880
   a404c:	01401404 	movi	r5,80
   a4050:	01000784 	movi	r4,30
   a4054:	00a296c0 	call	a296c <tty_print>
        tty_print(30,100,"Switch3= Servo Angle 180 Degrees",COLOR_YELLOW,COLOR_BLACK);
   a4058:	d8000015 	stw	zero,0(sp)
   a405c:	01c000c4 	movi	r7,3
   a4060:	018002b4 	movhi	r6,10
   a4064:	31946c04 	addi	r6,r6,20912
   a4068:	01401904 	movi	r5,100
   a406c:	01000784 	movi	r4,30
   a4070:	00a296c0 	call	a296c <tty_print>
        tty_print(10,200,"Key 1, Back to StartScreen",COLOR_RED,COLOR_BLACK);
   a4074:	d8000015 	stw	zero,0(sp)
   a4078:	01c00044 	movi	r7,1
   a407c:	018002b4 	movhi	r6,10
   a4080:	31947504 	addi	r6,r6,20948
   a4084:	01403204 	movi	r5,200
   a4088:	01000284 	movi	r4,10
   a408c:	00a296c0 	call	a296c <tty_print>

        if(sw==1){
   a4090:	e0bfff17 	ldw	r2,-4(fp)
   a4094:	10800058 	cmpnei	r2,r2,1
   a4098:	1000051e 	bne	r2,zero,a40b0 <testFunction+0xe8>
            servo_position(Degrees_0);
   a409c:	00c00384 	movi	r3,14
   a40a0:	00800334 	movhi	r2,12
   a40a4:	10851c04 	addi	r2,r2,5232
   a40a8:	10c00035 	stwio	r3,0(r2)
   a40ac:	00000f06 	br	a40ec <testFunction+0x124>
        }
        else if(sw==2){
   a40b0:	e0bfff17 	ldw	r2,-4(fp)
   a40b4:	10800098 	cmpnei	r2,r2,2
   a40b8:	1000051e 	bne	r2,zero,a40d0 <testFunction+0x108>
            servo_position(Degrees_90);
   a40bc:	00c00c04 	movi	r3,48
   a40c0:	00800334 	movhi	r2,12
   a40c4:	10851c04 	addi	r2,r2,5232
   a40c8:	10c00035 	stwio	r3,0(r2)
   a40cc:	00000706 	br	a40ec <testFunction+0x124>
        }
        else if (sw==4){
   a40d0:	e0bfff17 	ldw	r2,-4(fp)
   a40d4:	10800118 	cmpnei	r2,r2,4
   a40d8:	1000041e 	bne	r2,zero,a40ec <testFunction+0x124>
            servo_position(Degrees_180);
   a40dc:	00c01404 	movi	r3,80
   a40e0:	00800334 	movhi	r2,12
   a40e4:	10851c04 	addi	r2,r2,5232
   a40e8:	10c00035 	stwio	r3,0(r2)
        }
        if(key_in!=KEY_1)
   a40ec:	e0bffe17 	ldw	r2,-8(fp)
   a40f0:	108000a0 	cmpeqi	r2,r2,2
   a40f4:	1000091e 	bne	r2,zero,a411c <testFunction+0x154>
        {
            for( alt_u16 i=10000;i>0;i--);
   a40f8:	0089c404 	movi	r2,10000
   a40fc:	e0bffd8d 	sth	r2,-10(fp)
   a4100:	00000306 	br	a4110 <testFunction+0x148>
   a4104:	e0bffd8b 	ldhu	r2,-10(fp)
   a4108:	10bfffc4 	addi	r2,r2,-1
   a410c:	e0bffd8d 	sth	r2,-10(fp)
   a4110:	e0bffd8b 	ldhu	r2,-10(fp)
   a4114:	103ffb1e 	bne	r2,zero,a4104 <__alt_data_end+0xfffe4104>
            key_r=0;
   a4118:	e03ffd05 	stb	zero,-12(fp)
        }
        if ((key_in==KEY_1) && (key_r==0)) break;
   a411c:	e0bffe17 	ldw	r2,-8(fp)
   a4120:	10800098 	cmpnei	r2,r2,2
   a4124:	103fae1e 	bne	r2,zero,a3fe0 <__alt_data_end+0xfffe3fe0>
   a4128:	e0bffd03 	ldbu	r2,-12(fp)
   a412c:	10000126 	beq	r2,zero,a4134 <testFunction+0x16c>
    }
   a4130:	003fab06 	br	a3fe0 <__alt_data_end+0xfffe3fe0>
        if(key_in!=KEY_1)
        {
            for( alt_u16 i=10000;i>0;i--);
            key_r=0;
        }
        if ((key_in==KEY_1) && (key_r==0)) break;
   a4134:	0001883a 	nop
    }
}
   a4138:	0001883a 	nop
   a413c:	e037883a 	mov	sp,fp
   a4140:	dfc00117 	ldw	ra,4(sp)
   a4144:	df000017 	ldw	fp,0(sp)
   a4148:	dec00204 	addi	sp,sp,8
   a414c:	f800283a 	ret

000a4150 <DELAY>:

volatile DELAY(size_t i)
{
   a4150:	defffe04 	addi	sp,sp,-8
   a4154:	df000115 	stw	fp,4(sp)
   a4158:	df000104 	addi	fp,sp,4
   a415c:	e13fff15 	stw	r4,-4(fp)
	for(;i>0;i--);
   a4160:	00000306 	br	a4170 <DELAY+0x20>
   a4164:	e0bfff17 	ldw	r2,-4(fp)
   a4168:	10bfffc4 	addi	r2,r2,-1
   a416c:	e0bfff15 	stw	r2,-4(fp)
   a4170:	e0bfff17 	ldw	r2,-4(fp)
   a4174:	103ffb1e 	bne	r2,zero,a4164 <__alt_data_end+0xfffe4164>
}
   a4178:	0001883a 	nop
   a417c:	e037883a 	mov	sp,fp
   a4180:	df000017 	ldw	fp,0(sp)
   a4184:	dec00104 	addi	sp,sp,4
   a4188:	f800283a 	ret

000a418c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   a418c:	defffe04 	addi	sp,sp,-8
   a4190:	dfc00115 	stw	ra,4(sp)
   a4194:	df000015 	stw	fp,0(sp)
   a4198:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   a419c:	d0a00717 	ldw	r2,-32740(gp)
   a41a0:	10000326 	beq	r2,zero,a41b0 <alt_get_errno+0x24>
   a41a4:	d0a00717 	ldw	r2,-32740(gp)
   a41a8:	103ee83a 	callr	r2
   a41ac:	00000106 	br	a41b4 <alt_get_errno+0x28>
   a41b0:	d0a0ed04 	addi	r2,gp,-31820
}
   a41b4:	e037883a 	mov	sp,fp
   a41b8:	dfc00117 	ldw	ra,4(sp)
   a41bc:	df000017 	ldw	fp,0(sp)
   a41c0:	dec00204 	addi	sp,sp,8
   a41c4:	f800283a 	ret

000a41c8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   a41c8:	defffb04 	addi	sp,sp,-20
   a41cc:	dfc00415 	stw	ra,16(sp)
   a41d0:	df000315 	stw	fp,12(sp)
   a41d4:	df000304 	addi	fp,sp,12
   a41d8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   a41dc:	e0bfff17 	ldw	r2,-4(fp)
   a41e0:	10000816 	blt	r2,zero,a4204 <close+0x3c>
   a41e4:	01400304 	movi	r5,12
   a41e8:	e13fff17 	ldw	r4,-4(fp)
   a41ec:	00a1acc0 	call	a1acc <__mulsi3>
   a41f0:	1007883a 	mov	r3,r2
   a41f4:	008002b4 	movhi	r2,10
   a41f8:	1095b204 	addi	r2,r2,22216
   a41fc:	1885883a 	add	r2,r3,r2
   a4200:	00000106 	br	a4208 <close+0x40>
   a4204:	0005883a 	mov	r2,zero
   a4208:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   a420c:	e0bffd17 	ldw	r2,-12(fp)
   a4210:	10001926 	beq	r2,zero,a4278 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   a4214:	e0bffd17 	ldw	r2,-12(fp)
   a4218:	10800017 	ldw	r2,0(r2)
   a421c:	10800417 	ldw	r2,16(r2)
   a4220:	10000626 	beq	r2,zero,a423c <close+0x74>
   a4224:	e0bffd17 	ldw	r2,-12(fp)
   a4228:	10800017 	ldw	r2,0(r2)
   a422c:	10800417 	ldw	r2,16(r2)
   a4230:	e13ffd17 	ldw	r4,-12(fp)
   a4234:	103ee83a 	callr	r2
   a4238:	00000106 	br	a4240 <close+0x78>
   a423c:	0005883a 	mov	r2,zero
   a4240:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   a4244:	e13fff17 	ldw	r4,-4(fp)
   a4248:	00a49500 	call	a4950 <alt_release_fd>
    if (rval < 0)
   a424c:	e0bffe17 	ldw	r2,-8(fp)
   a4250:	1000070e 	bge	r2,zero,a4270 <close+0xa8>
    {
      ALT_ERRNO = -rval;
   a4254:	00a418c0 	call	a418c <alt_get_errno>
   a4258:	1007883a 	mov	r3,r2
   a425c:	e0bffe17 	ldw	r2,-8(fp)
   a4260:	0085c83a 	sub	r2,zero,r2
   a4264:	18800015 	stw	r2,0(r3)
      return -1;
   a4268:	00bfffc4 	movi	r2,-1
   a426c:	00000706 	br	a428c <close+0xc4>
    }
    return 0;
   a4270:	0005883a 	mov	r2,zero
   a4274:	00000506 	br	a428c <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   a4278:	00a418c0 	call	a418c <alt_get_errno>
   a427c:	1007883a 	mov	r3,r2
   a4280:	00801444 	movi	r2,81
   a4284:	18800015 	stw	r2,0(r3)
    return -1;
   a4288:	00bfffc4 	movi	r2,-1
  }
}
   a428c:	e037883a 	mov	sp,fp
   a4290:	dfc00117 	ldw	ra,4(sp)
   a4294:	df000017 	ldw	fp,0(sp)
   a4298:	dec00204 	addi	sp,sp,8
   a429c:	f800283a 	ret

000a42a0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   a42a0:	deffff04 	addi	sp,sp,-4
   a42a4:	df000015 	stw	fp,0(sp)
   a42a8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   a42ac:	0001883a 	nop
   a42b0:	e037883a 	mov	sp,fp
   a42b4:	df000017 	ldw	fp,0(sp)
   a42b8:	dec00104 	addi	sp,sp,4
   a42bc:	f800283a 	ret

000a42c0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   a42c0:	defffc04 	addi	sp,sp,-16
   a42c4:	df000315 	stw	fp,12(sp)
   a42c8:	df000304 	addi	fp,sp,12
   a42cc:	e13ffd15 	stw	r4,-12(fp)
   a42d0:	e17ffe15 	stw	r5,-8(fp)
   a42d4:	e1bfff15 	stw	r6,-4(fp)
  return len;
   a42d8:	e0bfff17 	ldw	r2,-4(fp)
}
   a42dc:	e037883a 	mov	sp,fp
   a42e0:	df000017 	ldw	fp,0(sp)
   a42e4:	dec00104 	addi	sp,sp,4
   a42e8:	f800283a 	ret

000a42ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   a42ec:	defffe04 	addi	sp,sp,-8
   a42f0:	dfc00115 	stw	ra,4(sp)
   a42f4:	df000015 	stw	fp,0(sp)
   a42f8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   a42fc:	d0a00717 	ldw	r2,-32740(gp)
   a4300:	10000326 	beq	r2,zero,a4310 <alt_get_errno+0x24>
   a4304:	d0a00717 	ldw	r2,-32740(gp)
   a4308:	103ee83a 	callr	r2
   a430c:	00000106 	br	a4314 <alt_get_errno+0x28>
   a4310:	d0a0ed04 	addi	r2,gp,-31820
}
   a4314:	e037883a 	mov	sp,fp
   a4318:	dfc00117 	ldw	ra,4(sp)
   a431c:	df000017 	ldw	fp,0(sp)
   a4320:	dec00204 	addi	sp,sp,8
   a4324:	f800283a 	ret

000a4328 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   a4328:	defffa04 	addi	sp,sp,-24
   a432c:	dfc00515 	stw	ra,20(sp)
   a4330:	df000415 	stw	fp,16(sp)
   a4334:	df000404 	addi	fp,sp,16
   a4338:	e13ffe15 	stw	r4,-8(fp)
   a433c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   a4340:	e0bffe17 	ldw	r2,-8(fp)
   a4344:	10000326 	beq	r2,zero,a4354 <alt_dev_llist_insert+0x2c>
   a4348:	e0bffe17 	ldw	r2,-8(fp)
   a434c:	10800217 	ldw	r2,8(r2)
   a4350:	1000061e 	bne	r2,zero,a436c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
   a4354:	00a42ec0 	call	a42ec <alt_get_errno>
   a4358:	1007883a 	mov	r3,r2
   a435c:	00800584 	movi	r2,22
   a4360:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   a4364:	00bffa84 	movi	r2,-22
   a4368:	00001306 	br	a43b8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   a436c:	e0bffe17 	ldw	r2,-8(fp)
   a4370:	e0ffff17 	ldw	r3,-4(fp)
   a4374:	e0fffc15 	stw	r3,-16(fp)
   a4378:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   a437c:	e0bffd17 	ldw	r2,-12(fp)
   a4380:	e0fffc17 	ldw	r3,-16(fp)
   a4384:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   a4388:	e0bffc17 	ldw	r2,-16(fp)
   a438c:	10c00017 	ldw	r3,0(r2)
   a4390:	e0bffd17 	ldw	r2,-12(fp)
   a4394:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   a4398:	e0bffc17 	ldw	r2,-16(fp)
   a439c:	10800017 	ldw	r2,0(r2)
   a43a0:	e0fffd17 	ldw	r3,-12(fp)
   a43a4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   a43a8:	e0bffc17 	ldw	r2,-16(fp)
   a43ac:	e0fffd17 	ldw	r3,-12(fp)
   a43b0:	10c00015 	stw	r3,0(r2)

  return 0;  
   a43b4:	0005883a 	mov	r2,zero
}
   a43b8:	e037883a 	mov	sp,fp
   a43bc:	dfc00117 	ldw	ra,4(sp)
   a43c0:	df000017 	ldw	fp,0(sp)
   a43c4:	dec00204 	addi	sp,sp,8
   a43c8:	f800283a 	ret

000a43cc <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   a43cc:	deffff04 	addi	sp,sp,-4
   a43d0:	df000015 	stw	fp,0(sp)
   a43d4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   a43d8:	0001883a 	nop
   a43dc:	e037883a 	mov	sp,fp
   a43e0:	df000017 	ldw	fp,0(sp)
   a43e4:	dec00104 	addi	sp,sp,4
   a43e8:	f800283a 	ret

000a43ec <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   a43ec:	defff804 	addi	sp,sp,-32
   a43f0:	dfc00715 	stw	ra,28(sp)
   a43f4:	df000615 	stw	fp,24(sp)
   a43f8:	dc000515 	stw	r16,20(sp)
   a43fc:	df000604 	addi	fp,sp,24
   a4400:	e13ffb15 	stw	r4,-20(fp)
   a4404:	e17ffc15 	stw	r5,-16(fp)
   a4408:	e1bffd15 	stw	r6,-12(fp)
   a440c:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
   a4410:	e1bffe17 	ldw	r6,-8(fp)
   a4414:	e17ffd17 	ldw	r5,-12(fp)
   a4418:	e13ffc17 	ldw	r4,-16(fp)
   a441c:	00a47f40 	call	a47f4 <open>
   a4420:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
   a4424:	e0bffa17 	ldw	r2,-24(fp)
   a4428:	10002216 	blt	r2,zero,a44b4 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
   a442c:	040002b4 	movhi	r16,10
   a4430:	8415b204 	addi	r16,r16,22216
   a4434:	e0bffa17 	ldw	r2,-24(fp)
   a4438:	01400304 	movi	r5,12
   a443c:	1009883a 	mov	r4,r2
   a4440:	00a1acc0 	call	a1acc <__mulsi3>
   a4444:	8085883a 	add	r2,r16,r2
   a4448:	10c00017 	ldw	r3,0(r2)
   a444c:	e0bffb17 	ldw	r2,-20(fp)
   a4450:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   a4454:	040002b4 	movhi	r16,10
   a4458:	8415b204 	addi	r16,r16,22216
   a445c:	e0bffa17 	ldw	r2,-24(fp)
   a4460:	01400304 	movi	r5,12
   a4464:	1009883a 	mov	r4,r2
   a4468:	00a1acc0 	call	a1acc <__mulsi3>
   a446c:	8085883a 	add	r2,r16,r2
   a4470:	10800104 	addi	r2,r2,4
   a4474:	10c00017 	ldw	r3,0(r2)
   a4478:	e0bffb17 	ldw	r2,-20(fp)
   a447c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   a4480:	040002b4 	movhi	r16,10
   a4484:	8415b204 	addi	r16,r16,22216
   a4488:	e0bffa17 	ldw	r2,-24(fp)
   a448c:	01400304 	movi	r5,12
   a4490:	1009883a 	mov	r4,r2
   a4494:	00a1acc0 	call	a1acc <__mulsi3>
   a4498:	8085883a 	add	r2,r16,r2
   a449c:	10800204 	addi	r2,r2,8
   a44a0:	10c00017 	ldw	r3,0(r2)
   a44a4:	e0bffb17 	ldw	r2,-20(fp)
   a44a8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   a44ac:	e13ffa17 	ldw	r4,-24(fp)
   a44b0:	00a49500 	call	a4950 <alt_release_fd>
  }
} 
   a44b4:	0001883a 	nop
   a44b8:	e6ffff04 	addi	sp,fp,-4
   a44bc:	dfc00217 	ldw	ra,8(sp)
   a44c0:	df000117 	ldw	fp,4(sp)
   a44c4:	dc000017 	ldw	r16,0(sp)
   a44c8:	dec00304 	addi	sp,sp,12
   a44cc:	f800283a 	ret

000a44d0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   a44d0:	defffb04 	addi	sp,sp,-20
   a44d4:	dfc00415 	stw	ra,16(sp)
   a44d8:	df000315 	stw	fp,12(sp)
   a44dc:	df000304 	addi	fp,sp,12
   a44e0:	e13ffd15 	stw	r4,-12(fp)
   a44e4:	e17ffe15 	stw	r5,-8(fp)
   a44e8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   a44ec:	01c07fc4 	movi	r7,511
   a44f0:	01800044 	movi	r6,1
   a44f4:	e17ffd17 	ldw	r5,-12(fp)
   a44f8:	010002b4 	movhi	r4,10
   a44fc:	2115b504 	addi	r4,r4,22228
   a4500:	00a43ec0 	call	a43ec <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   a4504:	01c07fc4 	movi	r7,511
   a4508:	000d883a 	mov	r6,zero
   a450c:	e17ffe17 	ldw	r5,-8(fp)
   a4510:	010002b4 	movhi	r4,10
   a4514:	2115b204 	addi	r4,r4,22216
   a4518:	00a43ec0 	call	a43ec <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   a451c:	01c07fc4 	movi	r7,511
   a4520:	01800044 	movi	r6,1
   a4524:	e17fff17 	ldw	r5,-4(fp)
   a4528:	010002b4 	movhi	r4,10
   a452c:	2115b804 	addi	r4,r4,22240
   a4530:	00a43ec0 	call	a43ec <alt_open_fd>
}  
   a4534:	0001883a 	nop
   a4538:	e037883a 	mov	sp,fp
   a453c:	dfc00117 	ldw	ra,4(sp)
   a4540:	df000017 	ldw	fp,0(sp)
   a4544:	dec00204 	addi	sp,sp,8
   a4548:	f800283a 	ret

000a454c <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
   a454c:	defff004 	addi	sp,sp,-64
   a4550:	df000f15 	stw	fp,60(sp)
   a4554:	df000f04 	addi	fp,sp,60
   a4558:	e13ffd15 	stw	r4,-12(fp)
   a455c:	e17ffe15 	stw	r5,-8(fp)
   a4560:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
   a4564:	00bffa84 	movi	r2,-22
   a4568:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   a456c:	e0bffd17 	ldw	r2,-12(fp)
   a4570:	10800828 	cmpgeui	r2,r2,32
   a4574:	1000501e 	bne	r2,zero,a46b8 <alt_irq_register+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   a4578:	0005303a 	rdctl	r2,status
   a457c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   a4580:	e0fff617 	ldw	r3,-40(fp)
   a4584:	00bfff84 	movi	r2,-2
   a4588:	1884703a 	and	r2,r3,r2
   a458c:	1001703a 	wrctl	status,r2
  
  return context;
   a4590:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
   a4594:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
   a4598:	008002b4 	movhi	r2,10
   a459c:	109c0704 	addi	r2,r2,28700
   a45a0:	e0fffd17 	ldw	r3,-12(fp)
   a45a4:	180690fa 	slli	r3,r3,3
   a45a8:	10c5883a 	add	r2,r2,r3
   a45ac:	e0ffff17 	ldw	r3,-4(fp)
   a45b0:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
   a45b4:	008002b4 	movhi	r2,10
   a45b8:	109c0704 	addi	r2,r2,28700
   a45bc:	e0fffd17 	ldw	r3,-12(fp)
   a45c0:	180690fa 	slli	r3,r3,3
   a45c4:	10c5883a 	add	r2,r2,r3
   a45c8:	10800104 	addi	r2,r2,4
   a45cc:	e0fffe17 	ldw	r3,-8(fp)
   a45d0:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
   a45d4:	e0bfff17 	ldw	r2,-4(fp)
   a45d8:	10001926 	beq	r2,zero,a4640 <alt_irq_register+0xf4>
   a45dc:	e0bffd17 	ldw	r2,-12(fp)
   a45e0:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   a45e4:	0005303a 	rdctl	r2,status
   a45e8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   a45ec:	e0fff717 	ldw	r3,-36(fp)
   a45f0:	00bfff84 	movi	r2,-2
   a45f4:	1884703a 	and	r2,r3,r2
   a45f8:	1001703a 	wrctl	status,r2
  
  return context;
   a45fc:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   a4600:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
   a4604:	00c00044 	movi	r3,1
   a4608:	e0bff217 	ldw	r2,-56(fp)
   a460c:	1884983a 	sll	r2,r3,r2
   a4610:	1007883a 	mov	r3,r2
   a4614:	d0a0f417 	ldw	r2,-31792(gp)
   a4618:	1884b03a 	or	r2,r3,r2
   a461c:	d0a0f415 	stw	r2,-31792(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   a4620:	d0a0f417 	ldw	r2,-31792(gp)
   a4624:	100170fa 	wrctl	ienable,r2
   a4628:	e0bff817 	ldw	r2,-32(fp)
   a462c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   a4630:	e0bff917 	ldw	r2,-28(fp)
   a4634:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   a4638:	0005883a 	mov	r2,zero
   a463c:	00001906 	br	a46a4 <alt_irq_register+0x158>
   a4640:	e0bffd17 	ldw	r2,-12(fp)
   a4644:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   a4648:	0005303a 	rdctl	r2,status
   a464c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   a4650:	e0fffa17 	ldw	r3,-24(fp)
   a4654:	00bfff84 	movi	r2,-2
   a4658:	1884703a 	and	r2,r3,r2
   a465c:	1001703a 	wrctl	status,r2
  
  return context;
   a4660:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   a4664:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
   a4668:	00c00044 	movi	r3,1
   a466c:	e0bff417 	ldw	r2,-48(fp)
   a4670:	1884983a 	sll	r2,r3,r2
   a4674:	0084303a 	nor	r2,zero,r2
   a4678:	1007883a 	mov	r3,r2
   a467c:	d0a0f417 	ldw	r2,-31792(gp)
   a4680:	1884703a 	and	r2,r3,r2
   a4684:	d0a0f415 	stw	r2,-31792(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   a4688:	d0a0f417 	ldw	r2,-31792(gp)
   a468c:	100170fa 	wrctl	ienable,r2
   a4690:	e0bffb17 	ldw	r2,-20(fp)
   a4694:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   a4698:	e0bffc17 	ldw	r2,-16(fp)
   a469c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   a46a0:	0005883a 	mov	r2,zero
   a46a4:	e0bff115 	stw	r2,-60(fp)
   a46a8:	e0bff317 	ldw	r2,-52(fp)
   a46ac:	e0bff515 	stw	r2,-44(fp)
   a46b0:	e0bff517 	ldw	r2,-44(fp)
   a46b4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
   a46b8:	e0bff117 	ldw	r2,-60(fp)
}
   a46bc:	e037883a 	mov	sp,fp
   a46c0:	df000017 	ldw	fp,0(sp)
   a46c4:	dec00104 	addi	sp,sp,4
   a46c8:	f800283a 	ret

000a46cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   a46cc:	defffe04 	addi	sp,sp,-8
   a46d0:	dfc00115 	stw	ra,4(sp)
   a46d4:	df000015 	stw	fp,0(sp)
   a46d8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   a46dc:	d0a00717 	ldw	r2,-32740(gp)
   a46e0:	10000326 	beq	r2,zero,a46f0 <alt_get_errno+0x24>
   a46e4:	d0a00717 	ldw	r2,-32740(gp)
   a46e8:	103ee83a 	callr	r2
   a46ec:	00000106 	br	a46f4 <alt_get_errno+0x28>
   a46f0:	d0a0ed04 	addi	r2,gp,-31820
}
   a46f4:	e037883a 	mov	sp,fp
   a46f8:	dfc00117 	ldw	ra,4(sp)
   a46fc:	df000017 	ldw	fp,0(sp)
   a4700:	dec00204 	addi	sp,sp,8
   a4704:	f800283a 	ret

000a4708 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   a4708:	defffb04 	addi	sp,sp,-20
   a470c:	dfc00415 	stw	ra,16(sp)
   a4710:	df000315 	stw	fp,12(sp)
   a4714:	dc000215 	stw	r16,8(sp)
   a4718:	df000304 	addi	fp,sp,12
   a471c:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   a4720:	e0bffe17 	ldw	r2,-8(fp)
   a4724:	10800217 	ldw	r2,8(r2)
   a4728:	10d00034 	orhi	r3,r2,16384
   a472c:	e0bffe17 	ldw	r2,-8(fp)
   a4730:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   a4734:	e03ffd15 	stw	zero,-12(fp)
   a4738:	00002306 	br	a47c8 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   a473c:	040002b4 	movhi	r16,10
   a4740:	8415b204 	addi	r16,r16,22216
   a4744:	e0bffd17 	ldw	r2,-12(fp)
   a4748:	01400304 	movi	r5,12
   a474c:	1009883a 	mov	r4,r2
   a4750:	00a1acc0 	call	a1acc <__mulsi3>
   a4754:	8085883a 	add	r2,r16,r2
   a4758:	10c00017 	ldw	r3,0(r2)
   a475c:	e0bffe17 	ldw	r2,-8(fp)
   a4760:	10800017 	ldw	r2,0(r2)
   a4764:	1880151e 	bne	r3,r2,a47bc <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   a4768:	040002b4 	movhi	r16,10
   a476c:	8415b204 	addi	r16,r16,22216
   a4770:	e0bffd17 	ldw	r2,-12(fp)
   a4774:	01400304 	movi	r5,12
   a4778:	1009883a 	mov	r4,r2
   a477c:	00a1acc0 	call	a1acc <__mulsi3>
   a4780:	8085883a 	add	r2,r16,r2
   a4784:	10800204 	addi	r2,r2,8
   a4788:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   a478c:	10000b0e 	bge	r2,zero,a47bc <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   a4790:	01400304 	movi	r5,12
   a4794:	e13ffd17 	ldw	r4,-12(fp)
   a4798:	00a1acc0 	call	a1acc <__mulsi3>
   a479c:	1007883a 	mov	r3,r2
   a47a0:	008002b4 	movhi	r2,10
   a47a4:	1095b204 	addi	r2,r2,22216
   a47a8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   a47ac:	e0bffe17 	ldw	r2,-8(fp)
   a47b0:	18800226 	beq	r3,r2,a47bc <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   a47b4:	00bffcc4 	movi	r2,-13
   a47b8:	00000806 	br	a47dc <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   a47bc:	e0bffd17 	ldw	r2,-12(fp)
   a47c0:	10800044 	addi	r2,r2,1
   a47c4:	e0bffd15 	stw	r2,-12(fp)
   a47c8:	d0a00617 	ldw	r2,-32744(gp)
   a47cc:	1007883a 	mov	r3,r2
   a47d0:	e0bffd17 	ldw	r2,-12(fp)
   a47d4:	18bfd92e 	bgeu	r3,r2,a473c <__alt_data_end+0xfffe473c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   a47d8:	0005883a 	mov	r2,zero
}
   a47dc:	e6ffff04 	addi	sp,fp,-4
   a47e0:	dfc00217 	ldw	ra,8(sp)
   a47e4:	df000117 	ldw	fp,4(sp)
   a47e8:	dc000017 	ldw	r16,0(sp)
   a47ec:	dec00304 	addi	sp,sp,12
   a47f0:	f800283a 	ret

000a47f4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   a47f4:	defff604 	addi	sp,sp,-40
   a47f8:	dfc00915 	stw	ra,36(sp)
   a47fc:	df000815 	stw	fp,32(sp)
   a4800:	df000804 	addi	fp,sp,32
   a4804:	e13ffd15 	stw	r4,-12(fp)
   a4808:	e17ffe15 	stw	r5,-8(fp)
   a480c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   a4810:	00bfffc4 	movi	r2,-1
   a4814:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   a4818:	00bffb44 	movi	r2,-19
   a481c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   a4820:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   a4824:	d1600404 	addi	r5,gp,-32752
   a4828:	e13ffd17 	ldw	r4,-12(fp)
   a482c:	00a4ae80 	call	a4ae8 <alt_find_dev>
   a4830:	e0bff815 	stw	r2,-32(fp)
   a4834:	e0bff817 	ldw	r2,-32(fp)
   a4838:	1000051e 	bne	r2,zero,a4850 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   a483c:	e13ffd17 	ldw	r4,-12(fp)
   a4840:	00a4b780 	call	a4b78 <alt_find_file>
   a4844:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   a4848:	00800044 	movi	r2,1
   a484c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   a4850:	e0bff817 	ldw	r2,-32(fp)
   a4854:	10002b26 	beq	r2,zero,a4904 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
   a4858:	e13ff817 	ldw	r4,-32(fp)
   a485c:	00a4c800 	call	a4c80 <alt_get_fd>
   a4860:	e0bff915 	stw	r2,-28(fp)
   a4864:	e0bff917 	ldw	r2,-28(fp)
   a4868:	1000030e 	bge	r2,zero,a4878 <open+0x84>
    {
      status = index;
   a486c:	e0bff917 	ldw	r2,-28(fp)
   a4870:	e0bffa15 	stw	r2,-24(fp)
   a4874:	00002506 	br	a490c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
   a4878:	01400304 	movi	r5,12
   a487c:	e13ff917 	ldw	r4,-28(fp)
   a4880:	00a1acc0 	call	a1acc <__mulsi3>
   a4884:	1007883a 	mov	r3,r2
   a4888:	008002b4 	movhi	r2,10
   a488c:	1095b204 	addi	r2,r2,22216
   a4890:	1885883a 	add	r2,r3,r2
   a4894:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   a4898:	e0fffe17 	ldw	r3,-8(fp)
   a489c:	00900034 	movhi	r2,16384
   a48a0:	10bfffc4 	addi	r2,r2,-1
   a48a4:	1886703a 	and	r3,r3,r2
   a48a8:	e0bffc17 	ldw	r2,-16(fp)
   a48ac:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   a48b0:	e0bffb17 	ldw	r2,-20(fp)
   a48b4:	1000051e 	bne	r2,zero,a48cc <open+0xd8>
   a48b8:	e13ffc17 	ldw	r4,-16(fp)
   a48bc:	00a47080 	call	a4708 <alt_file_locked>
   a48c0:	e0bffa15 	stw	r2,-24(fp)
   a48c4:	e0bffa17 	ldw	r2,-24(fp)
   a48c8:	10001016 	blt	r2,zero,a490c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   a48cc:	e0bff817 	ldw	r2,-32(fp)
   a48d0:	10800317 	ldw	r2,12(r2)
   a48d4:	10000826 	beq	r2,zero,a48f8 <open+0x104>
   a48d8:	e0bff817 	ldw	r2,-32(fp)
   a48dc:	10800317 	ldw	r2,12(r2)
   a48e0:	e1ffff17 	ldw	r7,-4(fp)
   a48e4:	e1bffe17 	ldw	r6,-8(fp)
   a48e8:	e17ffd17 	ldw	r5,-12(fp)
   a48ec:	e13ffc17 	ldw	r4,-16(fp)
   a48f0:	103ee83a 	callr	r2
   a48f4:	00000106 	br	a48fc <open+0x108>
   a48f8:	0005883a 	mov	r2,zero
   a48fc:	e0bffa15 	stw	r2,-24(fp)
   a4900:	00000206 	br	a490c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
   a4904:	00bffb44 	movi	r2,-19
   a4908:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   a490c:	e0bffa17 	ldw	r2,-24(fp)
   a4910:	1000090e 	bge	r2,zero,a4938 <open+0x144>
  {
    alt_release_fd (index);  
   a4914:	e13ff917 	ldw	r4,-28(fp)
   a4918:	00a49500 	call	a4950 <alt_release_fd>
    ALT_ERRNO = -status;
   a491c:	00a46cc0 	call	a46cc <alt_get_errno>
   a4920:	1007883a 	mov	r3,r2
   a4924:	e0bffa17 	ldw	r2,-24(fp)
   a4928:	0085c83a 	sub	r2,zero,r2
   a492c:	18800015 	stw	r2,0(r3)
    return -1;
   a4930:	00bfffc4 	movi	r2,-1
   a4934:	00000106 	br	a493c <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
   a4938:	e0bff917 	ldw	r2,-28(fp)
}
   a493c:	e037883a 	mov	sp,fp
   a4940:	dfc00117 	ldw	ra,4(sp)
   a4944:	df000017 	ldw	fp,0(sp)
   a4948:	dec00204 	addi	sp,sp,8
   a494c:	f800283a 	ret

000a4950 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   a4950:	defffc04 	addi	sp,sp,-16
   a4954:	dfc00315 	stw	ra,12(sp)
   a4958:	df000215 	stw	fp,8(sp)
   a495c:	dc000115 	stw	r16,4(sp)
   a4960:	df000204 	addi	fp,sp,8
   a4964:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
   a4968:	e0bffe17 	ldw	r2,-8(fp)
   a496c:	108000d0 	cmplti	r2,r2,3
   a4970:	1000111e 	bne	r2,zero,a49b8 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
   a4974:	040002b4 	movhi	r16,10
   a4978:	8415b204 	addi	r16,r16,22216
   a497c:	e0bffe17 	ldw	r2,-8(fp)
   a4980:	01400304 	movi	r5,12
   a4984:	1009883a 	mov	r4,r2
   a4988:	00a1acc0 	call	a1acc <__mulsi3>
   a498c:	8085883a 	add	r2,r16,r2
   a4990:	10800204 	addi	r2,r2,8
   a4994:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   a4998:	040002b4 	movhi	r16,10
   a499c:	8415b204 	addi	r16,r16,22216
   a49a0:	e0bffe17 	ldw	r2,-8(fp)
   a49a4:	01400304 	movi	r5,12
   a49a8:	1009883a 	mov	r4,r2
   a49ac:	00a1acc0 	call	a1acc <__mulsi3>
   a49b0:	8085883a 	add	r2,r16,r2
   a49b4:	10000015 	stw	zero,0(r2)
  }
}
   a49b8:	0001883a 	nop
   a49bc:	e6ffff04 	addi	sp,fp,-4
   a49c0:	dfc00217 	ldw	ra,8(sp)
   a49c4:	df000117 	ldw	fp,4(sp)
   a49c8:	dc000017 	ldw	r16,0(sp)
   a49cc:	dec00304 	addi	sp,sp,12
   a49d0:	f800283a 	ret

000a49d4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   a49d4:	deffff04 	addi	sp,sp,-4
   a49d8:	df000015 	stw	fp,0(sp)
   a49dc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   a49e0:	000170fa 	wrctl	ienable,zero
}
   a49e4:	0001883a 	nop
   a49e8:	e037883a 	mov	sp,fp
   a49ec:	df000017 	ldw	fp,0(sp)
   a49f0:	dec00104 	addi	sp,sp,4
   a49f4:	f800283a 	ret

000a49f8 <upper_char_line>:
		0x18187000, // }
		0x00000000, // ~
};

alt_u32 upper_char_line(const alt_u8 char_pos)
{
   a49f8:	defffe04 	addi	sp,sp,-8
   a49fc:	df000115 	stw	fp,4(sp)
   a4a00:	df000104 	addi	fp,sp,4
   a4a04:	2005883a 	mov	r2,r4
   a4a08:	e0bfff05 	stb	r2,-4(fp)
	return font32upper[char_pos];
   a4a0c:	e0ffff03 	ldbu	r3,-4(fp)
   a4a10:	008002b4 	movhi	r2,10
   a4a14:	10947f04 	addi	r2,r2,20988
   a4a18:	18c7883a 	add	r3,r3,r3
   a4a1c:	18c7883a 	add	r3,r3,r3
   a4a20:	10c5883a 	add	r2,r2,r3
   a4a24:	10800017 	ldw	r2,0(r2)
};
   a4a28:	e037883a 	mov	sp,fp
   a4a2c:	df000017 	ldw	fp,0(sp)
   a4a30:	dec00104 	addi	sp,sp,4
   a4a34:	f800283a 	ret

000a4a38 <lower_char_line>:

alt_u32 lower_char_line(const alt_u8 char_pos)
{
   a4a38:	defffe04 	addi	sp,sp,-8
   a4a3c:	df000115 	stw	fp,4(sp)
   a4a40:	df000104 	addi	fp,sp,4
   a4a44:	2005883a 	mov	r2,r4
   a4a48:	e0bfff05 	stb	r2,-4(fp)
	return font32lower[char_pos];
   a4a4c:	e0ffff03 	ldbu	r3,-4(fp)
   a4a50:	008002b4 	movhi	r2,10
   a4a54:	1094de04 	addi	r2,r2,21368
   a4a58:	18c7883a 	add	r3,r3,r3
   a4a5c:	18c7883a 	add	r3,r3,r3
   a4a60:	10c5883a 	add	r2,r2,r3
   a4a64:	10800017 	ldw	r2,0(r2)
   a4a68:	e037883a 	mov	sp,fp
   a4a6c:	df000017 	ldw	fp,0(sp)
   a4a70:	dec00104 	addi	sp,sp,4
   a4a74:	f800283a 	ret

000a4a78 <HW_CTX_SWITCH>:
	  context switch routine
	**********************************************/

/* registers have been saved into running tcb in exception entry handler */
HW_CTX_SWITCH:
	br gettask
   a4a78:	00000006 	br	a4a7c <gettask>

000a4a7c <gettask>:

gettask:
   	call get_next_task //call c-function and return here
   a4a7c:	00a30740 	call	a3074 <get_next_task>
	br restore_context
   a4a80:	00000006 	br	a4a84 <restore_context>

000a4a84 <restore_context>:
   a4a84:	004002b4 	movhi	at,10
	
restore_context:
	
	movia	at, current_tcb			# at=current_tcb
   a4a88:	08570404 	addi	at,at,23568
	ldwio   at, 0(at)				# Get address to current_tcb variable
   a4a8c:	08400037 	ldwio	at,0(at)
 
   	/* re-store r1 (at) last */
	ldwio	r2, TCB_REG_RETURNVALUES+0(at)	
   a4a90:	08800337 	ldwio	r2,12(at)
   	ldwio	r3, TCB_REG_RETURNVALUES+4(at)
   a4a94:	08c00437 	ldwio	r3,16(at)
    
   	ldwio	r4, TCB_REG_ARG+0(at)
   a4a98:	09000537 	ldwio	r4,20(at)
   	ldwio	r5, TCB_REG_ARG+4(at)
   a4a9c:	09400637 	ldwio	r5,24(at)
   	   	
   	ldwio	r6, TCB_REG_ARG+8(at)
   a4aa0:	09800737 	ldwio	r6,28(at)
	ldwio 	r7, TCB_REG_ARG+12(at)
   a4aa4:	09c00837 	ldwio	r7,32(at)
	
	ldwio	r8, TCB_REG_GPR+0(at)
   a4aa8:	0a000937 	ldwio	r8,36(at)
	ldwio	r9, TCB_REG_GPR+4(at)
   a4aac:	0a400a37 	ldwio	r9,40(at)
	ldwio	r10, TCB_REG_GPR+8(at)
   a4ab0:	0a800b37 	ldwio	r10,44(at)
	ldwio	r11, TCB_REG_GPR+12(at)
   a4ab4:	0ac00c37 	ldwio	r11,48(at)
	ldwio	r12, TCB_REG_GPR+16(at)
   a4ab8:	0b000d37 	ldwio	r12,52(at)
	ldwio	r13, TCB_REG_GPR+20(at)
   a4abc:	0b400e37 	ldwio	r13,56(at)
	ldwio	r14, TCB_REG_GPR+24(at)
   a4ac0:	0b800f37 	ldwio	r14,60(at)
	ldwio	r15, TCB_REG_GPR+28(at)
   a4ac4:	0bc01037 	ldwio	r15,64(at)
	#ldwio	r21, TCB_REG_GPR+52(at)
	#ldwio	r22, TCB_REG_GPR+56(at)
	#ldwio	r23, TCB_REG_GPR+60(at)
	/* r24, r25, r26 not affected */

	ldwio	sp, TCB_STACKPTR(at) # r27 stack pointer 
   a4ac8:	0ec01e37 	ldwio	sp,120(at)
	ldwio	fp, TCB_REG_FP(at)	 # r28 fram pointer
   a4acc:	0f001b37 	ldwio	fp,108(at)
	ldwio	ea, TCB_REG_EA(at)   # r29 return address from interrupt
   a4ad0:	0f401c37 	ldwio	ea,112(at)
	
	/* r30 not affected */
	
	ldwio	ra, TCB_REG_RA(at) # r31
   a4ad4:	0fc01d37 	ldwio	ra,116(at)
	ldwio	at, TCB_REG_AT(at)
   a4ad8:	08400237 	ldwio	at,8(at)
		
   	/* Jump to new task, adr in ea */
	eret 	# return from exception
   a4adc:	ef80083a 	eret

000a4ae0 <SW_CTX_SWITCH>:


/* registers have been saved into running tcb in exception entry handler */	
SW_CTX_SWITCH:
	/*** Get new task id ***/
	call get_new_task
   a4ae0:	00a31e40 	call	a31e4 <get_new_task>
	
	br restore_context
   a4ae4:	003fe706 	br	a4a84 <__alt_data_end+0xfffe4a84>

000a4ae8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   a4ae8:	defffa04 	addi	sp,sp,-24
   a4aec:	dfc00515 	stw	ra,20(sp)
   a4af0:	df000415 	stw	fp,16(sp)
   a4af4:	df000404 	addi	fp,sp,16
   a4af8:	e13ffe15 	stw	r4,-8(fp)
   a4afc:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   a4b00:	e0bfff17 	ldw	r2,-4(fp)
   a4b04:	10800017 	ldw	r2,0(r2)
   a4b08:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   a4b0c:	e13ffe17 	ldw	r4,-8(fp)
   a4b10:	00a13ec0 	call	a13ec <strlen>
   a4b14:	10800044 	addi	r2,r2,1
   a4b18:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   a4b1c:	00000d06 	br	a4b54 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   a4b20:	e0bffc17 	ldw	r2,-16(fp)
   a4b24:	10800217 	ldw	r2,8(r2)
   a4b28:	e0fffd17 	ldw	r3,-12(fp)
   a4b2c:	180d883a 	mov	r6,r3
   a4b30:	e17ffe17 	ldw	r5,-8(fp)
   a4b34:	1009883a 	mov	r4,r2
   a4b38:	00a4d640 	call	a4d64 <memcmp>
   a4b3c:	1000021e 	bne	r2,zero,a4b48 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   a4b40:	e0bffc17 	ldw	r2,-16(fp)
   a4b44:	00000706 	br	a4b64 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   a4b48:	e0bffc17 	ldw	r2,-16(fp)
   a4b4c:	10800017 	ldw	r2,0(r2)
   a4b50:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   a4b54:	e0fffc17 	ldw	r3,-16(fp)
   a4b58:	e0bfff17 	ldw	r2,-4(fp)
   a4b5c:	18bff01e 	bne	r3,r2,a4b20 <__alt_data_end+0xfffe4b20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   a4b60:	0005883a 	mov	r2,zero
}
   a4b64:	e037883a 	mov	sp,fp
   a4b68:	dfc00117 	ldw	ra,4(sp)
   a4b6c:	df000017 	ldw	fp,0(sp)
   a4b70:	dec00204 	addi	sp,sp,8
   a4b74:	f800283a 	ret

000a4b78 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   a4b78:	defffb04 	addi	sp,sp,-20
   a4b7c:	dfc00415 	stw	ra,16(sp)
   a4b80:	df000315 	stw	fp,12(sp)
   a4b84:	df000304 	addi	fp,sp,12
   a4b88:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   a4b8c:	d0a00217 	ldw	r2,-32760(gp)
   a4b90:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   a4b94:	00003106 	br	a4c5c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   a4b98:	e0bffd17 	ldw	r2,-12(fp)
   a4b9c:	10800217 	ldw	r2,8(r2)
   a4ba0:	1009883a 	mov	r4,r2
   a4ba4:	00a13ec0 	call	a13ec <strlen>
   a4ba8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   a4bac:	e0bffd17 	ldw	r2,-12(fp)
   a4bb0:	10c00217 	ldw	r3,8(r2)
   a4bb4:	e0bffe17 	ldw	r2,-8(fp)
   a4bb8:	10bfffc4 	addi	r2,r2,-1
   a4bbc:	1885883a 	add	r2,r3,r2
   a4bc0:	10800003 	ldbu	r2,0(r2)
   a4bc4:	10803fcc 	andi	r2,r2,255
   a4bc8:	1080201c 	xori	r2,r2,128
   a4bcc:	10bfe004 	addi	r2,r2,-128
   a4bd0:	10800bd8 	cmpnei	r2,r2,47
   a4bd4:	1000031e 	bne	r2,zero,a4be4 <alt_find_file+0x6c>
    {
      len -= 1;
   a4bd8:	e0bffe17 	ldw	r2,-8(fp)
   a4bdc:	10bfffc4 	addi	r2,r2,-1
   a4be0:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   a4be4:	e0bffe17 	ldw	r2,-8(fp)
   a4be8:	e0ffff17 	ldw	r3,-4(fp)
   a4bec:	1885883a 	add	r2,r3,r2
   a4bf0:	10800003 	ldbu	r2,0(r2)
   a4bf4:	10803fcc 	andi	r2,r2,255
   a4bf8:	1080201c 	xori	r2,r2,128
   a4bfc:	10bfe004 	addi	r2,r2,-128
   a4c00:	10800be0 	cmpeqi	r2,r2,47
   a4c04:	1000081e 	bne	r2,zero,a4c28 <alt_find_file+0xb0>
   a4c08:	e0bffe17 	ldw	r2,-8(fp)
   a4c0c:	e0ffff17 	ldw	r3,-4(fp)
   a4c10:	1885883a 	add	r2,r3,r2
   a4c14:	10800003 	ldbu	r2,0(r2)
   a4c18:	10803fcc 	andi	r2,r2,255
   a4c1c:	1080201c 	xori	r2,r2,128
   a4c20:	10bfe004 	addi	r2,r2,-128
   a4c24:	10000a1e 	bne	r2,zero,a4c50 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   a4c28:	e0bffd17 	ldw	r2,-12(fp)
   a4c2c:	10800217 	ldw	r2,8(r2)
   a4c30:	e0fffe17 	ldw	r3,-8(fp)
   a4c34:	180d883a 	mov	r6,r3
   a4c38:	e17fff17 	ldw	r5,-4(fp)
   a4c3c:	1009883a 	mov	r4,r2
   a4c40:	00a4d640 	call	a4d64 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   a4c44:	1000021e 	bne	r2,zero,a4c50 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   a4c48:	e0bffd17 	ldw	r2,-12(fp)
   a4c4c:	00000706 	br	a4c6c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   a4c50:	e0bffd17 	ldw	r2,-12(fp)
   a4c54:	10800017 	ldw	r2,0(r2)
   a4c58:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   a4c5c:	e0fffd17 	ldw	r3,-12(fp)
   a4c60:	d0a00204 	addi	r2,gp,-32760
   a4c64:	18bfcc1e 	bne	r3,r2,a4b98 <__alt_data_end+0xfffe4b98>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   a4c68:	0005883a 	mov	r2,zero
}
   a4c6c:	e037883a 	mov	sp,fp
   a4c70:	dfc00117 	ldw	ra,4(sp)
   a4c74:	df000017 	ldw	fp,0(sp)
   a4c78:	dec00204 	addi	sp,sp,8
   a4c7c:	f800283a 	ret

000a4c80 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   a4c80:	defffa04 	addi	sp,sp,-24
   a4c84:	dfc00515 	stw	ra,20(sp)
   a4c88:	df000415 	stw	fp,16(sp)
   a4c8c:	dc000315 	stw	r16,12(sp)
   a4c90:	df000404 	addi	fp,sp,16
   a4c94:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
   a4c98:	00bffa04 	movi	r2,-24
   a4c9c:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   a4ca0:	e03ffc15 	stw	zero,-16(fp)
   a4ca4:	00001d06 	br	a4d1c <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
   a4ca8:	040002b4 	movhi	r16,10
   a4cac:	8415b204 	addi	r16,r16,22216
   a4cb0:	e0bffc17 	ldw	r2,-16(fp)
   a4cb4:	01400304 	movi	r5,12
   a4cb8:	1009883a 	mov	r4,r2
   a4cbc:	00a1acc0 	call	a1acc <__mulsi3>
   a4cc0:	8085883a 	add	r2,r16,r2
   a4cc4:	10800017 	ldw	r2,0(r2)
   a4cc8:	1000111e 	bne	r2,zero,a4d10 <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
   a4ccc:	040002b4 	movhi	r16,10
   a4cd0:	8415b204 	addi	r16,r16,22216
   a4cd4:	e0bffc17 	ldw	r2,-16(fp)
   a4cd8:	01400304 	movi	r5,12
   a4cdc:	1009883a 	mov	r4,r2
   a4ce0:	00a1acc0 	call	a1acc <__mulsi3>
   a4ce4:	8085883a 	add	r2,r16,r2
   a4ce8:	e0fffe17 	ldw	r3,-8(fp)
   a4cec:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   a4cf0:	d0e00617 	ldw	r3,-32744(gp)
   a4cf4:	e0bffc17 	ldw	r2,-16(fp)
   a4cf8:	1880020e 	bge	r3,r2,a4d04 <alt_get_fd+0x84>
      {
        alt_max_fd = i;
   a4cfc:	e0bffc17 	ldw	r2,-16(fp)
   a4d00:	d0a00615 	stw	r2,-32744(gp)
      }
      rc = i;
   a4d04:	e0bffc17 	ldw	r2,-16(fp)
   a4d08:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
   a4d0c:	00000606 	br	a4d28 <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   a4d10:	e0bffc17 	ldw	r2,-16(fp)
   a4d14:	10800044 	addi	r2,r2,1
   a4d18:	e0bffc15 	stw	r2,-16(fp)
   a4d1c:	e0bffc17 	ldw	r2,-16(fp)
   a4d20:	10800810 	cmplti	r2,r2,32
   a4d24:	103fe01e 	bne	r2,zero,a4ca8 <__alt_data_end+0xfffe4ca8>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   a4d28:	e0bffd17 	ldw	r2,-12(fp)
}
   a4d2c:	e6ffff04 	addi	sp,fp,-4
   a4d30:	dfc00217 	ldw	ra,8(sp)
   a4d34:	df000117 	ldw	fp,4(sp)
   a4d38:	dc000017 	ldw	r16,0(sp)
   a4d3c:	dec00304 	addi	sp,sp,12
   a4d40:	f800283a 	ret

000a4d44 <exit>:
   a4d44:	defffe04 	addi	sp,sp,-8
   a4d48:	000b883a 	mov	r5,zero
   a4d4c:	dc000015 	stw	r16,0(sp)
   a4d50:	dfc00115 	stw	ra,4(sp)
   a4d54:	2021883a 	mov	r16,r4
   a4d58:	00a4d940 	call	a4d94 <__call_exitprocs>
   a4d5c:	8009883a 	mov	r4,r16
   a4d60:	00a4f240 	call	a4f24 <_exit>

000a4d64 <memcmp>:
   a4d64:	218d883a 	add	r6,r4,r6
   a4d68:	21800826 	beq	r4,r6,a4d8c <memcmp+0x28>
   a4d6c:	20800003 	ldbu	r2,0(r4)
   a4d70:	28c00003 	ldbu	r3,0(r5)
   a4d74:	10c00226 	beq	r2,r3,a4d80 <memcmp+0x1c>
   a4d78:	10c5c83a 	sub	r2,r2,r3
   a4d7c:	f800283a 	ret
   a4d80:	21000044 	addi	r4,r4,1
   a4d84:	29400044 	addi	r5,r5,1
   a4d88:	003ff706 	br	a4d68 <__alt_data_end+0xfffe4d68>
   a4d8c:	0005883a 	mov	r2,zero
   a4d90:	f800283a 	ret

000a4d94 <__call_exitprocs>:
   a4d94:	defff504 	addi	sp,sp,-44
   a4d98:	dd000515 	stw	r20,20(sp)
   a4d9c:	050002b4 	movhi	r20,10
   a4da0:	dc800315 	stw	r18,12(sp)
   a4da4:	dfc00a15 	stw	ra,40(sp)
   a4da8:	df000915 	stw	fp,36(sp)
   a4dac:	ddc00815 	stw	r23,32(sp)
   a4db0:	dd800715 	stw	r22,28(sp)
   a4db4:	dd400615 	stw	r21,24(sp)
   a4db8:	dcc00415 	stw	r19,16(sp)
   a4dbc:	dc400215 	stw	r17,8(sp)
   a4dc0:	dc000115 	stw	r16,4(sp)
   a4dc4:	d9000015 	stw	r4,0(sp)
   a4dc8:	2825883a 	mov	r18,r5
   a4dcc:	a5161204 	addi	r20,r20,22600
   a4dd0:	a4400017 	ldw	r17,0(r20)
   a4dd4:	8cc00c17 	ldw	r19,48(r17)
   a4dd8:	8c400c04 	addi	r17,r17,48
   a4ddc:	98004526 	beq	r19,zero,a4ef4 <__call_exitprocs+0x160>
   a4de0:	9c000117 	ldw	r16,4(r19)
   a4de4:	00900034 	movhi	r2,16384
   a4de8:	10bfffc4 	addi	r2,r2,-1
   a4dec:	9d402217 	ldw	r21,136(r19)
   a4df0:	85bfffc4 	addi	r22,r16,-1
   a4df4:	80a1883a 	add	r16,r16,r2
   a4df8:	8421883a 	add	r16,r16,r16
   a4dfc:	8421883a 	add	r16,r16,r16
   a4e00:	ac2f883a 	add	r23,r21,r16
   a4e04:	84000204 	addi	r16,r16,8
   a4e08:	9c21883a 	add	r16,r19,r16
   a4e0c:	b0002716 	blt	r22,zero,a4eac <__call_exitprocs+0x118>
   a4e10:	90000726 	beq	r18,zero,a4e30 <__call_exitprocs+0x9c>
   a4e14:	a800041e 	bne	r21,zero,a4e28 <__call_exitprocs+0x94>
   a4e18:	b5bfffc4 	addi	r22,r22,-1
   a4e1c:	bdffff04 	addi	r23,r23,-4
   a4e20:	843fff04 	addi	r16,r16,-4
   a4e24:	003ff906 	br	a4e0c <__alt_data_end+0xfffe4e0c>
   a4e28:	b9002017 	ldw	r4,128(r23)
   a4e2c:	913ffa1e 	bne	r18,r4,a4e18 <__alt_data_end+0xfffe4e18>
   a4e30:	99000117 	ldw	r4,4(r19)
   a4e34:	82000017 	ldw	r8,0(r16)
   a4e38:	213fffc4 	addi	r4,r4,-1
   a4e3c:	b100021e 	bne	r22,r4,a4e48 <__call_exitprocs+0xb4>
   a4e40:	9d800115 	stw	r22,4(r19)
   a4e44:	00000106 	br	a4e4c <__call_exitprocs+0xb8>
   a4e48:	80000015 	stw	zero,0(r16)
   a4e4c:	403ff226 	beq	r8,zero,a4e18 <__alt_data_end+0xfffe4e18>
   a4e50:	9f000117 	ldw	fp,4(r19)
   a4e54:	a8000526 	beq	r21,zero,a4e6c <__call_exitprocs+0xd8>
   a4e58:	00800044 	movi	r2,1
   a4e5c:	1592983a 	sll	r9,r2,r22
   a4e60:	a9404017 	ldw	r5,256(r21)
   a4e64:	494a703a 	and	r5,r9,r5
   a4e68:	2800021e 	bne	r5,zero,a4e74 <__call_exitprocs+0xe0>
   a4e6c:	403ee83a 	callr	r8
   a4e70:	00000906 	br	a4e98 <__call_exitprocs+0x104>
   a4e74:	a9004117 	ldw	r4,260(r21)
   a4e78:	4908703a 	and	r4,r9,r4
   a4e7c:	2000041e 	bne	r4,zero,a4e90 <__call_exitprocs+0xfc>
   a4e80:	b9400017 	ldw	r5,0(r23)
   a4e84:	d9000017 	ldw	r4,0(sp)
   a4e88:	403ee83a 	callr	r8
   a4e8c:	00000206 	br	a4e98 <__call_exitprocs+0x104>
   a4e90:	b9000017 	ldw	r4,0(r23)
   a4e94:	403ee83a 	callr	r8
   a4e98:	99000117 	ldw	r4,4(r19)
   a4e9c:	e13fcc1e 	bne	fp,r4,a4dd0 <__alt_data_end+0xfffe4dd0>
   a4ea0:	89000017 	ldw	r4,0(r17)
   a4ea4:	993fdc26 	beq	r19,r4,a4e18 <__alt_data_end+0xfffe4e18>
   a4ea8:	003fc906 	br	a4dd0 <__alt_data_end+0xfffe4dd0>
   a4eac:	00800034 	movhi	r2,0
   a4eb0:	10800004 	addi	r2,r2,0
   a4eb4:	10000f26 	beq	r2,zero,a4ef4 <__call_exitprocs+0x160>
   a4eb8:	99400117 	ldw	r5,4(r19)
   a4ebc:	99000017 	ldw	r4,0(r19)
   a4ec0:	2800091e 	bne	r5,zero,a4ee8 <__call_exitprocs+0x154>
   a4ec4:	20000826 	beq	r4,zero,a4ee8 <__call_exitprocs+0x154>
   a4ec8:	89000015 	stw	r4,0(r17)
   a4ecc:	a8000226 	beq	r21,zero,a4ed8 <__call_exitprocs+0x144>
   a4ed0:	a809883a 	mov	r4,r21
   a4ed4:	00000000 	call	0 <alt_exception_trap>
   a4ed8:	9809883a 	mov	r4,r19
   a4edc:	00000000 	call	0 <alt_exception_trap>
   a4ee0:	8cc00017 	ldw	r19,0(r17)
   a4ee4:	003fbd06 	br	a4ddc <__alt_data_end+0xfffe4ddc>
   a4ee8:	9823883a 	mov	r17,r19
   a4eec:	2027883a 	mov	r19,r4
   a4ef0:	003fba06 	br	a4ddc <__alt_data_end+0xfffe4ddc>
   a4ef4:	dfc00a17 	ldw	ra,40(sp)
   a4ef8:	df000917 	ldw	fp,36(sp)
   a4efc:	ddc00817 	ldw	r23,32(sp)
   a4f00:	dd800717 	ldw	r22,28(sp)
   a4f04:	dd400617 	ldw	r21,24(sp)
   a4f08:	dd000517 	ldw	r20,20(sp)
   a4f0c:	dcc00417 	ldw	r19,16(sp)
   a4f10:	dc800317 	ldw	r18,12(sp)
   a4f14:	dc400217 	ldw	r17,8(sp)
   a4f18:	dc000117 	ldw	r16,4(sp)
   a4f1c:	dec00b04 	addi	sp,sp,44
   a4f20:	f800283a 	ret

000a4f24 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   a4f24:	defffd04 	addi	sp,sp,-12
   a4f28:	df000215 	stw	fp,8(sp)
   a4f2c:	df000204 	addi	fp,sp,8
   a4f30:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   a4f34:	0001883a 	nop
   a4f38:	e0bfff17 	ldw	r2,-4(fp)
   a4f3c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   a4f40:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   a4f44:	10000226 	beq	r2,zero,a4f50 <_exit+0x2c>
    ALT_SIM_FAIL();
   a4f48:	002af070 	cmpltui	zero,zero,43969
   a4f4c:	00000106 	br	a4f54 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
   a4f50:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   a4f54:	003fff06 	br	a4f54 <__alt_data_end+0xfffe4f54>
